args:
- default: true
  description: List of devices to backup, comma separated
  name: devices
  required: true
- description: In seconds. If not provided, does not wait.
  name: waittimeout
comment: Connect to a checkpoint firewall appliance using SSH and retrieve status
  for backup tasks. The user account being used to access the device must be set to
  use the SSH shell and not the built in Checkpoint CLI. Consult the Checkpoint documentation
  for instructions on how to do this.
commonfields:
  id: CheckpointFWBackupStatus
  version: -1
dependson:
  must:
  - ssh
enabled: true
name: CheckpointFWBackupStatus
outputs:
- contextPath: CheckpointBackup.DeviceName
  description: Name of backed-up device
- contextPath: CheckpointBackup.System
  description: Backed up system
- contextPath: CheckpointBackup.Status
  description: Status of the backup process
- contextPath: CheckpointBackup.Path
  description: Path of backup file
script: "from re import escape\nCLI_SHOW = 'show backup status'\nBASH_SHOW = '/etc/cli.sh\
  \ -c \"' + CLI_SHOW + '\"'\nkeepPolling = True\nres = []\ntbl = []\ndevices = demisto.get(demisto.args(),\
  \ 'devices')\ndevicesBackupStarted = []\ndevicesBackupError = []\nif not devices:\n\
  \  res.append({\"Type\": entryTypes[\"error\"], \"ContentsFormat\": formats[\"text\"\
  ], \"Contents\": \"Received empty device list!\"})\nelse:\n  devices = ','.join(devices)\
  \ if isinstance(devices, list) else devices\n  sshArgs = {\"using\": devices,\n\
  \           \"cmd\": CLI_SHOW\n           }\n  while keepPolling:\n      resSSH\
  \ = demisto.executeCommand(\"ssh\", sshArgs)\n      try:\n          for entry in\
  \ resSSH:\n              if isError(entry):\n                  res += resSSH\n \
  \                 break\n              else:\n                  device = entry['ModuleName']\n\
  \                  if demisto.get(entry, 'Contents.success'):\n                \
  \      output = demisto.get(entry, 'Contents.output')\n                      backFileLoc\
  \ = output.find(\"Backup file location\")\n                      backFileLocEnd\
  \ = output.find(\"Backup process finished\")\n                      result = 'Answer\
  \ returned'\n                      devicesBackupStarted.append({\n             \
  \             'DeviceName' : device,\n                          'System' : demisto.get(entry,\
  \ 'Contents.system'),\n                          'Status': (\"Done\" if output.find(\"\
  local backup succeeded.\") > -1 else \"Pending\"),\n                          'Path':\
  \ (output[backFileLoc+len(\"Backup file location: \") : backFileLocEnd-1] if backFileLoc\
  \ > -1 else None)\n                          })\n                  else:\n     \
  \                 devicesBackupError.append(device)\n                      output\
  \ = \"Output:\\n\" + str(demisto.get(entry, 'Contents.output')) + \"Error:\\n\"\
  \ + str(demisto.get(entry, 'Contents.error'))\n                      result = 'Failed\
  \ to query'\n\n                  tbl.append({'DeviceName': device, 'System': demisto.get(entry,\
  \ 'Contents.system'), 'Query result': result, 'Output': output })\n      except\
  \ Exception as ex:\n          res.append({\"Type\": entryTypes[\"error\"], \"ContentsFormat\"\
  : formats[\"text\"],\n                      \"Contents\": \"Error occurred while\
  \ parsing output from command. Exception info:\\n\" + str(ex) + \"\\n\\nInvalid\
  \ output:\\n\" + str(resSSH)})\n      keepPolling = False\n  demisto.setContext('CheckpointBackup',\
  \ devicesBackupStarted)\n\n  res.append({\"Type\": entryTypes[\"note\"], \"ContentsFormat\"\
  : formats[\"table\"], \"Contents\": tbl})\ndemisto.results(res)\n\n"
scripttarget: 0
subtype: python2
tags:
- checkpoint
timeout: 0s
toversion: 4.1.9
type: python
