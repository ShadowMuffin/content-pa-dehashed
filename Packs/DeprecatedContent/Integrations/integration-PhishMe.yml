category: Data Enrichment & Threat Intelligence
commonfields:
  id: Phishme Intelligence
  version: -1
configuration:
- defaultvalue: https://www.threathq.com/apiv1
  display: Server URL (e.g https://www.threathq.com/apiv1)
  name: url
  required: true
  type: 0
- defaultvalue: ''
  display: API username
  name: credentials
  required: true
  type: 9
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: Major
  display: URL Threshold (None, Minor, Moderate or Major). Minimum severity to consider
    the URL malicious
  name: urlThreshold
  required: false
  type: 0
- defaultvalue: Major
  display: File Threshold (None, Minor, Moderate or Major). Minimum severity to consider
    the file malicious
  name: fileThreshold
  required: false
  type: 0
- defaultvalue: Major
  display: IP Threshold (None, Minor, Moderate or Major). Minimum severity to consider
    the IP malicious
  name: ipThreshold
  required: false
  type: 0
- defaultvalue: Major
  display: Email Threshold (None, Minor, Moderate or Major). Minimum severity to consider
    the email malicious
  name: emailThreshold
  required: false
  type: 0
deprecated: true
description: Human-vetted, Phishing-specific Threat Intelligence from Phishme. Deprecated.
  Use the Cofense Intelligence integration instead.
detaileddescription: 'Human-vetted, Phishing-specific Threat Intelligence from PhishMe.

  How to get the API key:

  Log in to your PhishMe account.

  Go to Settings

  API Tokens tab.

  Click on "Add a new api token"'
display: Phishme Intelligence
hidden: false
image: data:image/png;base64,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
name: Phishme Intelligence
script:
  commands:
  - arguments:
    - default: true
      description: URL to get the reputation for
      name: url
      required: true
    description: Checks the reputation of a URL.
    name: url
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
    - contextPath: DBotScore.Type
      description: Indicator type
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    - contextPath: PhishMe.URL.Data
      description: Bad URLs found
    - contextPath: PhishMe.URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision
    - contextPath: PhishMe.URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision
    - contextPath: PhishMe.URL.PhishMe.ThreatIDs
      description: The thread ids retrieved by the vendor.
  - arguments:
    - default: true
      description: Hash of the file to get the reputation of (MD5, SHA-1, or SHA-256).
        You can pass CSV list to efficiently retrieve multiple responses.
      name: file
      required: true
    description: Checks the reputation of a file hash.
    name: file
    outputs:
    - contextPath: File.MD5
      description: File MD5
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
    - contextPath: DBotScore.Type
      description: Indicator type
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    - contextPath: PhishMe.File.MD5
      description: File MD5
    - contextPath: PhishMe.File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
    - contextPath: PhishMe.File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision
    - contextPath: PhishMe.File.ThreatIDs
      description: The thread ids retrieved by the vendor.
  - arguments:
    - default: true
      description: IP address to check
      name: ip
      required: true
    description: Check the reputation of an IP address.
    name: ip
    outputs:
    - contextPath: IP.Data
      description: Bad IP Address found
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
    - contextPath: DBotScore.Type
      description: Indicator type
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    - contextPath: PhishMe.IP.Data
      description: Bad IP Address found
    - contextPath: PhishMe.IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision
    - contextPath: PhishMe.IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision
    - contextPath: PhishMe.IP.PhishMe.ThreatIDs
      description: The thread ids retrieved by the vendor.
    - contextPath: IP.ASN
      description: Autonomous System name for the IP.
    - contextPath: IP.GEO.Location
      description: Location in format latitude, longitude.
    - contextPath: IP.GEO.Country
      description: Country of the IP.
  - arguments:
    - default: true
      description: String to search
      name: str
      required: true
    - defaultValue: '10'
      description: Limit of strings to search
      name: limit
    description: Search for extracted strings identified within malware campaigns.
    name: phishme-search
    outputs:
    - contextPath: PhishMe.NumOfThreats
      description: Number of threats
    - contextPath: PhishMe.String
      description: String to search
  - arguments:
    - default: true
      description: Sender email address to get the reputation of
      name: email
      required: true
    description: Check the reputation of an email address.
    name: email
    outputs:
    - contextPath: Email.Data
      description: Sender address to check.
    - contextPath: Account.Email.Address
      description: Sender email address to check
    - contextPath: Account.Email.Malicious.Vendor
      description: For malicious emails, the vendor that made the decision
    - contextPath: Account.Email.Malicious.Description
      description: For malicious emails, the reason that the vendor made the decision
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested
    - contextPath: DBotScore.Type
      description: Indicator type
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
    - contextPath: DBotScore.Score
      description: The actual score
    - contextPath: PhishMe.Email.Data
      description: Sender address to check.
    - contextPath: PhishMe.Email.Malicious.Vendor
      description: For malicious emails, the vendor that made the decision
    - contextPath: PhishMe.Email.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision
    - contextPath: PhishMe.Email.PhishMe.ThreatIDs
      description: The thread ids retrieved by the vendor.
  runonce: false
  script: "var auth = 'Basic ' + Base64.encode(params.credentials.identifier + ':'\
    \ + params.credentials.password);\n\nvar sendRequest = function(method,api,urlargs)\
    \ {\n\n    var url = params.url;\n    if (url[url.length - 1] === '/') {\n   \
    \     url = url.substring(0, url.length - 1);\n    }\n\n    var requestUrl = url\
    \ + '/' + api + encodeToURLQuery(urlargs);\n    var res = http(\n        requestUrl,\n\
    \        {\n            Method: method,\n            Headers: {\n            \
    \    'Authorization': [auth]\n            }\n        },\n        params.insecure,\n\
    \        params.proxy\n    );\n\n    if ((res.StatusCode < 200 || res.StatusCode\
    \ >= 300) && res.success === false) {\n        throw 'PhishMe Request Failed.\\\
    nStatus code: ' + res.StatusCode + '.\\nBody: ' + JSON.stringify(res) + '.';\n\
    \    }\n\n    try{\n        return JSON.parse(res.Body);\n    }\n    catch(exc){\n\
    \        throw \"PhishMe Error: JSON parse error\\n\" + res;\n    }\n};\n\nvar\
    \ addMD = function(threat) {\n    var md = \"\";\n    md += '### Threat ID: '\
    \ + threat.id + '\\n';\n\n    if (threat.label !== undefined) {\n        md +=\
    \ \"Name of the campaign: **\" + threat.label + \"**\\n\";\n    }\n    if (threat.blockSet[0].ipDetail\
    \ !== undefined) {\n        md += \"ASN: **\" + threat.blockSet[0].ipDetail.asn\
    \ + \" \" + threat.blockSet[0].ipDetail.asnOrganization+\"**\\n\";\n    }\n  \
    \  if (threat.blockSet[0].ipDetail !== undefined) {\n        md += \"Country:\
    \ **\" + threat.blockSet[0].ipDetail.countryName + \"**\\n\";\n    }\n    if (threat.executiveSummary\
    \ !== undefined) {\n        md += \"#### Executive Summary: \\n\";\n    }\n  \
    \  if (threat.executiveSummary !== undefined) {\n        md += threat.executiveSummary\
    \ + \"\\n\";\n    }\n\n    md += \"#### Threat Types:\\n\";\n    for (var j =\
    \ 0; j < threat.malwareFamilySet.length; j++){\n        md += \"* \" + threat.malwareFamilySet[j].description\
    \ + \"\\n\";\n    }\n    md += '##### Last published: ' + new Date(threat.lastPublished)\
    \ +'\\n';\n    return md;\n};\n\n// Returns {severityScore: 'The severity score\
    \ found', md: 'The markdown for the threat', indicatorFound: 'set to true if indicator\
    \ was found in threat'}\nvar checkThreat = function(threat, threshold, indicator)\
    \ {\n    var severityLevel = 0;\n    var md = '';\n    var threshold_score = calcScore(threshold);\n\
    \    if (threshold_score === -1) {\n        throw \"Phishme error: Invalid threshold\
    \ value: \" + threshold + \". Valid values are: None, Minor, Moderate or Major.\"\
    ;\n    }\n    res = {}\n    for (var i = 0; i < threat.blockSet.length; i++){\n\
    \        if (threat.blockSet[i]['impact']) {\n            var threat_score = calcScore(threat.blockSet[i]['impact']);\n\
    \            var adjusted_score = threshold_score <= threat_score ? 3 : threat_score;\n\
    \            // if the queried indicator has a severity level, we'll take it\n\
    \            if (threat.blockSet[i]['data'] === indicator) {\n               \
    \ severityLevel = adjusted_score;\n                res.indicatorFound = true;\n\
    \                break;\n            }\n            severityLevel = Math.max(severityLevel,\
    \ adjusted_score);\n        }\n    }\n    var threatLevel = calcVerdict(severityLevel);\n\
    \    md += 'Verdict: ' + threatLevel +'\\n';\n    md += addMD(threat);\n    res.severityScore\
    \ = severityLevel;\n    res.md = md;\n    return res;\n}\n\nvar searchUrl = function(url)\
    \ {\n    var tmpargs = {};\n    tmpargs.urlSearch = url;\n    var res = sendRequest(\"\
    POST\",\"threat/search\",tmpargs);\n    var threats = res.data.threats;\n    var\
    \ ec = {};\n    var md = \"## PhishMe URL Reputation for: \"+url+\"\\n\";\n  \
    \  var dbotScore = 0;\n    var threatArray = [];\n    var threshold = params.urlThreshold;\n\
    \    var indicatorFnd = false;\n    if (threats.length && threats.length !== 0)\
    \ {\n        ec[outputPaths.url] = {\n            Data: url\n        };\n    \
    \    for (var k = 0; k < threats.length; k++) {\n            threatAnalysis =\
    \ checkThreat(threats[k], threshold, url);\n            threatArray[k] = threats[k].id;\n\
    \            md += threatAnalysis['md'];\n            if (threatAnalysis.indicatorFound)\
    \ {\n                indicatorFnd = true;\n                dbotScore = threatAnalysis['severityScore'];\n\
    \            } else if (!indicatorFnd) {\n                dbotScore = Math.max(dbotScore,\
    \ threatAnalysis['severityScore']);\n            }\n        }\n\n        ec[outputPaths.url]['PhishMe']\
    \ = {};\n        ec[outputPaths.url].PhishMe['ThreatIDs'] = threatArray;\n   \
    \     ec[\"PhishMe.\" + outputPaths.url] = {\n            Data: url,\n       \
    \     ThreatIDs: threatArray\n        };\n        if (dbotScore === 3) {\n   \
    \         ec[outputPaths.url].Malicious = {\n                Vendor: 'PhishMe',\n\
    \                Description: 'Match found in PhishMe database'\n            };\n\
    \            ec[\"PhishMe.\" + outputPaths.url].Malicious = ec[outputPaths.url].Malicious;\n\
    \        }\n    } else {\n        md += \"No information found for this url\"\
    ;\n    }\n\n    ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'PhishMe',\
    \ Score: dbotScore};\n\n    return ( {'ContentsFormat': formats.json, 'Type':\
    \ entryTypes.note, 'Contents': res, \"HumanReadable\": md, \"EntryContext\": ec}\
    \ );\n};\n\nvar extractedString = function(str,limit) {\n    var tmpargs = {};\n\
    \    tmpargs.extractedString = str;\n    var res = sendRequest(\"POST\",\"threat/search\"\
    ,tmpargs);\n    var threats = res.data.threats;\n    var countThreats = 0;\n \
    \   var md = \"## PhishMe Search Reputation for: \"+str+\"\\n\";\n    var mdBody\
    \ = \"\";\n    var ec = {};\n\n    if (threats.length !== 0) {\n        if(limit\
    \ === undefined){\n            limit = 10;\n        }\n\n        for(var i = 0;\
    \ i < threats.length && (countThreats<limit); i++){\n            if (threats[i].hasReport\
    \ === true){\n                countThreats += 1;\n                mdBody += addMD(threats[i]);\n\
    \            }\n        }\n\n        md += \"There are \" + countThreats + \"\
    \ threats regarding your string search.\\n\";\n        md += \"### Details from\
    \ the last campaign\\n\";\n        md += mdBody;\n\n        ec = {\"PhishMe\"\
    \ : {}};\n        ec.PhishMe = {\"String\": str, \"NumOfThreats\": countThreats};\n\
    \n    } else {\n        md += \"There are no results for this search\\n\";\n \
    \       ec = {\"PhishMe\" : {}};\n        ec.PhishMe = {\"String\": str, \"NumOfThreats\"\
    : 0};\n    }\n\n    return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note,\
    \ 'Contents': res, \"HumanReadable\": md, \"EntryContext\": ec} );\n};\n\nvar\
    \ checkEmail = function(sender_name) {\n    var tmpargs = {};\n    tmpargs.watchListEmail\
    \ = sender_name;\n    var res = sendRequest(\"POST\",\"threat/search\",tmpargs);\n\
    \    var threats = res.data.threats;\n    var ec = {};\n    var md = \"## PhishMe\
    \ email Reputation for: \" + sender_name + \"\\n\";\n    var dbotScore = 0;\n\
    \    var threatArray = [];\n    var threshold = params.emailThreshold;\n    var\
    \ indicatorFnd = false;\n    var contextEmailKey = 'Email(val.Data && val.Data\
    \ === obj.Data)';\n    if (threats.length && threats.length !== 0) {\n       \
    \ ec[contextEmailKey] = {\n            'Data': sender_name\n        };\n     \
    \   ec[outputPaths.email] = {\n            'Address': sender_name\n        };\n\
    \        for (var k = 0; k < threats.length; k++) {\n            threatAnalysis\
    \ = checkThreat(threats[k], threshold, sender_name);\n            threatArray[k]\
    \ = threats[k].id;\n            md += threatAnalysis['md'];\n            if (threatAnalysis.indicatorFound)\
    \ {\n                indicatorFnd = true;\n                dbotScore = threatAnalysis['severityScore'];\n\
    \            } else if (!indicatorFnd) {\n                dbotScore = Math.max(dbotScore,\
    \ threatAnalysis['severityScore']);\n            }\n        }\n        ec[contextEmailKey]['PhishMe']\
    \ = {};\n        ec[contextEmailKey].PhishMe['ThreatIDs'] = threatArray;\n   \
    \     ec['PhishMe.' + contextEmailKey] = {\n            Data: sender_name,\n \
    \           ThreatIDs: threatArray\n        };\n        if (dbotScore === 3) {\n\
    \            ec[outputPaths.email].Malicious = {\n                Vendor: 'PhishMe',\n\
    \                Description: 'Match found in PhishMe database'\n            };\n\
    \            ec[\"PhishMe.\" + contextEmailKey].Malicious = ec[outputPaths.email].Malicious;\n\
    \        }\n\n    } else {\n        md += \"No infomation found for this email\"\
    ;\n    }\n\n    ec.DBotScore = {Indicator: sender_name, Type: 'email', Vendor:\
    \ 'PhishMe', Score: dbotScore};\n\n    return ( {'ContentsFormat': formats.json,\
    \ 'Type': entryTypes.note, 'Contents': res, \"HumanReadable\": md, \"EntryContext\"\
    : ec} );\n};\n\nvar checkMD5 = function(str) {\n    var tmpargs = {};\n    tmpargs.allMD5\
    \ = str;\n    var res = sendRequest(\"POST\",\"threat/search\",tmpargs);\n   \
    \ var threats = res.data.threats;\n    var ec = {};\n    var md = \"## PhishMe\
    \ Hash Reputation for: \"+str+\"\\n\";\n    var dbotScore = 0;\n    var threatArray\
    \ = [];\n    var threshold = params.fileThreshold;\n    var indicatorFnd = false;\n\
    \    var threshold_score = calcScore(threshold);\n    if (threshold_score ===\
    \ -1) {\n        throw \"Phishme error: Invalid threshold value: \" + threshold\
    \ + \". Valid values are: None, Minor, Moderate or Major.\";\n    }\n    if (threats.length\
    \ !== 0) {\n        ec[outputPaths.file] = {\n            MD5: str\n        };\n\
    \        for (var k = 0; k < threats.length; k++) {\n            var severityLevel\
    \ = 0;\n            for (var i = 0; i < threats[k].blockSet.length; i++){\n  \
    \              if (threats[k].blockSet[i]['impact']) {\n                    var\
    \ threat_score = calcScore(threats[k].blockSet[i]['impact']);\n              \
    \      var adjusted_score = threshold_score <= threat_score ? 3 : threat_score;\n\
    \                    // if the queried indicator has a severity level, we'll take\
    \ it\n                    if (threats[k].executableSet[i] && threats[k].executableSet[i]['md5Hex']\
    \ === str) {\n                        severityLevel = adjusted_score;\n      \
    \                  dbotScore = severityLevel;\n                        indicatorFnd\
    \ = true;\n                        break;\n                    }\n           \
    \         severityLevel = Math.max(severityLevel, adjusted_score);\n         \
    \       }\n            }\n            var threatLevel = calcVerdict(severityLevel);\n\
    \            md += 'Verdict: ' + threatLevel +'\\n';\n            md += addMD(threats[k]);\n\
    \            threatArray[k] = threats[k].id;\n            if (!indicatorFnd) {\n\
    \                dbotScore = Math.max(dbotScore, severityLevel);\n           \
    \ }\n        }\n        ec[outputPaths.file]['PhishMe'] = {};\n        ec[outputPaths.file]['ThreatIDs']\
    \ = threatArray;\n        ec['PhishMe.' + outputPaths.file] = {\n            \
    \    MD5: str,\n                ThreatIDs: threatArray\n        };\n        if\
    \ (dbotScore === 3) {\n            ec[outputPaths.file].Malicious = {\n      \
    \          Vendor: 'PhishMe',\n                Description: 'Match found in PhishMe\
    \ database'\n            };\n            ec[\"PhishMe.\" + outputPaths.file].Malicious\
    \ = ec[outputPaths.file].Malicious;\n        }\n    } else {\n        md += \"\
    No information found for this hash\";\n    }\n\n    ec.DBotScore = {Indicator:\
    \ str, Type: 'file', Vendor: 'PhishMe', Score: dbotScore};\n\n    return ( {'ContentsFormat':\
    \ formats.json, 'Type': entryTypes.note, 'Contents': res, \"HumanReadable\": md,\
    \ \"EntryContext\": ec} );\n}\n\nvar checkIP = function(ip) {\n    var tmpargs\
    \ = {};\n    tmpargs.ip = ip;\n    var res = sendRequest(\"POST\",\"threat/search\"\
    ,tmpargs);\n    var threats = res.data.threats;\n    var ec = {};\n    var md\
    \ = \"## PhishMe IP Reputation for: \"+ip+\"\\n\";\n    var dbotScore = 0;\n \
    \   var threatArray = [];\n    var threshold = params.ipThreshold;\n    var indicatorFnd\
    \ = false;\n    var threshold_score = calcScore(threshold);\n    if (threshold_score\
    \ === -1) {\n        throw \"Phishme error: Invalid threshold value: \" + threshold\
    \ + \". Valid values are: None, Minor, Moderate or Major.\";\n    }\n    if (threats.length\
    \ && threats.length !== 0) {\n        ec[outputPaths.ip] = {\n            Data:\
    \ ip\n        };\n        for (var k = 0; k < threats.length; k++) {\n       \
    \     var severityLevel = 0;\n            for (var i = 0; i < threats[k].blockSet.length;\
    \ i++){\n                if (threats[k].blockSet[i].data === ip && threats[k].blockSet[i].ipDetail)\
    \ {\n                    ec[outputPaths.ip].ASN = threats[k].blockSet[i].ipDetail.asn;\n\
    \                    ec[outputPaths.ip].GEO = {\n                        \"Location\"\
    : (threats[k].blockSet[i].ipDetail.latitude + ', ' + threats[k].blockSet[i].ipDetail.longitude),\n\
    \                        \"Country\": threats[k].blockSet[i].ipDetail.countryIsoCode\n\
    \                    };\n                }\n                if (threats[k].blockSet[i]['impact'])\
    \ {\n                    var threat_score = calcScore(threats[k].blockSet[i]['impact']);\n\
    \                    var adjusted_score = threshold_score <= threat_score ? 3\
    \ : threat_score;\n                    // if the queried indicator has a severity\
    \ level, we'll take it\n                    if (threats[k].blockSet[i]['ipDetail']\
    \ && threats[k].blockSet[i]['ipDetail']['ip']===ip) {\n                      \
    \  severityLevel = adjusted_score;\n                        dbotScore = severityLevel;\n\
    \                        indicatorFnd = true;\n                        break;\n\
    \                    }\n                    severityLevel = Math.max(severityLevel,\
    \ adjusted_score);\n                }\n            }\n            var threatLevel\
    \ = calcVerdict(severityLevel);\n            md += 'Verdict: ' + threatLevel +'\\\
    n';\n            md += addMD(threats[k]);\n            threatArray[k] = threats[k].id;\n\
    \            if (!indicatorFnd) {\n                dbotScore = Math.max(dbotScore,\
    \ severityLevel);\n            }\n        }\n        ec[outputPaths.ip]['PhishMe']\
    \ = {};\n        ec[outputPaths.ip].PhishMe['ThreatIDs'] = threatArray;\n    \
    \    ec[\"PhishMe.\" + outputPaths.ip] = {\n            Data: ip,\n          \
    \  ThreatIDs: threatArray\n        };\n        if (dbotScore === 3) {\n      \
    \      ec[outputPaths.ip].Malicious = {\n                Vendor: 'PhishMe',\n\
    \                Description: 'Match found in PhishMe database'\n            };\n\
    \            ec[\"PhishMe.\" + outputPaths.ip].Malicious = ec[outputPaths.ip].Malicious;\n\
    \        }\n    } else {\n        md += \"No information found for this ip\";\n\
    \    }\n\n    ec.DBotScore = {Indicator: ip, Type: 'ip', Vendor: 'PhishMe', Score:\
    \ dbotScore};\n\n    return ( {'ContentsFormat': formats.json, 'Type': entryTypes.note,\
    \ 'Contents': res, \"HumanReadable\": md, \"EntryContext\": ec} );\n}\n\nvar calcVerdict\
    \ = function (dbotScore) {\n    switch (dbotScore){\n        case 0:\n       \
    \     return 'Unknown';\n        case 2:\n            return 'Suspicious';\n \
    \       case 3:\n            return 'Bad';\n    }\n}\n\nvar calcScore = function\
    \ (severityLevel) {\n    switch (severityLevel){\n        case 'None':\n     \
    \       return 0;\n        case 'Minor':\n            return 2;\n        case\
    \ 'Moderate':\n            return 2;\n        case 'Major':\n            return\
    \ 3;\n        default:\n            return -1;\n    }\n}\n\n\nfunction addDays(theDate,\
    \ days) {\n    return theDate.getTime() - days*24*60*60*1000;\n}\n\nvar updates\
    \ = function(){\n    var newDate = addDays(new Date(), 50);\n    var tmpargs =\
    \ {};\n    tmpargs.timestamp = newDate;\n    var res = sendRequest(\"POST\",\"\
    threat/updates\", tmpargs);\n    var ec = {};\n    var md = \"\";\n\n    return\
    \ res;\n}\n\nswitch (command) {\n    // This is the call made when pressing the\
    \ integration test button.\n    case 'test-module':\n        res = updates();\n\
    \        if (res.success === true){\n            return 'ok';\n        }else {\n\
    \            return JSON.stringify(res);\n        }\n\n    case \"url\":\n   \
    \     return searchUrl(args.url);\n\n    case \"phishme-search\":\n        return\
    \ extractedString(args.str, args.limit);\n\n    case \"email\":\n        return\
    \ checkEmail(args.email)\n\n    case \"file\":\n        return checkMD5(args.file);\n\
    \n    case \"ip\":\n        return checkIP(args.ip);\n    default:\n}\n"
  type: javascript
tests:
- No test - Replaced by Cofense Integration
toversion: 4.1.9
