args:
- description: The name of the text file (format is described in the script details).
    The file should be attached in the war room.
  name: trainingFileName
  required: true
- description: The name of the list to store the model binary (as base64). The list
    must be exist in Demisto (with any value).
  name: modelStoreListName
  required: true
- defaultValue: '0.7'
  description: Precision threshold - model will be store only above this threshold.
  name: precisionThreshold
comment: This script is deprecated. See https://xsoar.pan.dev/docs/reference/playbooks/d-bot-create-phishing-classifier-v2
  for more information.
commonfields:
  id: DBotTrainTextClassifier
  version: -1
deprecated: true
dockerimage: demisto/dl:1.1
enabled: true
fromversion: 4.1.0
name: DBotTrainTextClassifier
outputs:
- contextPath: DBotTextClassifier.TrainDataSize
  description: The number of training samples
  type: number
- contextPath: DBotTextClassifier.ListName
  description: Model list name in Demisto
- contextPath: DBotTextClassifier.Precision
  description: Model precision (precent)
  type: number
- contextPath: DBotTextClassifier.Recall
  description: Model recall (precent)
  type: number
runonce: true
script: "import base64, sys, uuid, zlib\nimport demisto_ml\n\nMODEL_LIST = demisto.args()['modelStoreListName']\n\
  TRAINING_FILE_NAME = demisto.args()['trainingFileName']\nTEST_ABOVE_THRESHOLD =\
  \ float(demisto.args()['precisionThreshold'])\n\ndef get_file_path(file_name):\n\
  \    file_name = file_name.strip()\n    res = demisto.dt(demisto.context(), \"File(val.Name\
  \ == '%s')\" % file_name)\n    if type(res) is list:\n        res = res[0]\n   \
  \ entry_id = res['EntryID']\n    res = demisto.executeCommand(\"getFilePath\", {\"\
  id\": entry_id})\n    if res[0]['Type'] == entryTypes['error']:\n        demisto.results(res)\n\
  \        sys.exit(0)\n    return res[0]['Contents']['path']\n\n\ndef combine_files(file_paths):\n\
  \    if len(file_paths) == 1:\n        return file_paths[0]\n    combined_file_path\
  \ = str(uuid.uuid4()) + \".txt\"\n    with open(combined_file_path, 'wb') as out:\n\
  \        for file_path in file_paths:\n            with open(file_path, 'rb') as\
  \ f:\n                out.write(f.read())\n    return combined_file_path\n\n# get\
  \ file path\nif type(TRAINING_FILE_NAME) is list:\n    file_names = TRAINING_FILE_NAME\n\
  else:\n    file_names = TRAINING_FILE_NAME.split(\",\")\n    file_names = [f for\
  \ f in file_names if f]\nfile_paths = map(get_file_path, file_names)\ntraining_file_path\
  \ = combine_files(file_paths)\n\n# evaluate model\ntrain_amount, (test_amount, precision,\
  \ recall) = demisto_ml.get_model_precision(training_file_path)\ndemisto.log(\"Model\
  \ evaluation trained on %d samples and tested on %d samples:\\nPrecision:%.2f%%\\\
  nRecall:%.2f%%\" % (train_amount, test_amount, precision*100, recall*100))\ntotal_amount\
  \ = train_amount + test_amount\nif precision <= TEST_ABOVE_THRESHOLD:\n    return_error(\"\
  Model evaluation is below %.2f threshold, do not store model\" % TEST_ABOVE_THRESHOLD)\n\
  \n# train model\ntry:\n    model = demisto_ml.train_text_model(training_file_path,\
  \ True)\n    encoded_model = demisto_ml.encode_model(model)\nexcept Exception:\n\
  \    return_error(\"An error occurred while training model\")\n\nres = demisto.executeCommand(\"\
  createList\", {\"listName\": MODEL_LIST, \"listData\": encoded_model})\nif isError(res[0]):\n\
  \    demisto.results(res)\n    sys.exit(0)\n\nmodel_summary = {\n    'ListName':\
  \ MODEL_LIST,\n    'TrainDataSize': total_amount,\n    'Precision': \"%.2f\" % precision,\n\
  \    'Recall': \"%.2f\" % recall\n}\n\ndemisto.results({\n    \"EntryContext\":\
  \ {\n        'DBotTextClassifier': model_summary\n    },\n    'HumanReadable': 'Done\
  \ training',\n    'HumanReadableFormat': formats['text'],\n    'Contents': model_summary,\n\
  \    'ContentsFormat': formats['json']\n})\n\n\n\n"
scripttarget: 0
subtype: python2
tags:
- phishing
- ml
tests:
- No tests
timeout: "60\xB5s"
toversion: 4.1.9
type: python
