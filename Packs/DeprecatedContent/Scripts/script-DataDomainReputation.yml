args:
- default: true
  description: URL to look up
  name: input
  required: true
- description: Time in minutes that cache should be valid for
  name: cacheExpiration
  required: false
- auto: PREDEFINED
  defaultValue: 'no'
  description: Whether to calculate reputation even if it is manual set - yes/no
  name: forceCalc
  predefined:
  - 'yes'
  - 'no'
comment: Evaluate reputation of a URL and Domain and return a score between 0 and
  3 (0 - unknown, 1 - known good, 2 - suspicious, 3 - known bad). If the indicator
  reputation was manually set, the manual value will be returned.
commonfields:
  id: DataDomainReputation
  version: -1
deprecated: true
enabled: true
fromversion: 3.1.0
name: DataDomainReputation
script: "\nfunction calculateScore(scores) {\n  var score = -1;\n  for (var i = 0;\
  \ scores && i < scores.length; i++) {\n      if (scores[i] && score < scores[i])\
  \ {\n        score = scores[i];\n      }\n  }\n  return score < 0 ? 0 : score;\n\
  }\n\nfunction calculateReputation(value, cacheExpiration, forceCalc, command, argName,\
  \ typeName) {\n  var cachedBrands = [];\n  var scores = [];\n  var res = executeCommand(\"\
  getIndicator\", {\"value\": value});\n  if (forceCalc != 'yes' && res[0] && res[0].Contents[0]\
  \ && res[0].Contents[0].manualScore) {\n      return res[0].Contents[0].score;\n\
  \  }\n  // Get all indicator cached data\n  var cache = executeCommand(\"getIndicatorScoreCache\"\
  , {value: value});\n  if (cache && cache.length > 0 && cache[0].Contents) {\n  \
  \    var latestCacheTime = new Date().getTime() - (cacheExpiration * 60 * 1000);\n\
  \      var cachedScores = cache[0].Contents[0].scores;\n      if (cachedScores)\
  \ {\n          // Iterate on cache according to different vendors\n          var\
  \ scoreKeys = Object.keys(cachedScores);\n          scoreKeys.forEach(function (key)\
  \ {\n              cachedTime = cachedScores[key].timestamp;\n              if (cachedTime\
  \ && (new Date(cachedTime)).getTime() > latestCacheTime) {\n                  //We\
  \ have a valid cache hit, we should capture the score and not query it again\n \
  \                 scores.push(cachedScores[key].score);\n                  cachedBrands.push(key);\n\
  \              }\n          });\n      }\n  }\n  var brands = {};\n  // Get all\
  \ brands that were not in the cache\n  var allModules = getModulesForCommand(command);\n\
  \  if (allModules) {\n      var instanceKeys = Object.keys(allModules);\n      instanceKeys.forEach(function\
  \ (key) {\n          if (allModules[key].state === 'active' && cachedBrands.indexOf(allModules[key].brand)\
  \ === -1) {\n              brands[allModules[key].brand] = true;\n          }\n\
  \      });\n  }\n  var brandArr = Object.keys(brands);\n  if (brandArr.length >\
  \ 0) {\n      // Run the other reputation scripts only if there are new brands that\
  \ were not used\n      var brandStr = brandArr.join(',');\n      var cmdArgs = {\
  \ 'using-brand': brandStr };\n      cmdArgs[argName] = value;\n      var rep = executeCommand(command,\
  \ cmdArgs);\n      var newScores = dq(rep, 'EntryContext.DBotScore.Score');\n  \
  \    scores = scores.concat(newScores);\n  }\n  return calculateScore(scores);\n\
  }\n\nvar score = calculateReputation(args.input, args.cacheExpiration, args.forceCalc,\
  \ 'url', 'url', 'URL');\nscore = score < 0 ? 0 : score;\nvar domainRes = executeCommand('ExtractDomain',\
  \ {text: args.input});\nvar domain = domainRes[0].Contents[0].Name;\n\nvar domainScore\
  \ = calculateReputation(domain, args.cacheExpiration, args.forceCalc, 'domain',\
  \ 'domain', 'Domain');\n\nif (domainScore > score) {\n    score = domainScore;\n\
  }\nreturn score;"
scripttarget: 0
tags:
- reputation
toversion: 4.1.9
type: javascript
