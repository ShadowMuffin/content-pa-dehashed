args:
- default: true
  description: Entry ID of an email file
  name: entryId
  required: true
comment: Deprecated - use `ParseEmailFiles parse_only_headers=true`. This automation
  parses headers from an email file.
commonfields:
  id: ParseEmailHeader
  version: -1
deprecated: true
enabled: true
name: ParseEmailHeaders
outputs:
- contextPath: Email.Headers
  description: The headers of the email
  type: Unknown
- contextPath: Email.Headers.From
  description: This displays who the message is from, however, this can be easily
    forged and can be the least reliable.
  type: Unknown
- contextPath: Email.Headers.To
  description: This shows to whom the message was addressed, but may not contain the
    recipient's address.
  type: Unknown
- contextPath: Email.Headers.Subject
  description: Email subject
  type: String
- contextPath: Email.Headers.Date
  description: The date and time the email message was composed
  type: Unknown
- contextPath: Email.Headers.CC
  description: Email 'cc' addresses
  type: Unknown
- contextPath: Email.Headers.Reply-To
  description: The email address for return mail
  type: String
- contextPath: Email.Headers.Received
  description: List of all the servers/computers through which the message traveled
  type: String
- contextPath: Email.Headers.Message-ID
  description: A unique string assigned by the mail system when the message is first
    created. These can easily be forged. (e.g. 5c530c1b.1c69fb81.bd826.0eff@mx.google.com)
  type: String
runas: DBotWeakRole
runonce: false
script: "import json\n\n\ndef main():\n    execute_command_result = demisto.executeCommand(\"\
  ParseEmailFiles\", {\n        \"entryid\": demisto.args().get(\"entryId\"),\n  \
  \      \"parse_only_headers\": \"true\",\n        \"max_depth\": \"1\"\n    })\n\
  \    if is_error(execute_command_result):\n        return_error(get_error(execute_command_result))\n\
  \n    parsed_email_headers = None\n    readable_output = \"\"\n    for command_result\
  \ in execute_command_result:\n        if command_result.get(\"EntryContext\") is\
  \ not None \\\n           and \"Email\" in command_result.get(\"EntryContext\"):\n\
  \            parsed_email = command_result.get(\"EntryContext\").get(\"Email\")\n\
  \n            if \"HeadersMap\" in parsed_email:\n                # msg files will\
  \ have HeadersMap as dict\n                parsed_email_headers = parsed_email.get(\"\
  HeadersMap\")\n\n            readable_output = command_result.get('HumanReadable')\n\
  \n    if parsed_email_headers is None:\n        return_outputs(readable_output=\"\
  Couldn't find Headers outputs\" + demisto.args()['entryId'] + \"\\n\",\n       \
  \                outputs=None)\n\n    return_outputs(\n        readable_output=readable_output,\n\
  \        outputs={\n            \"Email\": {\n                \"Headers\": parsed_email_headers\n\
  \            }\n        },\n        raw_response=parsed_email_headers\n    )\n\n\
  \nif __name__ == '__builtin__':\n    main()"
scripttarget: 0
subtype: python2
tags:
- email
toversion: 4.1.9
type: python
