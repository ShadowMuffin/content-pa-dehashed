args:
- default: true
  description: War room entryID of the file to read.
  name: entryID
  required: true
- description: Maximal file size to load, in bytes. Default is 1MB.
  name: maxFileSize
comment: Load the contents and metadata of a PDF file into context.
commonfields:
  id: ReadPDFFile
  version: -1
deprecated: true
dockerimage: demisto/pdfx
enabled: true
fromversion: 4.1.0
name: ReadPDFFile
outputs:
- contextPath: URL.Data
  description: List of URLs that were extracted from the PDF file
- contextPath: File.Text
  description: The PDF File extracted text
- contextPath: File.Producer
  description: The PDF File producer
- contextPath: File.Title
  description: The PDF File Title
- contextPath: File.xap
  description: The PDF File xap
- contextPath: File.Author
  description: The PDF File Author
- contextPath: File.dc
  description: The PDF File dc
- contextPath: File.xapmm
  description: The PDF File xapmm
- contextPath: File.ModDate
  description: The PDF File ModDate
- contextPath: File.CreationDate
  description: The PDF File CreationDate
- contextPath: File.Pages
  description: Number of pages in PDF file
runas: DBotWeakRole
runonce: false
script: "import pdfx\nfrom pdfminer.psparser import PSEOF\nfrom pdfminer.pdfdocument\
  \ import PDFEncryptionError\nimport traceback\nimport sys\nreload(sys)\nsys.setdefaultencoding(\"\
  utf-8\")\n\nentry_id = demisto.args()[\"entryID\"]\n\ndef mark_suspicious(suspicious_reason):\n\
  \    \"\"\"Missing EOF, file may be corrupted or suspicious file\"\"\"\n\n    dbot\
  \ = {\n        \"DBotScore\":\n        {\n            \"Indicator\": entry_id,\n\
  \            \"Type\": \"file\",\n            \"Vendor\": \"PDFx\",\n          \
  \  \"Score\": 2\n        }\n    }\n\n    human_readable = \"{}, file marked as suspicious\
  \ for entry id: {}\".format(suspicious_reason, entry_id)\n\n    return_outputs(human_readable,\
  \ dbot, {})\n\n\n#File entity\npdf_file = {\n    \"EntryID\" : entry_id\n}\n\n#URLS\n\
  URLs = []\n\nmaxFileSize = demisto.get(demisto.args(), \"maxFileSize\")\nif maxFileSize:\n\
  \    maxFileSize = int(maxFileSize)\nelse:\n    maxFileSize = 1024**2\nres = demisto.executeCommand(\"\
  getFilePath\", {\"id\": entry_id})\nif isError(res[0]):\n    demisto.results(res)\n\
  else:\n    path = demisto.get(res[0],\"Contents.path\")\n    if path:\n        try:\n\
  \            pdf = pdfx.PDFx(path)\n        except PSEOF:\n            mark_suspicious('Missing\
  \ EOF')\n            sys.exit(0)\n        except PDFEncryptionError:\n         \
  \   mark_suspicious('Possibly encrypted file')\n            sys.exit(0)\n      \
  \  except TypeError:\n            tb = traceback.format_exc()\n            if 'pdf\
  \ = pdfx.PDFx(args.pdf)' in tb and \"out_str = in_str.decode(enc['encoding'])\"\
  \ in tb:\n                mark_suspicious(\"The script failed to read the PDF file.\
  \ This might happen if your PDF file contains only an image\")\n            else:\n\
  \                mark_suspicious(\"The script failed read PDF file due to an unknown\
  \ issue\")\n            sys.exit(0)\n\n        if not pdf:\n            demisto.results({\n\
  \                \"Type\": entryTypes[\"error\"],\n                \"ContentsFormat\"\
  : formats[\"text\"],\n                \"Contents\" : \"Could not load pdf file in\
  \ EntryID {0}\".format(entry_id)\n            })\n            sys.exit(0)\n\n\n\
  \        # Get metadata:\n        metadata = pdf.get_metadata()\n\n        # Get\
  \ text:\n        text = pdf.get_text()\n\n        # Get URLs:\n        references_dict\
  \ = pdf.get_references_as_dict()\n        if \"url\" in references_dict.keys():\n\
  \            for url in references_dict[\"url\"]:\n                URLs.append({\"\
  Data\":url})\n\n        #Add Text to file entity\n        pdf_file[\"Text\"] = text\n\
  \n        #Add Metadata to file entity\n        for k in metadata.keys():\n    \
  \        pdf_file[k] = metadata[k]\n\n        md = \"### Metadata\\n\"\n       \
  \ md += \"* \" if metadata else \"\"\n        md += \"\\n* \".join([\"{0}: {1}\"\
  .format(k,v) for k,v in metadata.iteritems()])\n\n        md += \"\\n### URLs\\\
  n\"\n        md += \"* \" if URLs else \"\"\n        md += \"\\n* \".join([\"{0}\"\
  .format(str(k[\"Data\"])) for k in URLs])\n\n        md += \"\\n### Text\"\n   \
  \     md += \"\\n{0}\".format(text)\n\n        demisto.results({\"Type\" : entryTypes[\"\
  note\"],\n                        \"ContentsFormat\" : formats[\"markdown\"],\n\
  \                        \"Contents\" : md,\n                        \"HumanReadable\"\
  : md,\n                        \"EntryContext\": {\"File(val.EntryID == obj.EntryID)\"\
  \ : pdf_file, \"URL\" : URLs}\n                        })\n\n        all_pdf_data\
  \ = \"\"\n        if metadata:\n            for k,v in metadata.iteritems():\n \
  \               all_pdf_data += str(v)\n        if text:\n            all_pdf_data\
  \ += text\n        if URLs:\n            for u in URLs:\n                u = u[\"\
  Data\"] + \" \"\n                all_pdf_data += u\n\n        # Extract indicators\
  \ (omitting context output, letting auto-extract work)\n        indicators_hr =\
  \ demisto.executeCommand(\"extractIndicators\", {\n            \"text\": all_pdf_data})[0][u\"\
  Contents\"]\n        demisto.results({\n            \"Type\": entryTypes[\"note\"\
  ],\n            \"ContentsFormat\": formats[\"json\"],\n            \"Contents\"\
  : indicators_hr,\n            \"HumanReadable\": indicators_hr\n             })\n\
  \n    else:\n        demisto.results({\n            \"Type\" : entryTypes[\"error\"\
  ],\n            \"ContentsFormat\" : formats[\"text\"],\n            \"Contents\"\
  \ : \"EntryID {0} path could not be found\".format(entry_id)\n             })"
scripttarget: 0
subtype: python2
tags:
- Utility
- ingestion
tests:
- No tests
toversion: 4.1.9
type: python
