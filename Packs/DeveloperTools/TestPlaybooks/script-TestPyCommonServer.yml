args:
- auto: PREDEFINED
  default: true
  defaultValue: DQ
  description: one of python common server testing features
  name: test_type
  predefined:
  - DQ
  - ENTRY
  - XML
  - TBLMD
  - FLTNCL
  - HASH
  - CAMELIZE
  - REPLACE_IN_KEYS
  - DATE_TO_TIMESTAMP
  - PASCAL_TO_SPACE
  - RETURN_OUTPUTS
  - APPEND_CONTEXT
  - REMOVE_DICTIONARY_NULLS
  required: true
comment: Tests for common function dq
commonfields:
  id: TestPYCommonServer
  version: -1
enabled: true
name: TestPYCommonServer
runas: DBotWeakRole
runonce: false
script: "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport copy\nimport unittest\n\
  \nINFO = {'b' : 1,\n    'a': {\n        'safd' : 3,\n        'b' : [\n         \
  \   {'c' : {'d' : 432}, 'd' : 2},\n            {'c' : {'f' : 1}},\n            {'b'\
  \ : 1234},\n            {'c' : {'d' : 4567}},\n            {'c' : {'d' : 11}},\n\
  \            {'c' : {'d' : u'asdf'}}],\n        'c' : {'d' : 10},\n        }\n \
  \   }\n\ndef test_dq():\n    # expected_x = [432, 4567, 11, 'asdf']\n    # x = dq(INFO,\
  \ 'a.b.c.d'.split('.'))\n\n    # if x != expected_x:\n    #     raise ValueError('expected:\
  \ [%s]\\n %s\\ngot: [%s]\\n%s' % (type(expected_x), expected_x, type(x), x))\n\n\
  \    demisto.results('DQ tests finished successfully! - deprecated')\n\ndef test_entry():\n\
  \    #entry = createEntry(INFO, {\n    #        'contextPath' : 'PY.Test(val.ID\
  \ && val.ID == obj.ID)',\n    #        'title' : 'Python DQ Test',\n    #      \
  \  'innerPath' : 'a.b',\n    #        'data' : [\n    #            {'to' : 'd_label',\
  \ 'from' : u'c.d'},\n    #            {'to' : 'e_hidden', 'from' : u'c.e', 'humanReadable'\
  \ : False},\n    #        ],\n    #    })\n\n    # demisto.results(entry)\n    demisto.results('ok')\n\
  \ndef test_xml():\n    import json\n\n    xml = \"<work><employee><id>100</id><name>foo</name></employee><employee><id>200</id><name>goo</name></employee></work>\"\
  \n    jsonExpected = '{\"work\": {\"employee\": [{\"id\": \"100\", \"name\": \"\
  foo\"}, {\"id\": \"200\", \"name\": \"goo\"}]}}'\n\n    jsonActual = xml2json(xml)\n\
  \    assert jsonActual == jsonExpected, \"expected\\n\" + jsonExpected + \"\\n to\
  \ equal \\n\" + jsonActual\n\n    jsonDict = json.loads(jsonActual)\n    assert\
  \ jsonDict['work']['employee'][0]['id'] == \"100\", 'id of first employee must be\
  \ 100'\n    assert jsonDict['work']['employee'][1]['name'] == \"goo\", 'name of\
  \ second employee must be goo'\n\n    xmlActual = json2xml(jsonActual)\n    assert\
  \ xmlActual == xml, \"expected\\n\" + xml + \"\\n to equal \\n\" + xmlActual\n\n\
  \    demisto.results('XML tests finished successfully!')\n\n\ndef toEntry(table):\n\
  \    return {\n\n        'Type' : entryTypes['note'],\n        'Contents': table,\n\
  \        'ContentsFormat': formats['table'],\n        'ReadableContentsFormat' :\
  \ formats['markdown'],\n        'HumanReadable' : table\n    }\n\n\ndef test_tbl_to_md():\n\
  \    tables = []\n    data = [\n        {\n            'header_1': 'a1',\n     \
  \       'header_2': 'b1',\n            'header_3': 'c1'\n        },\n        {\n\
  \            'header_1': 'a2',\n            'header_2': 'b2',\n            'header_3':\
  \ 'c2'\n        },\n        {\n            'header_1': 'a3',\n            'header_2':\
  \ 'b3',\n            'header_3': 'c3'\n        },\n    ]\n\n    # sanity\n    table\
  \ = tableToMarkdown('tableToMarkdown test', data)\n    expected_table = '''### tableToMarkdown\
  \ test\n|header_1|header_2|header_3|\n|---|---|---|\n| a1 | b1 | c1 |\n| a2 | b2\
  \ | c2 |\n| a3 | b3 | c3 |\n'''\n    tables.append((table, expected_table, ))\n\n\
  \    # header transform\n    table_transform = tableToMarkdown('tableToMarkdown\
  \ test with headerTransform', data, headerTransform=underscoreToCamelCase)\n   \
  \ expected_table_transform = '''### tableToMarkdown test with headerTransform\n\
  |Header1|Header2|Header3|\n|---|---|---|\n| a1 | b1 | c1 |\n| a2 | b2 | c2 |\n|\
  \ a3 | b3 | c3 |\n'''\n    tables.append((table_transform, expected_table_transform,\
  \ ))\n\n    # escaping characters: multiline + md-chars\n    data2 = copy.deepcopy(data)\n\
  \    for i, d in enumerate(data2):\n        d['header_2'] = 'b%d.1\\nb%d.2' % (i+1,\
  \ i+1, )\n        d['header_3'] = 'c%d|1' % (i+1, )\n\n    table_multiline = tableToMarkdown('tableToMarkdown\
  \ test with multiline', data2)\n    expected_table_multiline = '''### tableToMarkdown\
  \ test with multiline\n|header_1|header_2|header_3|\n|---|---|---|\n| a1 | b1.1<br>b1.2\
  \ | c1\\|1 |\n| a2 | b2.1<br>b2.2 | c2\\|1 |\n| a3 | b3.1<br>b3.2 | c3\\|1 |\n'''\n\
  \    tables.append((table_multiline, expected_table_multiline, ))\n\n    # url +\
  \ empty data\n    data3 = copy.deepcopy(data)\n    for i, d in enumerate(data3):\n\
  \        d['header_3'] = '[url](https:\\\\demisto.com)'\n        d['header_2'] =\
  \ None\n    table_url_missing_info = tableToMarkdown('tableToMarkdown test with\
  \ url and missing info', data3)\n    expected_table_url_missing_info = '''### tableToMarkdown\
  \ test with url and missing info\n|header_1|header_2|header_3|\n|---|---|---|\n\
  | a1 |  | [url](https:\\\\demisto.com) |\n| a2 |  | [url](https:\\\\demisto.com)\
  \ |\n| a3 |  | [url](https:\\\\demisto.com) |\n'''\n    tables.append((table_url_missing_info,\
  \ expected_table_url_missing_info, ))\n\n    # single column table\n    table_single_column\
  \ = tableToMarkdown('tableToMarkdown test with single column', data, ['header_1'])\n\
  \    expected_table_single_column = '''### tableToMarkdown test with single column\n\
  |header_1|\n|---|\n| a1 |\n| a2 |\n| a3 |\n'''\n    tables.append((table_single_column,\
  \ expected_table_single_column, ))\n\n    # list values\n    data4 = copy.deepcopy(data)\n\
  \    for i, d in enumerate(data4):\n        d['header_3'] = [i+1, 'second item']\n\
  \        d['header_2'] = 'hi'\n    table_list_field = tableToMarkdown('tableToMarkdown\
  \ test with list field', data4)\n    expected_table_list_field = '''### tableToMarkdown\
  \ test with list field\n|header_1|header_2|header_3|\n|---|---|---|\n| a1 | hi |\
  \ 1,<br>second item |\n| a2 | hi | 2,<br>second item |\n| a3 | hi | 3,<br>second\
  \ item |\n'''\n    tables.append((table_list_field, expected_table_list_field, ))\n\
  \n    # all fields are empty\n    data5 = [\n        {\n            'a' : None,\n\
  \            'b' : None,\n            'c' : None,\n        } for _ in range(3)\n\
  \    ]\n    table_all_none = tableToMarkdown('tableToMarkdown test with all none\
  \ fields', data5)\n    expected_table_all_none = '''### tableToMarkdown test with\
  \ all none fields\n|a|b|c|\n|---|---|---|\n|  |  |  |\n|  |  |  |\n|  |  |  |\n\
  '''\n    tables.append((table_all_none, expected_table_all_none, ))\n\n    # all\
  \ fields are empty - removed\n    table_all_none2 = tableToMarkdown('tableToMarkdown\
  \ test with all none fields2', data5, removeNull=True)\n    expected_table_all_none2\
  \ = '''### tableToMarkdown test with all none fields2\n**No entries.**\n'''\n  \
  \  tables.append((table_all_none2, expected_table_all_none2, ))\n\n    # header\
  \ not on first object\n    data6 = copy.deepcopy(data)\n    data6[1]['extra_header']\
  \ = 'sample'\n    table_extra_header = tableToMarkdown('tableToMarkdown test with\
  \ extra header', data6, headers=['header_1', 'header_2', 'extra_header'])\n    expected_table_extra_header\
  \ = '''### tableToMarkdown test with extra header\n|header_1|header_2|extra_header|\n\
  |---|---|---|\n| a1 | b1 |  |\n| a2 | b2 | sample |\n| a3 | b3 |  |\n'''\n    tables.append((table_extra_header,\
  \ expected_table_extra_header, ))\n\n    # no such header\n    table_no_headers\
  \ = tableToMarkdown('tableToMarkdown test with no headers', data, headers=['no',\
  \ 'header', 'found'], removeNull=True)\n    expected_table_no_headers = '''### tableToMarkdown\
  \ test with no headers\n**No entries.**\n'''\n    tables.append((table_no_headers,\
  \ expected_table_no_headers, ))\n\n\n    # dict value\n    data7 = copy.deepcopy(data)\n\
  \    data7[1]['extra_header'] = {'sample' : 'qwerty', 'sample2' : 'asdf'}\n    table_dict_record\
  \ = tableToMarkdown('tableToMarkdown test with dict record', data7, headers=['header_1',\
  \ 'header_2', 'extra_header'])\n    expected_dict_record = '''### tableToMarkdown\
  \ test with dict record\n|header_1|header_2|extra_header|\n|---|---|---|\n| a1 |\
  \ b1 |  |\n| a2 | b2 | sample: qwerty<br>sample2: asdf |\n| a3 | b3 |  |\n'''\n\
  \    tables.append((table_dict_record, expected_dict_record, ))\n\n    # string\
  \ header (instead of list)\n    table_string_header = tableToMarkdown('tableToMarkdown\
  \ string header', data, 'header_1')\n    expected_string_header_tbl = '''### tableToMarkdown\
  \ string header\n|header_1|\n|---|\n| a1 |\n| a2 |\n| a3 |\n'''\n    tables.append((table_string_header,\
  \ expected_string_header_tbl, ))\n\n    # list of string values instead of list\
  \ of dict objects\n    table_string_array = tableToMarkdown('tableToMarkdown test\
  \ with string array', ['foo', 'bar', 'katz'], ['header_1'])\n    expected_string_array_tbl\
  \ = '''### tableToMarkdown test with string array\n|header_1|\n|---|\n| foo |\n\
  | bar |\n| katz |\n'''\n    tables.append((table_string_array, expected_string_array_tbl,\
  \ ))\n\n    # combination: string header + string values list\n    table_string_array_string_header\
  \ = tableToMarkdown('tableToMarkdown test with string array and string header',\
  \ ['foo', 'bar', 'katz'], 'header_1')\n    expected_string_array_string_header_tbl\
  \ = '''### tableToMarkdown test with string array and string header\n|header_1|\n\
  |---|\n| foo |\n| bar |\n| katz |\n'''\n    tables.append((table_string_array_string_header,\
  \ expected_string_array_string_header_tbl, ))\n\n    results = [actual == expected\
  \ for actual, expected in tables]\n\n    if all(results):\n        demisto.results('ok')\n\
  \    else:\n        for result, (actual, expected) in zip(results, tables):\n  \
  \          if not result:\n                demisto.results(toEntry(actual))\n  \
  \              demisto.results(toEntry(expected))\n\n        demisto.results(str(results))\n\
  \        return_error('failure')\n\n\ndef test_flatten_cell():\n    returned = []\n\
  \n    # sanity\n    utf8_to_flatten = 'abcdefghijklmnopqrstuvwxyz1234567890!'.decode('utf8')\n\
  \    flatten_text = flattenCell(utf8_to_flatten)\n    expected_string = 'abcdefghijklmnopqrstuvwxyz1234567890!'\n\
  \n    returned.append((flatten_text, expected_string))\n\n    # list of uft8 and\
  \ string to flatten\n    str_a = 'abcdefghijklmnopqrstuvwxyz1234567890!'\n    utf8_b\
  \ = str_a.decode('utf8')\n    list_to_flatten = [str_a, utf8_b]\n    flatten_text\
  \ = flattenCell(list_to_flatten)\n    expected_flatten_string = 'abcdefghijklmnopqrstuvwxyz1234567890!,\\\
  nabcdefghijklmnopqrstuvwxyz1234567890!'\n\n    returned.append((flatten_text, expected_flatten_string))\n\
  \n\n    # special character test\n    special_char = u'\u4F1A'\n    list_of_special\
  \ = [special_char, special_char]\n    try:\n      flattenCell(list_of_special)\n\
  \      flattenCell(special_char)\n    except:\n      demisto.results(toEntry('special\
  \ character failure - flatten_cell'))\n      demisto.results(return_error('failure'))\n\
  \n    # dictionary test\n    dict_to_flatten = { 'first' : u'\u4F1A' }\n    expected_flatten_dict\
  \ = u'{\\n    \"first\": \"\\u4f1a\"\\n}'\n    returned.append((dict_to_flatten,\
  \ expected_flatten_dict))\n\n    results = [actual == expected for actual, expected\
  \ in returned]\n\n    if all(results):\n        demisto.results('ok')\n    else:\n\
  \        for result, (actual, expected) in zip(results, returned):\n           \
  \ if not result:\n                demisto.results(toEntry(actual))\n           \
  \     demisto.results(toEntry(expected))\n\n        demisto.results(str(results))\n\
  \        return_error('failure')\n\n\ndef test_hash_djb2():\n    assert hash_djb2(\"\
  test\") == 2090756197, \"Invalid value of hash_djb2\"\n\n\ndef test_camelize():\n\
  \    assert str(camelize([{'chookity_bop': 'asdasd'}, {'ab_c': 'd e', 'fgh_ijk':\
  \ 'lm', 'nop': 'qr_st'}], '_')) == \"[{u'ChookityBop': 'asdasd'}, {u'AbC': 'd e',\
  \ u'Nop': 'qr_st', u'FghIjk': 'lm'}]\"\n    assert str(camelize({'ab_c': 'd e',\
  \ 'fgh_ijk': 'lm', 'nop': 'qr_st'}, '_')) == \"{u'AbC': 'd e', u'Nop': 'qr_st',\
  \ u'FghIjk': 'lm'}\"\n\ndef test_replace_in_keys():\n    assert str(replace_in_keys({'a.b':\
  \ 'c', 'd.e': 'f'})) == \"{u'a_b': 'c', u'd_e': 'f'}\"\n\ndef test_date_to_timestamp():\n\
  \    assert date_to_timestamp('2018-11-06T08:56:41') == 1541494601000\n    assert\
  \ date_to_timestamp(datetime.strptime('2018-11-06T08:56:41', \"%Y-%m-%dT%H:%M:%S\"\
  )) == 1541494601000\n    demisto.results(\"date_to_timestamp test finished successfuly!\"\
  )\n\n\ndef test_pascalToSpace():\n    use_cases = [\n        ('Validate', 'Validate'),\n\
  \        ('validate', 'Validate'),\n        ('TCP', 'TCP'),\n        ('eventType',\
  \ 'Event Type'),\n        ('eventID', 'Event ID'),\n        ('eventId', 'Event Id'),\n\
  \        ('IPAddress', 'IP Address'),\n    ]\n    for s, expected in use_cases:\n\
  \        if pascalToSpace(s) != expected:\n            return_error('Error on {}\
  \ != {}'.format(pascalToSpace(s), expected))\n\n    demisto.results('ok')\n\ndef\
  \ test_argToList():\n    expected = ['a', 'b', 'c']\n    test1 = ['a', 'b', 'c']\n\
  \    test2 = 'a,b,c'\n    test3 = '[\"a\",\"b\",\"c\"]'\n    test4 = 'a;b;c'\n\n\
  \    results = [argToList(test1), argToList(test2), argToList(test2, ','), argToList(test3),\
  \ argToList(test4, ';')]\n\n    for result in results:\n        if expected != result:\n\
  \            return_error('argToList test failed, {} is not equal to {}'.format(str(result),\
  \ str(expected)))\n\n    demisto.results('ok')\n\ndef test_return_outputs():\n \
  \   return_outputs(readable_output=\"foo\", outputs={\"foo\":\"foo1\"})\n\n    return_outputs(readable_output=None,\
  \ outputs={\"foo\":\"foo1\"})\n\n    return_outputs(readable_output=\"foo\", outputs=None)\n\
  \n    return_outputs(\"foo\", {\"foo\":\"foo1\"}, raw_response={\"raw\":\"response\"\
  })\n\ndef test_remove_nulls():\n    temp_dictionary = {\"a\": \"b\", \"c\": 4, \"\
  e\": [], \"f\": {}, \"g\": None, \"h\": \"\", \"i\": [1,], \"k\": ()}\n    expected_dictionary\
  \ = {\"a\": \"b\", \"c\": 4, \"i\": [1,]}\n\n    removeNullsFromDictionary(temp_dictionary)\n\
  \n    if expected_dictionary != temp_dictionary:\n        return_error('deleteNullsFromDictionary\
  \ test failed, {} is not equal to {}'.format(str(deleteNullsFromDictionary), str(expected_dictionary)))\n\
  \n    demisto.results('ok')\n\ndef test_append_context():\n    appendContext('empty_string_key',\
  \ '')\n    appendContext('empty_list_key', [])\n    appendContext('zero_key', 0)\n\
  \    appendContext('none_key', None)\n    demisto.results(\"placeholder so the run\
  \ would finish\")\n\n''' MAIN TEST RUNNER '''\nTESTS = {\n    'DQ' : test_dq,\n\
  \    # 'XML' : test_xml,\n    'ENTRY' : test_entry,\n    'FLTNCL': test_flatten_cell,\n\
  \    'TBLMD' : test_tbl_to_md,\n    'HASH'  : test_hash_djb2,\n    'CAMELIZE': test_camelize,\n\
  \    'REPLACE_IN_KEYS': test_replace_in_keys,\n    'DATE_TO_TIMESTAMP': test_date_to_timestamp,\n\
  \    'PASCAL_TO_SPACE' : test_pascalToSpace,\n    'ARG_TO_LIST': test_argToList,\n\
  \    'RETURN_OUTPUTS': test_return_outputs,\n    'REMOVE_DICTIONARY_NULLS': test_remove_nulls,\n\
  \    'APPEND_CONTEXT': test_append_context\n}\n\n\nclass TestIsError(unittest.TestCase):\n\
  \n    def test_is_error_true(self):\n        execute_command_results = [\n     \
  \       {\n                \"Type\": entryTypes[\"error\"],\n                \"\
  ContentsFormat\": formats[\"text\"],\n                \"Contents\": \"this is error\
  \ message\"\n            }\n        ]\n        self.assertTrue(is_error(execute_command_results))\n\
  \n\n    def test_is_error_single_entry(self):\n        execute_command_results =\
  \ {\n            \"Type\": entryTypes[\"error\"],\n            \"ContentsFormat\"\
  : formats[\"text\"],\n            \"Contents\": \"this is error message\"\n    \
  \    }\n\n        self.assertTrue(is_error(execute_command_results))\n\n    def\
  \ test_is_error_false(self):\n        execute_command_results = [\n            {\n\
  \                \"Type\": entryTypes[\"note\"],\n                \"ContentsFormat\"\
  : formats[\"text\"],\n                \"Contents\": \"this is regular note\"\n \
  \           }\n        ]\n        self.assertFalse(is_error(execute_command_results))\n\
  \n    def test_not_error_entry(self):\n        execute_command_results = \"invalid\
  \ command results as string\"\n        self.assertFalse(is_error(execute_command_results))\n\
  \n\nclass TestGetError(unittest.TestCase):\n    def test_get_error(self):\n    \
  \    execute_command_results = [\n            {\n                \"Type\": entryTypes[\"\
  error\"],\n                \"ContentsFormat\": formats[\"text\"],\n            \
  \    \"Contents\": \"this is error message\"\n            }\n        ]\n       \
  \ error = get_error(execute_command_results)\n        self.assertEquals(error, \"\
  this is error message\")\n\n    def test_get_error_single_entry(self):\n       \
  \ execute_command_results = {\n            \"Type\": entryTypes[\"error\"],\n  \
  \          \"ContentsFormat\": formats[\"text\"],\n            \"Contents\": \"\
  this is error message\"\n        }\n\n        error = get_error(execute_command_results)\n\
  \        self.assertEquals(error, \"this is error message\")\n\n    def test_get_error_need_raise_error_on_non_error_input(self):\n\
  \        execute_command_results = [\n            {\n                \"Type\": entryTypes[\"\
  note\"],\n                \"ContentsFormat\": formats[\"text\"],\n             \
  \   \"Contents\": \"this is not an error\"\n            }\n        ]\n        try:\n\
  \            get_error(execute_command_results)\n            self.fail(\"get_error\
  \ should raise an error\")\n        except ValueError, e:\n            self.assertEquals(e.message,\
  \ \"execute_command_result has no error entry. before using get_error use is_error\"\
  )\n\n\ndef main():\n    test_type = demisto.args()['test_type']\n    if test_type\
  \ not in TESTS:\n        demisto.results('Invalid test: %s' % (test_type,))\n  \
  \  else:\n        TESTS[test_type]()\n\n\nif __name__ == '__builtin__':\n    main()"
scripttarget: 0
subtype: python2
tags: []
toversion: 4.1.9
type: python
