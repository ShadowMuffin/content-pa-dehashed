category: Data Enrichment & Threat Intelligence
commonfields:
  id: VirusTotal
  version: -1
configuration:
- defaultvalue: https://www.virustotal.com/vtapi/v2/
  display: Server URL (e.g. https://192.168.0.1)
  name: Server
  required: true
  type: 0
- defaultvalue: ''
  display: API Key
  name: APIKey
  required: true
  type: 4
- defaultvalue: 'true'
  display: Use system proxy settings
  name: useproxy
  required: false
  type: 8
- defaultvalue: 'false'
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: '10'
  display: File Threshold. Minimum number of positive results from VT scanners to
    consider the file malicious.
  name: fileThreshold
  required: false
  type: 0
- defaultvalue: '10'
  display: IP Threshold. Minimum number of positive results from VT scanners to consider
    the IP malicious.
  name: ipThreshold
  required: false
  type: 0
- defaultvalue: '10'
  display: URL Threshold. Minimum number of positive results from VT scanners to consider
    the URL malicious.
  name: urlThreshold
  required: false
  type: 0
- defaultvalue: '10'
  display: Domain Threshold. Minimum number of positive results from VT scanners to
    consider the domain malicious.
  name: domainThreshold
  required: false
  type: 0
- defaultvalue: ''
  display: Preferred Vendors List. CSV list of vendors which are considered more trustworthy.
  name: preferredVendors
  required: false
  type: 12
- defaultvalue: ''
  display: 'Preferred Vendor Threshold. The minimum number of highly trusted vendors
    required to consider a domain, IP address, URL, or file as malicious. '
  name: preferredVendorsThreshold
  required: false
  type: 0
- defaultvalue: 'false'
  display: "Determines whether to return all results, which can number in the thousands.\
    \ If \u201Ctrue\u201D, returns all results and overrides the _fullResponse_, _long_\
    \ arguments (if set to \u201Cfalse\u201D) in a command. If \u201Cfalse\u201D,\
    \ the _fullResponse_, _long_ arguments in the command determines how results are\
    \ returned."
  name: fullResponseGlobal
  required: false
  type: 8
description: Analyze suspicious hashes, URLs, domains and IP addresses
detaileddescription: '## Get a VirusTotal API Key

  To use this integration, you need a VirusTotal API key.

  1. Log in to your VirusTotal console.

  2. Click your username, and select **My API Key**.


  ## Indicator Thresholds

  Configure the default threshold for each indicator type in the instance settings.

  You can also specify the threshold as an argument when running relevant commands.

  Indicators with positive results equal to or higher than the threshold will be considered
  malicious.

  Indicators with positive results equal to or higher than half of the threshold value,
  and lower than the threshold, will be considered suspicious.'
display: VirusTotal
image: data:image/png;base64,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
name: VirusTotal
script:
  commands:
  - arguments:
    - default: true
      description: A CSV list of hashes of the file to query. Supports MD5, SHA1,
        and SHA256.
      name: file
      required: true
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Whether to return full response for scans. Default is "false".
      name: long
      predefined:
      - 'true'
      - 'false'
    - description: If the number of positives is higher than the threshold, the file
        will be considered malicious. If the threshold is not specified, the default
        file threshold, as configured in the instance settings, will be used.
      name: threshold
    - defaultValue: '60'
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      name: wait
    - defaultValue: '0'
      description: Number of retries for the API rate limit. Default is "0".
      name: retries
    description: Checks the file reputation of the specified hash.
    name: file
    outputs:
    - contextPath: File.MD5
      description: Bad MD5 hash.
    - contextPath: File.SHA1
      description: Bad SHA1 hash.
    - contextPath: File.SHA256
      description: Bad SHA256 hash.
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
    - contextPath: File.Malicious.Detections
      description: For malicious files, the total number of detections.
    - contextPath: File.Malicious.TotalEngines
      description: For malicious files, the total number of engines that checked the
        file hash.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: File.VirusTotal.Scans.Source
      description: Vendor used to scan the hash.
    - contextPath: File.VirusTotal.Scans.Detected
      description: Scan detection for this hash (True or False).
    - contextPath: File.VirusTotal.Scans.Result
      description: Scan result for this hash, for example, signature.
    - contextPath: File.VirusTotal.ScanID
      description: Scan ID for this hash.
      type: string
    - contextPath: File.PositiveDetections
      description: Number of engines that positively detected the indicator as malicious.
      type: number
    - contextPath: File.DetectionEngines
      description: Total number of engines that checked the indicator.
      type: number
    - contextPath: File.VirusTotal.vtLink
      description: Virus Total permanent link.
      type: string
  - arguments:
    - default: true
      description: IP address to check.
      isArray: true
      name: ip
      required: true
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Whether to return full response for detected URLs. Default is "false".
      name: long
      predefined:
      - 'true'
      - 'false'
    - description: If the number of positives is higher than the threshold, the IP
        address will be considered malicious. If the threshold is not specified, the
        default IP threshold, as configured in the instance settings, will be used.
      name: threshold
    - defaultValue: '10'
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format. Default is "10".
      name: sampleSize
    - defaultValue: '60'
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      name: wait
    - defaultValue: '0'
      description: Number of retries for API rate limit. Default is "0".
      name: retries
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Whether to return all results, which can be thousands. Default
        is "false". We recommend that you don't return full results in playbooks.
      name: fullResponse
      predefined:
      - 'true'
      - 'false'
    description: Checks the reputation of an IP address.
    name: ip
    outputs:
    - contextPath: IP.Address
      description: Bad IP address.
    - contextPath: IP.ASN
      description: Bad IP ASN.
    - contextPath: IP.Geo.Country
      description: Bad IP country.
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision.
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: IP.VirusTotal.DownloadedHashes
      description: Latest files that were detected by at least one antivirus solution,
        and were downloaded by VirusTotal from the IP address.
    - contextPath: IP.VirusTotal.UnAVDetectedDownloadedHashes
      description: Latest files that were not detected by any antivirus solution,
        and were downloaded by VirusTotal from the specified IP address.
    - contextPath: IP.VirusTotal.DetectedURLs
      description: Latest URLs hosted in this IP address that were detected by at
        least one URL scanner.
    - contextPath: IP.VirusTotal.CommunicatingHashes
      description: Latest detected files that communicate with this IP address.
    - contextPath: IP.VirusTotal.UnAVDetectedCommunicatingHashes
      description: Latest undetected files that communicate with this IP address.
    - contextPath: IP.VirusTotal.Resolutions.hostname
      description: Domains that resolved to the specified IP address.
    - contextPath: IP.VirusTotal.ReferrerHashes
      description: Latest detected files that embed this IP address in their strings.
    - contextPath: IP.VirusTotal.UnAVDetectedReferrerHashes
      description: Latest undetected files that embed this IP address in their strings.
    - contextPath: IP.VirusTotal.Resolutions.last_resolved
      description: Last resolution times of the domains that resolved to the specified
        IP address.
  - arguments:
    - description: The URL to check.
      isArray: true
      name: url
      required: true
    - defaultValue: '10'
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format.
      name: sampleSize
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Whether to return the full response for the detected URLs.
      name: long
      predefined:
      - 'true'
      - 'false'
    - description: If the number of positives is higher than the threshold, the URL
        will be considered malicious. If the threshold is not specified, the default
        URL threshold, as configured in the instance settings, will be used.
      name: threshold
    - defaultValue: '0'
      description: Time (in seconds) to wait if the URL does not exist and is submitted
        for scanning. Default is "0".
      name: submitWait
    - defaultValue: '60'
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      name: wait
    - defaultValue: '0'
      description: Number of retries for API rate limit. Default is "0".
      name: retries
    description: Checks the reputation of a URL.
    name: url
    outputs:
    - contextPath: URL.Data
      description: Bad URLs found.
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: URL.VirusTotal.Scans.Source
      description: Vendor that scanned this URL.
    - contextPath: URL.VirusTotal.Scans.Detected
      description: Scan detection for this URL (True or False).
    - contextPath: URL.VirusTotal.Scans.Result
      description: Scan result for this URL, for example, signature.
    - contextPath: URL.DetectionEngines
      description: Total number of engines that checked the indicator.
      type: number
    - contextPath: URL.PositiveDetections
      description: Number of engines that positively detected the indicator as malicious.
      type: number
    - contextPath: url.VirusTotal.ScanID
      description: Scan ID for this URL.
      type: string
    - contextPath: File.VirusTotal.vtLink
      description: Virus Total permanent link.
      type: string
  - arguments:
    - default: true
      description: Domain name to check.
      isArray: true
      name: domain
      required: true
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Whether to return the full response for detected URLs. Default
        is "false".
      name: long
      predefined:
      - 'true'
      - 'false'
    - defaultValue: '10'
      description: The number of samples from each type (resolutions, detections,
        etc.) to display for long format.
      name: sampleSize
    - description: If the number of positives is higher than the threshold, the domain
        will be considered malicious. If the threshold is not specified, the default
        domain threshold, as configured in the instance settings, will be used.
      name: threshold
    - defaultValue: '60'
      description: Time (in seconds) to wait between tries if the API rate limit is
        reached. Default is "60".
      name: wait
    - defaultValue: '0'
      description: Number of retries for API rate limit. Default is "0".
      name: retries
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Whether to return all results, which can be thousands. Default
        is "false". We recommend that you don't return full results in playbooks.
      name: fullResponse
      predefined:
      - 'true'
      - 'false'
    description: Checks the reputation of a domain.
    name: domain
    outputs:
    - contextPath: Domain.Name
      description: Bad domain found.
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason that the vendor made the decision.
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
    - contextPath: DBotScore.Score
      description: The actual score.
    - contextPath: Domain.VirusTotal.DownloadedHashes
      description: Hashes of files that were downloaded from this domain.
    - contextPath: Domain.VirusTotal.CommunicatingHashes
      description: Hashes of files that communicated with this domain in a sandbox.
    - contextPath: Domain.VirusTotal.Resolutions.ip_address
      description: IP addresses that resolved to this domain.
    - contextPath: Domain.VirusTotal.Whois
      description: Whois report.
    - contextPath: Domain.VirusTotal.Subdomains
      description: Subdomains.
    - contextPath: Domain.VirusTotal.UnAVDetectedDownloadedHashes
      description: Latest files that were not detected by any antivirus solution,
        and were downloaded by VirusTotal from the specified IP address.
    - contextPath: Domain.VirusTotal.DetectedURLs
      description: Latest URLs hosted in this domain address that were detected by
        at least one URL scanner.
    - contextPath: Domain.VirusTotal.ReferrerHashes
      description: Latest detected files that embed this domain address in their strings.
    - contextPath: Domain.VirusTotal.UnAVDetectedReferrerHashes
      description: Latest undetected files that embed this domain address in their
        strings.
    - contextPath: Domain.VirusTotal.UnAVDetectedCommunicatingHashes
      description: Latest undetected files that communicated with this domain in a
        sandbox.
    - contextPath: Domain.VirusTotal.Resolutions.last_resolved
      description: Last resolution times of the IP addresses that resolve to this
        domain.
  - arguments:
    - default: true
      description: The file entry ID to submit.
      name: entryID
      required: true
    - description: Private API extension. Special upload URL for files larger than
        32 MB.
      name: uploadURL
    description: Submits a file for scanning.
    name: file-scan
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files.
    - contextPath: vtLink
      description: Virus Total permanent link.
      type: string
  - arguments:
    - default: true
      description: Hash of the file to re-scan. Supports MD5, SHA1, and SHA256.
      name: file
      required: true
    description: Re-scans an already submitted file. This avoids having to upload
      the file again.
    name: file-rescan
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted files.
    - contextPath: vtLink
      description: Virus Total permanent link.
      type: string
  - arguments:
    - default: true
      description: The URL to scan.
      name: url
      required: true
    description: Scans a specified URL.
    name: url-scan
    outputs:
    - contextPath: vtScanID
      description: Scan IDs of the submitted URLs.
    - contextPath: vtLink
      description: Virus Total permanent link.
      type: string
  - arguments:
    - default: true
      description: The file hash (MD5, SHA1, or SHA256) or URL on which you're commenting.
      name: resource
      required: true
    - description: 'The actual review, which you can tag by using the "#" twitter-like
        syntax, for example, #disinfection #zbot, and reference users using the "@"
        syntax, for example, @VirusTotalTeam).'
      name: comment
      required: true
    description: Adds comments to files and URLs.
    name: vt-comments-add
  - arguments: []
    description: Private API. Get a special URL for files larger than 32 MB.
    name: vt-file-scan-upload-url
    outputs:
    - contextPath: vtUploadURL
      description: The special upload URL for large files.
  - arguments:
    - default: true
      description: The file hash (MD5, SHA1, orSHA256) or URL from which you're retrieving
        comments.
      name: resource
      required: true
    - description: Datetime token in the format YYYYMMDDHHMISS. You can use this for
        paging.
      name: before
    description: Private API. Retrieves comments for a given resource.
    name: vt-comments-get
  runonce: false
  script: "var serverUrl = params.Server;\nif (serverUrl[serverUrl.length - 1] !==\
    \ '/') {\n    serverUrl += '/';\n}\n//THRESHOLDS PARAMETERS\nvar FILE_THRESHOLD\
    \ = params.fileThreshold;\nvar IP_THRESHOLD = params.ipThreshold;\nvar URL_THRESHOLD\
    \ = params.urlThreshold;\nvar DOMAIN_THRESHOLD = params.domainThreshold;\nvar\
    \ PREFERRED_VENDORS = params.preferredVendors\nvar PREFERRED_VENDORS_THRESHOLD\
    \ = params.preferredVendorsThreshold\nvar FULL_RESPONSE = params.fullResponseGlobal\n\
    if (isNaN(FILE_THRESHOLD) || isNaN(IP_THRESHOLD) || isNaN(URL_THRESHOLD) || isNaN(DOMAIN_THRESHOLD))\
    \ {\n    throw 'Threshold parameters must be numbers.\\n';\n}\nfunction isEnoughPreferredVendors(scanResults)\
    \ {\n    if (!(PREFERRED_VENDORS && PREFERRED_VENDORS_THRESHOLD)) {\n        return\
    \ false;\n    }\n    if (PREFERRED_VENDORS && !(PREFERRED_VENDORS_THRESHOLD))\
    \ {\n        return(\"Error: If you entered Preferred Vendors List you must also\
    \ enter Preferred Vendors Threshold\")\n    }\n    if (!(\"scans\" in scanResults))\
    \ {\n        return false;\n    }\n    counter = 0;\n    vendorsScansDict = scanResults[\"\
    scans\"];\n    listOfPrefferedVendors = PREFERRED_VENDORS.split(',');\n    for\
    \ (var i=0; i < listOfPrefferedVendors.length; i++) {\n        listOfPrefferedVendors[i]\
    \ = listOfPrefferedVendors[i].toLowerCase();\n    }\n    for (var vendorName in\
    \ vendorsScansDict) {\n        if (vendorsScansDict.hasOwnProperty(vendorName))\
    \ {\n            curVendorScan = vendorsScansDict[vendorName];\n            vendorNameLowercase\
    \ = vendorName.toLowerCase();\n            if (listOfPrefferedVendors.indexOf(vendorNameLowercase)\
    \ != -1) {\n                if (\"detected\" in curVendorScan && curVendorScan[\"\
    detected\"]) {\n                    counter++;\n                }\n          \
    \  }\n        }\n    }\n    return (parseInt(PREFERRED_VENDORS_THRESHOLD) <= counter);\n\
    }\nfunction createScansTable(scans){\n    // Returns a table with the scan result\
    \ for each vendor\n    scans_table = [];\n    positives_scans_table = [];\n  \
    \  negative_scans_table = [];\n    for (var scan in scans) {\n        dict_for_table\
    \ = {};\n        dict_for_table['Source'] = scan;\n        if (scans[scan]['detected']){\n\
    \            dict_for_table['Detected'] = scans[scan]['detected'];\n        }\n\
    \        if (scans[scan]['result']){\n            dict_for_table['Result'] = scans[scan]['result'];\n\
    \        }\n        if (scans[scan]['update']){\n            dict_for_table['Update']\
    \ = scans[scan]['update'];\n        }\n        if (scans[scan]['detail']){\n \
    \           dict_for_table['Details'] = scans[scan]['detail'];\n        }\n  \
    \      if (dict_for_table['Detected'] && dict_for_table['Detected'] === true)\n\
    \            positives_scans_table.push(dict_for_table);\n        else\n     \
    \       negative_scans_table.push(dict_for_table);\n    }\n    positives_scans_table.sort(function(a,\
    \ b){\n      return a.Source > b.Source;\n    });\n    negative_scans_table.sort(function(a,\
    \ b){\n      return a.Source > b.Source;\n    });\n    scans_table = positives_scans_table.concat(negative_scans_table);\n\
    \    return scans_table;\n}\nfunction doReq(method, path, parameters) {\n    if\
    \ (!parameters) {\n        parameters = {};\n    }\n    parameters.apikey = params.APIKey;\n\
    \    var result = http(\n        serverUrl + path + (method === 'GET' ? encodeToURLQuery(parameters)\
    \ : ''),\n        {\n            Headers: {'Content-Type': ['application/x-www-form-urlencoded'],\
    \ 'Accept': ['application/json']},\n            Method: method,\n            Body:\
    \ method == 'POST' ? encodeToURLQuery(parameters).substring(1) : ''\n        },\n\
    \        params.insecure,\n        params.useproxy\n    );\n    if (result.StatusCode\
    \ == 401) {\n        throw '401 Unauthorized - Wrong or invalid API key.';\n \
    \   }\n    if (result.StatusCode == 403) {\n        throw '403 Forbidden - The\
    \ API key is not valid';\n    }\n    if (result.StatusCode == 404) {\n       \
    \ throw '404 - Cannot find the requested resource. Check your Server URL.';\n\
    \    }\n    if (result.StatusCode < 200 || result.StatusCode > 299) {\n      \
    \  throw 'Failed to perform request ' + path + ', request status code: ' + result.StatusCode;\n\
    \    }\n    if (result.Body === '' && result.StatusCode === 204) {\n        return\
    \ {statusCode: result.StatusCode};\n    }\n    if (result.Body === '') {\n   \
    \     throw 'No content received. Maybe you tried a private API?.';\n    }\n \
    \   var obj;\n    try {\n        obj = JSON.parse(result.Body);\n    } catch (ex)\
    \ {\n        throw 'Error parsing reply - ' + result.Body + ' - ' + ex;\n    }\n\
    \    if (!Array.isArray(obj) && obj.response_code !== 1 && obj.response_code !==\
    \ 0) {\n        throw 'Response code: ' + obj.response_code + ', message: ' +\
    \ obj.verbose_msg;\n    }\n    return {\n        body: result.Body,\n        obj:\
    \ obj,\n        statusCode: result.StatusCode\n    };\n}\nfunction withRetries(waitForRateLimit,\
    \ retries, reqCall) {\n    if (waitForRateLimit) {\n        waitForRateLimit =\
    \ parseInt(waitForRateLimit);\n    }\n    if (!waitForRateLimit) {\n        waitForRateLimit\
    \ = 60;\n    }\n    if (retries) {\n        retries = parseInt(retries);\n   \
    \ }\n    if (!retries) {\n        retries = 0;\n    }\n    var res = reqCall();\n\
    \    var tries = 0;\n    while (res.statusCode === 204 && !res.body && tries <\
    \ retries && waitForRateLimit > 0) {\n        wait(waitForRateLimit);\n      \
    \  tries++;\n        res = reqCall();\n    }\n    if (res.statusCode === 204 &&\
    \ !res.body) {\n        throw 'No content received. Possible API rate limit reached.';\n\
    \    }\n    return res;\n}\nfunction doFile(hash, longFormat, threshold, waitForRateLimit,\
    \ retries) {\n    if (!threshold) {\n        threshold = FILE_THRESHOLD || 10;\n\
    \    }\n    threshold = parseInt(threshold);\n\n    var res = withRetries(waitForRateLimit,\
    \ retries, function() {return doReq('POST', 'file/report', {resource: hash});});\n\
    \    var o = res.obj;\n    var ec = {};\n    if (o.response_code === 0) {\n  \
    \      ec[\"DBotScore\"] = [{Indicator: hash, Type: 'hash', Vendor: 'VirusTotal',\
    \ Score: 0},\n                          {Indicator: hash, Type: 'file', Vendor:\
    \ 'VirusTotal', Score: 0}];\n        return {Type: entryTypes.note, Contents:\
    \ res.body, ContentsFormat: formats.json, EntryContext: ec,\n            HumanReadable:\
    \ 'VirusTotal does not have details about ' + hash + '\\n' + res.obj.verbose_msg};\n\
    \    }\n    var r = [];\n    if (Array.isArray(res.obj)) { // Got multiple hashes\
    \ so need to nicely iterate\n        r = res.obj;\n    } else {\n        r = [res.obj];\n\
    \    }\n    var md = '';\n    ec.DBotScore = [];\n    ec[outputPaths.file] = [];\n\
    \    for (var i=0; i<r.length; i++) {\n        md += '## VirusTotal Hash Reputation\
    \ for: ' + r[i].resource + '\\n';\n        md += 'Scan date: **' + r[i].scan_date\
    \ + '**\\n';\n        md += 'Positives / Total: **' + r[i].positives + '/' + r[i].total\
    \ + '**\\n';\n        md += 'VT Link: [' + r[i].resource + '](' + r[i].permalink\
    \ + ')\\n';\n        var dbotScore = 0;\n        if (r[i].positives >= threshold\
    \ || isEnoughPreferredVendors(r[i])) {\n            dbotScore = 3;\n         \
    \   var malFile = {};\n            addMalicious(malFile, outputPaths.file, {\n\
    \                MD5: r[i].md5,\n                SHA1: r[i].sha1,\n          \
    \      SHA256: r[i].sha256,\n                PositiveDetections: r[i].positives,\n\
    \                DetectionEngines: Object.keys(r[i].scans).length,\n         \
    \       Malicious: {Vendor: 'VirusTotal', Detections: r[i].positives, TotalEngines:\
    \ r[i].total}\n            });\n            ec[outputPaths.file].push(malFile[outputPaths.file]);\n\
    \        } else if (r[i].positives >= threshold / 2) {\n            dbotScore\
    \ = 2;\n        } else {\n            dbotScore = 1;\n        }\n        ec.DBotScore.push({Indicator:\
    \ hash, Type: 'hash', Vendor: 'VirusTotal', Score: dbotScore});\n        ec.DBotScore.push({Indicator:\
    \ hash, Type: 'file', Vendor: 'VirusTotal', Score: dbotScore});\n        md +=\
    \ 'MD5 / SHA1 / SHA256: **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256\
    \ + '**\\n';\n        longFormat = FULL_RESPONSE? 'true': longFormat;\n      \
    \  if (longFormat === 'true' && r[i].scans) { // add scans table\n           \
    \ scansTable = createScansTable(r[i].scans);\n            md += tableToMarkdown('Scans',\
    \ scansTable);\n            if (ec[outputPaths.file]){\n                scans_ec\
    \ = {\n                    Scans: scansTable,\n                    ScanID: r[i].scan_id,\n\
    \                    vtLink: r[i].permalink\n                };\n            \
    \    if (typeof ec[outputPaths.file][i] === 'object') { // malicous\n        \
    \            ec[outputPaths.file][i].VirusTotal = scans_ec;\n                }\
    \ else { // not malicious\n                    ec[outputPaths.file][i] = {\n \
    \                       SHA256: r[i].sha256,\n                        SHA1: r[i].sha1,\n\
    \                        MD5: r[i].md5,\n                        VirusTotal: scans_ec,\n\
    \                        PositiveDetections: r[i].positives,\n               \
    \         DetectionEngines: Object.keys(r[i].scans).length\n                 \
    \   };\n                }\n            } else {\n                scans_ec = {\n\
    \                    MD5: r[i].md5,\n                    SHA1: r[i].sha1,\n  \
    \                  SHA256: r[i].sha256,\n                    VirusTotal: {\n \
    \                       Scans: scansTable,\n                        ScanID: r[i].scan_id,\n\
    \                        vtLink: r[i].permalink\n                    },\n    \
    \                PositiveDetections: r[i].positives,\n                    DetectionEngines:\
    \ Object.keys(r[i].scans).length\n                };\n                ec[outputPaths.file]\
    \ = scans_ec;\n            }\n        } else { // short format\n            if\
    \ (ec[outputPaths.file]){\n                scans_ec = {\n                    ScanID:\
    \ r[i].scan_id,\n                    vtLink: r[i].permalink\n                };\n\
    \                if (typeof ec[outputPaths.file][i] === 'object') { // malicious\n\
    \                    ec[outputPaths.file][i].VirusTotal = scans_ec;\n        \
    \        } else { // not malicious\n                    ec[outputPaths.file][i]\
    \ = {\n                        SHA256: r[i].sha256,\n                        SHA1:\
    \ r[i].sha1,\n                        MD5: r[i].md5,\n                       \
    \ VirusTotal: scans_ec,\n                        PositiveDetections: r[i].positives,\n\
    \                        DetectionEngines: Object.keys(r[i].scans).length\n  \
    \                  };\n                }\n            } else {\n             \
    \   scans_ec = {\n                    SHA256: r[i].sha256,\n                 \
    \   SHA1: r[i].sha1,\n                    MD5: r[i].md5,\n                   \
    \ VirusTotal: {\n                        ScanID: r[i].scan_id,\n             \
    \           vtLink: r[i].permalink\n                    },\n                 \
    \   PositiveDetections: r[i].positives,\n                    DetectionEngines:\
    \ Object.keys(r[i].scans).length\n                };\n                ec[outputPaths.file]\
    \ = scans_ec;\n            }\n        }\n        md += '\\n';\n    }\n    return\
    \ {\n        Type: entryTypes.note,\n        Contents: res.body,\n        ContentsFormat:\
    \ formats.json,\n        HumanReadable: md,\n        EntryContext: ec\n    };\n\
    }\nfunction calcRecentDownloads(checks) {\n    var badDownloads = 0;\n    var\
    \ millisec_in_day = 1000 * 60 * 60 * 24;\n    var now = Date.now();\n    for (var\
    \ c=0; c<checks.length; c++) {\n        if (checks[c]) {\n            for (var\
    \ ci=0; ci<checks[c].length; ci++) {\n                if (checks[c][ci].date)\
    \ {\n                    var d = new Date(checks[c][ci].date.replace(' ', 'T'));\n\
    \                    if (((now - d.getTime()) / millisec_in_day < 30) && (checks[c][ci].positives\
    \ > 0)) {\n                        badDownloads++;\n                    }\n  \
    \              }\n            }\n        }\n    }\n    return badDownloads;\n\
    }\nfunction doIP(ip, longFormat, threshold, sampleSize, waitForRateLimit, retries,\
    \ fullResponse) {\n\n    var ipList = argToList(ip);\n    var entryList = [];\n\
    \    for (z = 0; z < ipList.length; z++) {\n        ip = ipList[z];\n        if\
    \ (!isValidIP(ip)) {\n            entryList.push({Type: entryTypes.error, Contents:\
    \ 'IP - ' + ip + ' is not valid IP', ContentsFormat: formats.text});\n       \
    \     continue;\n        }\n        if (!threshold) {\n            threshold =\
    \ IP_THRESHOLD || 10;\n        }\n        threshold = parseInt(threshold);\n \
    \       if (!sampleSize) {\n            sampleSize = 10;\n        }\n        var\
    \ res = withRetries(waitForRateLimit, retries, function() {return doReq('GET',\
    \ 'ip-address/report', {ip: ip});});\n        var o = res.obj;\n        var ec\
    \ = {};\n        if (o.response_code === 0) {\n            ec.DBotScore = {Indicator:\
    \ ip, Type: 'ip', Vendor: 'VirusTotal', Score: 0};\n            entryList.push({Type:\
    \ entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext:\
    \ ec,\n                HumanReadable: 'VirusTotal does not have details about\
    \ ' + ip + ' ,it sent the following response:\\n' + res.obj.verbose_msg});\n \
    \           continue;\n        }\n        full_response = FULL_RESPONSE? 'true':\
    \ fullResponse;\n        if (fullResponse === 'true'){\n            maxLen = 1000;\n\
    \        } else {\n            maxLen = 50;\n        }\n        // Calculate score\
    \ based on recently found downloads\n        var badDownloads = calcRecentDownloads([o.detected_downloaded_samples,\
    \ o.undetected_downloaded_samples]);\n        var dbotScore = 0;\n        if (badDownloads\
    \ >= threshold) {\n            dbotScore = 3;\n            addMalicious(ec, outputPaths.ip,{\n\
    \                Address: ip,\n                ASN: o.asn,\n                Geo:\
    \ {Country: o.country},\n                Malicious: {Vendor: 'VirusTotal', Description:\
    \ 'Recent malicious downloads: ' + badDownloads}\n            });\n        } else\
    \ if (badDownloads >= threshold / 2) {\n            dbotScore = 2;\n        }\
    \ else {\n            dbotScore = 1;\n        }\n        ec.DBotScore = {Indicator:\
    \ ip, Type: 'ip', Vendor: 'VirusTotal', Score: dbotScore};\n        var md = '##\
    \ VirusTotal IP Reputation for: ' + ip + '\\n';\n        md += (o.asn) ? 'ASN:\
    \ **' + o.asn + ' (' + o.as_owner + ')**\\n' : 'ASN: N/A\\n';\n        md += 'Country:\
    \ **' + o.country + '**\\n';\n        md += 'VT Link: [' + ip + '](https://www.virustotal.com/en/search?query='\
    \ + encodeURIComponent(ip) + ')\\n';\n        var detectedUrls = o.detected_urls\
    \ || [];\n        var detectedDownloadedSamples = o.detected_downloaded_samples\
    \ || [];\n        var undetectedDownloadedSamples = o.undetected_downloaded_samples\
    \ || [];\n        var detectedCommunicatingSamples = o.detected_communicating_samples\
    \ || [];\n        var undetectedCommunicatingSamples = o.undetected_communicating_samples\
    \ || [];\n        var detectedReferrerSamples = o.detected_referrer_samples ||\
    \ [];\n        var undetectedReferrerSamples = o.undetected_referrer_samples ||\
    \ [];\n        var resolutions = o.resolutions || [];\n        var arrTitle =\
    \ [{a: detectedUrls, t: 'Detected URL'}, {a: detectedDownloadedSamples, t: 'Detected\
    \ downloaded sample'},\n            {a: undetectedDownloadedSamples, t: 'Undetected\
    \ downloaded sample'}, {a: detectedCommunicatingSamples, t: 'Detected communicating\
    \ sample'},\n            {a: undetectedCommunicatingSamples, t: 'Undetected communicating\
    \ sample'},{a: detectedReferrerSamples, t: 'Detected referrer sample'},\n    \
    \        {a: undetectedReferrerSamples, t: 'Undetected referrer sample'}, {a:\
    \ resolutions, t: 'Resolutions'}];\n        for (var i = 0; i<arrTitle.length;\
    \ i++) {\n            if (arrTitle[i].a) {\n                md += arrTitle[i].t\
    \ + ' count: **' + arrTitle[i].a.length + '**\\n';\n            }\n        }\n\
    \        if (ec[outputPaths.ip]){ // malicious\n            ec[outputPaths.ip]['VirusTotal']\
    \ = {\n                'DownloadedHashes': detectedDownloadedSamples.slice(0,maxLen),\n\
    \                'UnAVDetectedDownloadedHashes': undetectedDownloadedSamples.slice(0,maxLen),\n\
    \                \"DetectedURLs\": detectedUrls.slice(0,maxLen),\n           \
    \     'CommunicatingHashes': detectedCommunicatingSamples.slice(0,maxLen),\n \
    \               'UnAVDetectedCommunicatingHashes': undetectedCommunicatingSamples.slice(0,maxLen),\n\
    \                'Resolutions': resolutions.slice(0,maxLen),\n               \
    \ 'ReferrerHashes': detectedReferrerSamples.slice(0,maxLen),\n               \
    \ 'UnAVDetectedReferrerHashes': undetectedReferrerSamples.slice(0,maxLen)\n  \
    \          };\n        } else { // not malicious\n            ec[outputPaths.ip]\
    \ = {\n                \"Address\": ip,\n                \"VirusTotal\": {\n \
    \                   'DownloadedHashes': detectedDownloadedSamples.slice(0,maxLen),\n\
    \                    'UnAVDetectedDownloadedHashes': undetectedDownloadedSamples.slice(0,maxLen),\n\
    \                    \"DetectedURLs\": detectedUrls.slice(0,maxLen),\n       \
    \             'CommunicatingHashes': detectedCommunicatingSamples.slice(0,maxLen),\n\
    \                    'UnAVDetectedCommunicatingHashes': undetectedCommunicatingSamples.slice(0,maxLen),\n\
    \                    'Resolutions': resolutions.slice(0,maxLen),\n           \
    \         'ReferrerHashes': detectedReferrerSamples.slice(0,maxLen),\n       \
    \             'UnAVDetectedReferrerHashes': undetectedReferrerSamples.slice(0,maxLen)\n\
    \                },\n                'ASN': o.asn,\n                'Geo': {Country:\
    \ o.country}\n            };\n        }\n        longFormat = FULL_RESPONSE? 'true':\
    \ longFormat;\n        if (longFormat === 'true') {\n            for (var j=0;\
    \ j<arrTitle.length; j++) {\n                if (arrTitle[j].a) {\n          \
    \          md += '### ' + arrTitle[j].t + '\\n';\n                    // Print\
    \ only the first 10 rows\n                    var curr = [];\n               \
    \     for (var k=0; k<Math.min(arrTitle[j].a.length, sampleSize); k++) {\n   \
    \                     curr.push(arrTitle[j].a[k]);\n                    }\n  \
    \                  md += arrToMd(curr) + '\\n';\n                }\n         \
    \   }\n        }\n        entryList.push({\n            Type: entryTypes.note,\n\
    \            Contents: res.body,\n            ContentsFormat: formats.json,\n\
    \            HumanReadable: md,\n            EntryContext: ec\n        });\n \
    \   }\n    return entryList;\n}\nfunction getURLs(url) {\n        var urls = [];\n\
    \        var urlList = argToList(url);\n        for (z = urlList.length - 1; z\
    \ >= 0; z--) {\n            var isURL = urlList[z].match(/(?:(?:https?|ftp|hxxps?):\\\
    /\\/|www\\[?\\.\\]?|ftp\\[?\\.\\]?)(?:[-\\w\\d]+\\[?\\.\\]?)+[-\\w\\d]+(?::\\\
    d+)?(?:(?:\\/|\\?)[-\\w\\d+&@#\\/%=~_$?!\\-:,.\\(\\);]*[\\w\\d+&@#\\/%=~_$\\(\\\
    );])?/);\n            if (isURL == null){\n                var i = z;\n      \
    \          var url;\n                var optionalURL;\n                while(i>=0\
    \ && z > 0 && optionalURL == null) {\n                    i--;\n             \
    \       optionalURL = urlList.slice(i, z).join(\"\").match(/(?:(?:https?|ftp|hxxps?):\\\
    /\\/|www\\[?\\.\\]?|ftp\\[?\\.\\]?)(?:[-\\w\\d]+\\[?\\.\\]?)+[-\\w\\d]+(?::\\\
    d+)?(?:(?:\\/|\\?)[-\\w\\d+&@#\\/%=~_$?!\\-:,.\\(\\);]*[\\w\\d+&@#\\/%=~_$\\(\\\
    );])?/);\n                }\n                if (optionalURL !== null) {\n   \
    \                 urls.push(urlList.slice(i, z+1).join(\",\"));\n            \
    \    }\n                z = i;\n            } else {\n                urls.push(urlList[z]);\n\
    \            }\n        }\n\n        return urls;\n    }\nfunction doURL(url,\
    \ threshold, longFormat, sampleSize, submitWait, waitForRateLimit, retries) {\n\
    \    //lowercase the URL protocol\n    //Example: https://www.demisto.com -->\
    \ https://www.demisto.com, Http://www.demisto.com --> http://www.demisto.com,\
    \ www.demisto.com --> www.demisto.com\n\n    var urlList = getURLs(url);\n   \
    \ var entryList = [];\n    for (z = 0; z < urlList.length; z++) {\n        url\
    \ = urlList[z];\n        var protocol = url.match(/\\b^[^:]+(?=:\\/\\/)\\b/);\n\
    \        if (protocol !== null) { // if url doesn't start with a protocol, ignore\n\
    \          protocol = protocol[0].toLowerCase();\n          var not_protocol =\
    \ url.replace(/(^\\w+:|^)\\/\\//, '');\n          url = protocol + '://' + not_protocol;\n\
    \        }\n        if (!submitWait) {\n            submitWait = 0;\n        }\n\
    \        if (!sampleSize) {\n            sampleSize = 10;\n        }\n       \
    \ if (!threshold) {\n            threshold = URL_THRESHOLD || 10;\n        }\n\
    \        threshold = parseInt(threshold);\n        var res = withRetries(waitForRateLimit,\
    \ retries, function() {return doReq('POST', 'url/report', {resource: url, scan:1});});\n\
    \        var o = res.obj;\n        var ec = {};\n        if (o.response_code ===\
    \ 0) {\n            ec.DBotScore = {Indicator: url, Type: 'url', Vendor: 'VirusTotal',\
    \ Score: 0};\n            entryList({Type: entryTypes.note, Contents: res.body,\
    \ ContentsFormat: formats.json, EntryContext: ec,\n                HumanReadable:\
    \ 'VirusTotal does not have details about ' + url + '\\n' + res.obj.verbose_msg});\n\
    \            continue;\n        }\n        var md = '## VirusTotal URL Reputation\
    \ for: ' + url + '\\n';\n        if (!o.scans && submitWait>0) {\n           \
    \ wait(parseInt(submitWait));\n            res = doReq('GET', 'url/report', {resource:\
    \ url});\n            o = res.obj;\n        }\n        if (!o.scans) { // URL\
    \ doesn't exist in VT\n            md += 'URL submitted for scan. Please retry\
    \ command later\\n';\n            ec[outputPaths.url] = {\n                Data:\
    \ url,\n                VirusTotal: {\n                    ScanID: o.scan_id\n\
    \                },\n                DetectionEngines: 0,\n                PositiveDetections:\
    \ 0\n            };\n        } else {\n            md += 'Last scan date: *' +\
    \ o.scan_date + '*\\n';\n            md += 'Total scans: **' + o.total + '**\\\
    n';\n            md += 'Positive scans: **' + o.positives + '**\\n';\n       \
    \     md += 'VT Link: [' + url + '](' + o.permalink + ')\\n';\n            var\
    \ dbotScore = 0;\n            if (o.positives >= threshold  || isEnoughPreferredVendors(o))\
    \ {\n                dbotScore = 3;\n                addMalicious(ec, outputPaths.url,\
    \ {\n                    Data: url,\n                    Malicious: {Vendor: 'VirusTotal',\
    \ Description: 'Positives / Total: ' + o.positives + ' / ' + o.total},\n     \
    \               DetectionEngines: Object.keys(o.scans).length,\n             \
    \       PositiveDetections: o.positives\n                });\n            } else\
    \ if (o.positives >= threshold / 2) {\n                dbotScore = 2;\n      \
    \      } else {\n                dbotScore = 1;\n            }\n            ec.DBotScore\
    \ = {Indicator: url, Type: 'url', Vendor: 'VirusTotal', Score: dbotScore};\n \
    \           longFormat = FULL_RESPONSE? 'true': longFormat;\n            if (longFormat\
    \ === 'true') { // add scans table\n                scansTable = createScansTable(o.scans);\n\
    \                md += tableToMarkdown('Scans', scansTable);\n               \
    \ if (ec[outputPaths.url]){ // malicious\n                    scans_ec = {\n \
    \                       Scans: scansTable,\n                        ScanID: o.scan_id,\n\
    \                        vtLink: o.permalink\n                    };\n       \
    \             ec[outputPaths.url].VirusTotal = scans_ec;\n                } else\
    \ { // not malicious\n                    scans_ec = {\n                     \
    \   Data: url,\n                        \"VirusTotal\": {\n                  \
    \          Scans: scansTable,\n                            ScanID: o.scan_id,\n\
    \                            vtLink: o.permalink\n                        },\n\
    \                        DetectionEngines: Object.keys(o.scans).length,\n    \
    \                    PositiveDetections: o.positives\n                    };\n\
    \                    ec[outputPaths.url] = scans_ec;\n                }\n    \
    \        } else { // short format\n                if (ec[outputPaths.url]){ //\
    \ malicious\n                    ec[outputPaths.url]['VirusTotal'] = {\n     \
    \                   ScanID: o.scan_id,\n                        vtLink: o.permalink\n\
    \                    };\n                } else { // not malicious\n         \
    \           ec[outputPaths.url] = {\n                        Data: url,\n    \
    \                    VirusTotal: {\n                            ScanID: o.scan_id,\n\
    \                            vtLink: o.permalink\n                        },\n\
    \                        DetectionEngines: Object.keys(o.scans).length,\n    \
    \                    PositiveDetections: o.positives\n                    };\n\
    \                }\n            }\n        }\n        entryList.push({\n     \
    \       Type: entryTypes.note,\n            Contents: res.body,\n            ContentsFormat:\
    \ formats.json,\n            HumanReadable: md,\n            EntryContext: ec\n\
    \        });\n    }\n    return entryList;\n}\nfunction doDomain(domain, threshold,\
    \ longFormat, sampleSize, waitForRateLimit, retries, fullResponse) {\n    if (!sampleSize)\
    \ {\n        sampleSize = 10;\n    }\n    if (!threshold) {\n        threshold\
    \ = DOMAIN_THRESHOLD || 10;\n    }\n    threshold = parseInt(threshold);\n   \
    \ var domainList = argToList(domain);\n    var entryList = [];\n    for (z = 0;\
    \ z < domainList.length; z++) {\n        domain = domainList[z];\n        var\
    \ res = withRetries(waitForRateLimit, retries, function() {return doReq('GET',\
    \ 'domain/report', {domain: domain});});\n        var o = res.obj;\n        var\
    \ ec = {};\n        if (o.response_code === 0) {\n            ec.DBotScore = {Indicator:\
    \ domain, Type: 'domain', Vendor: 'VirusTotal', Score: 0};\n            entryList.push({Type:\
    \ entryTypes.note, Contents: res.body, ContentsFormat: formats.json, EntryContext:\
    \ ec,\n                HumanReadable: 'VirusTotal does not have details about\
    \ ' + domain + '\\n' + res.obj.verbose_msg});\n            continue;\n       \
    \ }\n        full_response = FULL_RESPONSE? 'true': fullResponse;\n        if\
    \ (fullResponse === 'true') {\n            maxLen = 1000;\n        } else {\n\
    \            maxLen = 50;\n        }\n        // Calculate score based on recently\
    \ found downloads\n        var badDownloads = calcRecentDownloads([o.detected_downloaded_samples,\
    \ o.undetected_downloaded_samples]);\n        var dbotScore = 0;\n        if (badDownloads\
    \ >= threshold) {\n            dbotScore = 3;\n            addMalicious(ec, outputPaths.domain,\
    \ {Name: domain,\n                Malicious: {Vendor: 'VirusTotal', Description:\
    \ 'Recent malicious downloads: ' + badDownloads}});\n        } else if (badDownloads\
    \ >= threshold / 2) {\n            dbotScore = 2;\n        } else {\n        \
    \    dbotScore = 1;\n        }\n        ec.DBotScore = {Indicator: domain, Type:\
    \ 'domain', Vendor: 'VirusTotal', Score: dbotScore};\n        var md = '## VirusTotal\
    \ Domain Reputation for: ' + domain + '\\n';\n        md += '#### Domain categories:\
    \ *' + o.categories + \"*\\n\";\n        md += 'VT Link: [' + domain + '](https://www.virustotal.com/en/search?query='\
    \ + encodeURIComponent(domain) + ')\\n';\n        var detectedUrls = o.detected_urls\
    \ || [];\n        var detectedDownloadedSamples = o.detected_downloaded_samples\
    \ || [];\n        var undetectedDownloadedSamples = o.undetected_downloaded_samples\
    \ || [];\n        var detectedCommunicatingSamples = o.detected_communicating_samples\
    \ || [];\n        var undetectedCommunicatingSamples = o.undetected_communicating_samples\
    \ || [];\n        var detectedReferrerSamples = o.detected_referrer_samples ||\
    \ [];\n        var undetectedReferrerSamples = o.undetected_referrer_samples ||\
    \ [];\n        var resolutions = o.resolutions || [];\n        var arrTitle =\
    \ [{a: detectedUrls, t: 'Detected URL'}, {a: detectedDownloadedSamples, t: 'Detected\
    \ downloaded sample'},\n            {a: undetectedDownloadedSamples, t: 'Undetected\
    \ downloaded sample'}, {a: detectedCommunicatingSamples, t: 'Detected communicating\
    \ sample'},\n            {a: undetectedCommunicatingSamples, t: 'Undetected communicating\
    \ sample'},{a: detectedReferrerSamples, t: 'Detected referrer sample'},\n    \
    \        {a: undetectedReferrerSamples, t: 'Undetected referrer sample'}, {a:\
    \ resolutions, t: 'Resolutions'}];\n        for (var i = 0; i<arrTitle.length;\
    \ i++) {\n            if (arrTitle[i].a) {\n                md += arrTitle[i].t\
    \ + ' count: **' + arrTitle[i].a.length + '**\\n';\n            }\n        }\n\
    \        longFormat = FULL_RESPONSE? 'true': longFormat;\n        if (longFormat\
    \ === 'true') {\n            for (var j = 0; j<arrTitle.length; j++) {\n     \
    \           if (arrTitle[j].a) {\n                    md += '### ' + arrTitle[j].t\
    \ + '\\n';\n                    // Print only the first 10 rows\n            \
    \        var curr = [];\n                    for (var k = 0; k<Math.min(arrTitle[j].a.length,\
    \ sampleSize); k++) {\n                        curr.push(arrTitle[j].a[k]);\n\
    \                    }\n                    md += arrToMd(curr) + '\\n';\n   \
    \             }\n            }\n        }\n        if (o.domain_siblings && o.domain_siblings.length\
    \ > 0) {\n            md += \"### Observed subdomains\\n\";\n            for (i\
    \ = 0; i < o.domain_siblings.length; i++) {\n                md += \"- \" + o.domain_siblings[i]\
    \ + \"\\n\";\n            }\n        }\n        if (o.whois) {\n            var\
    \ whoIs = o.whois.trim();\n            var lines = whoIs ? whoIs.split(\"\\n\"\
    ) : [];\n            md += '### Whois Lookup\\n';\n            for (i = 0; i <\
    \ lines.length; i++) {\n                var parts = lines[i].split(': ');\n  \
    \              if (parts[0] && parts[1]) {\n                    md += \"**\" +\
    \ parts[0].trim() + \"**: \" + parts[1] + \"\\n\";\n                }\n      \
    \      }\n        }\n        var detected_downloaded_samples = o.detected_downloaded_samples;\n\
    \        if (detected_downloaded_samples === undefined) {\n            detected_downloaded_samples\
    \ = [];\n        } else {\n            detected_downloaded_samples = detected_downloaded_samples.slice(0,maxLen);\n\
    \        }\n        var undetected_downloaded_samples = o.undetected_downloaded_samples;\n\
    \        if (undetected_downloaded_samples === undefined) {\n            undetected_downloaded_samples\
    \ = [];\n        } else {\n            undetected_downloaded_samples = undetected_downloaded_samples.slice(0,maxLen);\n\
    \        }\n        var detected_urls = o.detected_urls;\n        if (detected_urls\
    \ === undefined) {\n            detected_urls = [];\n        } else {\n      \
    \      detected_urls = detected_urls.slice(0,maxLen);\n        }\n        var\
    \ detected_communicating_samples = o.detected_communicating_samples;\n       \
    \ if (detected_communicating_samples === undefined) {\n            detected_communicating_samples\
    \ = [];\n        } else {\n            detected_communicating_samples = detected_communicating_samples.slice(0,maxLen);\n\
    \        }\n        var undetected_communicating_samples = o.undetected_communicating_samples;\n\
    \        if (undetected_communicating_samples === undefined) {\n            undetected_communicating_samples\
    \ = [];\n        } else {\n            undetected_communicating_samples = undetected_communicating_samples.slice(0,maxLen);\n\
    \        }\n        resolutions = o.resolutions;\n        if (resolutions ===\
    \ undefined) {\n            resolutions = [];\n        } else {\n            resolutions\
    \ = resolutions.slice(0,maxLen);\n        }\n        var detected_referrer_samples\
    \ = o.detected_referrer_samples;\n        if (detected_referrer_samples === undefined)\
    \ {\n            detected_referrer_samples = [];\n        } else {\n         \
    \   detected_referrer_samples = detected_referrer_samples.slice(0,maxLen);\n \
    \       }\n        var undetected_referrer_samples = o.undetected_referrer_samples;\n\
    \        if (undetected_referrer_samples === undefined) {\n            undetected_referrer_samples\
    \ = [];\n        } else {\n            undetected_referrer_samples = undetected_referrer_samples.slice(0,maxLen);\n\
    \        }\n        var domain_siblings = o.domain_siblings;\n        if (domain_siblings\
    \ === undefined) {\n            domain_siblings = [];\n        } else {\n    \
    \        domain_siblings = domain_siblings.slice(0,maxLen);\n        }\n     \
    \   domain_ec = {\n            \"Name\": domain,\n            \"VirusTotal\":\
    \ {\n                'DownloadedHashes': detected_downloaded_samples,\n      \
    \          'UnAVDetectedDownloadedHashes': undetected_downloaded_samples,\n  \
    \              \"DetectedURLs\": detected_urls,\n                'CommunicatingHashes':\
    \ detected_communicating_samples,\n                'UnAVDetectedCommunicatingHashes':\
    \ undetected_communicating_samples,\n                'Resolutions': resolutions,\n\
    \                'ReferrerHashes': detected_referrer_samples,\n              \
    \  'UnAVDetectedReferrerHashes': undetected_referrer_samples,\n              \
    \  'Whois': o.whois,\n                'Subdomains': domain_siblings,\n       \
    \     }\n        };\n        if (ec[outputPaths.domain]){ // malicious\n     \
    \       ec[outputPaths.domain].VirusTotal = {\n                'DownloadedHashes':\
    \ detected_downloaded_samples,\n                'UnAVDetectedDownloadedHashes':\
    \ undetected_downloaded_samples,\n                \"DetectedURLs\": detected_urls,\n\
    \                'CommunicatingHashes': detected_communicating_samples,\n    \
    \            'UnAVDetectedCommunicatingHashes': undetected_communicating_samples,\n\
    \                'Resolutions': resolutions,\n                'ReferrerHashes':\
    \ detected_referrer_samples,\n                'UnAVDetectedReferrerHashes': undetected_referrer_samples,\n\
    \                'Whois': o.whois,\n                'Subdomains': domain_siblings,\n\
    \            };\n        } else { // not malicious\n            ec[outputPaths.domain]\
    \ = domain_ec;\n        }\n\n        entryList.push({\n            Type: entryTypes.note,\n\
    \            Contents: res.body,\n            ContentsFormat: formats.json,\n\
    \            HumanReadable: md,\n            EntryContext: ec\n        });\n \
    \   }\n    return entryList;\n}\nfunction scanURL(url) {\n    var res = doReq('POST',\
    \ 'url/scan', {url: url});\n    var r = [];\n    if (Array.isArray(res.obj)) {\
    \ // Got multiple URLs so need to nicely iterate\n        r = res.obj;\n    }\
    \ else {\n        r = [res.obj];\n    }\n    var md = '';\n    var ec = {vtScanID:\
    \ [], vtLink: []};\n    for (var i=0; i<r.length; i++) {\n        md += '## VirusTotal\
    \ URL scan for: [' + r[i].url + '](' + r[i].permalink + ')\\n';\n        md +=\
    \ 'Scan ID: **' + r[i].scan_id + '**\\n';\n        ec.vtScanID.push(r[i].scan_id);\n\
    \        ec.vtLink.push(r[i].permalink);\n        md += 'Scan Date: **' + r[i].scan_date\
    \ + '**\\n\\n';\n    }\n    return {\n        Type: entryTypes.note,\n       \
    \ Contents: res.body,\n        ContentsFormat: formats.json,\n        HumanReadable:\
    \ md,\n        EntryContext: ec\n    };\n}\nfunction scanFile(entry, uploadURL)\
    \ {\n    var url = uploadURL ? uploadURL : serverUrl + 'file/scan';\n    var fileName\
    \ = dq(invContext, \"File(val.EntryID == '\" + entry + \"').Name\");\n    if (Array.isArray(fileName))\
    \ {\n        if (fileName.length > 0) {\n            fileName = fileName[0];\n\
    \        } else {\n            fileName = undefined;\n        }\n    }\n    var\
    \ result = httpMultipart(url, entry, {Method: 'POST', Headers: {'Accept': ['application/json']}},\
    \ {apikey: params.APIKey},\n        params.insecure, params.proxy, undefined,\
    \ 'file', fileName);\n    if (result.StatusCode < 200 || result.StatusCode > 299)\
    \ {\n        throw 'Failed to perform request ' + url + ', request status code:\
    \ ' + result.StatusCode;\n    }\n    if (result.Body === '' && result.StatusCode\
    \ == 204) {\n        throw 'No content recieved. Possible API rate limit reached.';\n\
    \    }\n    if (result.Body === '') {\n        throw 'No content recieved. Maybe\
    \ you tried a private API?.';\n    }\n    var obj;\n    try {\n        obj = JSON.parse(result.Body);\n\
    \    } catch (ex) {\n        throw 'Error parsing reply - ' + result.Body + '\
    \ - ' + ex;\n    }\n    if (obj.response_code !== 1) {\n        throw 'Response\
    \ code: ' + obj.response_code + ', message: ' + obj.verbose_msg;\n    }\n    var\
    \ ec = {};\n    ec.vtScanID = obj.scan_id;\n    ec.vtLink = obj.permalink;\n \
    \   var md = '## VirusTotal scan file for [' + entry + '](' + obj.permalink +\
    \ ')\\n';\n    md += 'Resource: **' + obj.resource + '**\\n';\n    md += 'MD5\
    \ / SHA1 / SHA256: **' + obj.md5 + ' / ' + obj.sha1 + ' / ' + obj.sha256 + '**\\\
    n';\n    return {\n        Type: entryTypes.note,\n        Contents: result.Body,\n\
    \        ContentsFormat: formats.json,\n        HumanReadable: md,\n        EntryContext:\
    \ ec\n    };\n}\nfunction rescanFile(hash) {\n    var res = doReq('POST', 'file/rescan',\
    \ {resource: hash});\n    var r = [];\n    if (Array.isArray(res.obj)) { // Got\
    \ multiple hashes so need to nicely iterate\n        r = res.obj;\n    } else\
    \ {\n        r = [res.obj];\n    }\n    var md = '';\n    var ec = {vtScanID:\
    \ [], vtLink: []};\n    for (var i=0; i<r.length; i++) {\n        md += '## VirusTotal\
    \ File Rescan for: [' + r[i].resource + '](' + r[i].permalink + ')\\n';\n    \
    \    md += 'Scan ID: **' + r[i].scan_id + '**\\n';\n        ec.vtScanID.push(r[i].scan_id);\n\
    \        ec.vtLink.push(r[i].permalink);\n        md += 'MD5 / SHA1 / SHA256:\
    \ **' + r[i].md5 + ' / ' + r[i].sha1 + ' / ' + r[i].sha256 + '**\\n\\n';\n   \
    \ }\n    return {\n        Type: entryTypes.note,\n        Contents: res.body,\n\
    \        ContentsFormat: formats.json,\n        HumanReadable: md,\n        EntryContext:\
    \ ec\n    };\n}\nfunction doComments(resource, comment) {\n    var res = doReq('POST',\
    \ 'comments/put', {resource: resource, comment: comment});\n    return {\n   \
    \     Type: entryTypes.note,\n        Contents: res.body,\n        ContentsFormat:\
    \ formats.json,\n        HumanReadable: res.obj.verbose_msg\n    };\n}\nfunction\
    \ getComments(resource, before) {\n    var params = {resource: resource};\n  \
    \  if (before) {\n        params.before = before;\n    }\n    var res = doReq('GET',\
    \ 'comments/get', params);\n    return {\n        Type: entryTypes.note,\n   \
    \     Contents: res.body,\n        ContentsFormat: formats.json,\n        HumanReadable:\
    \ arrToMd(res.obj.comments)\n    };\n}\nfunction fileScanUploadURL() {\n    var\
    \ res = doReq('GET', 'file/scan/upload_url');\n    return {\n        Type: entryTypes.note,\n\
    \        Contents: res.body,\n        ContentsFormat: formats.json,\n        HumanReadable:\
    \ res.obj.upload_url,\n        EntryContext: {vtUploadURL: res.obj.upload_url}\n\
    \    };\n}\nfunction test() {\n    // if getting \"No content received. Possible\
    \ API rate limit reached.\" it's means that the api key use not usable right now,\
    \ but it's working\n    try\n    {\n        doFile('7657fcb7d772448a6d8504e4b20168b8');\
    \ // Check sample file - it will throw an error if not successful\n    } catch(err)\n\
    \    {\n        if (err == \"No content received. Possible API rate limit reached.\"\
    ){\n            return true;\n        }\n        return String(err);\n    }\n\
    \    return true;\n}\ntry {\n    switch (command) {\n        case 'test-module':\n\
    \            return test();\n        case 'file':\n            return doFile(args.file,\
    \ args.long, args.threshold, args.wait, args.retries);\n        case 'ip':\n \
    \           return doIP(args.ip, args.long, args.threshold, args.sampleSize, args.wait,\
    \ args.retries, args.fullResponse);\n        case 'url':\n            return doURL(args.url,\
    \ args.threshold, args.long, args.sampleSize, args.submitWait, args.wait, args.retries);\n\
    \        case 'domain':\n            return doDomain(args.domain, args.threshold,\
    \ args.long, args.sampleSize, args.wait, args.retries);\n        case 'file-scan':\n\
    \            return scanFile(args.entryID, args.uploadURL);\n        case 'file-rescan':\n\
    \            return rescanFile(args.file);\n        case 'url-scan':\n       \
    \     return scanURL(args.url);\n        case 'vt-comments-add':\n           \
    \ return doComments(args.resource, args.comment);\n        case 'vt-comments-get':\n\
    \            return getComments(args.resource, args.before);\n        case 'vt-file-scan-upload-url':\n\
    \            return fileScanUploadURL();\n        default:\n            throw\
    \ 'Unknown command - ' + command;\n    }\n} catch (err) {\n    return {\n    \
    \    'Type' : entryTypes.error,\n        'ContentsFormat' : formats.text,\n  \
    \      'Contents': err,\n        'EntryContext': {'Error': err}\n    };\n}"
  type: javascript
tests:
- virusTotal-test-playbook
toversion: 4.1.9
