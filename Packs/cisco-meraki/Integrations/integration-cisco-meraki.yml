category: IT Services
commonfields:
  id: Cisco Meraki
  version: -1
configuration:
- defaultvalue: ''
  display: API Key
  name: apiKey
  required: true
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Cloud controlled WiFi, routing, and security
detaileddescription: Get api key from Meraki dashboard
display: Cisco Meraki
hidden: false
image: data:image/png;base64,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
name: Cisco Meraki
script:
  commands:
  - arguments: []
    description: List the organizations that the api-key has privileges on
    name: meraki-fetch-organizations
    outputs:
    - contextPath: Organization
      description: List of organizations, each includes ID & Name
  - arguments:
    - description: Organization id
      name: organizationId
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: License state for an organization
    name: meraki-get-organization-license-state
  - arguments:
    - description: Organization id
      name: organizationId
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List of Inventories for an organization
    name: meraki-fetch-organization-inventory
    outputs:
    - contextPath: Devices
      description: List of devices, each includes Serial, NetworkId, Model, ClaimedAt,
        PublicIp & Mac
  - arguments:
    - description: Organization id
      name: organizationId
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List the networks in an organization
    name: meraki-fetch-networks
    outputs:
    - contextPath: Network
      description: List of networks, each includes ID, Name, Type, OrganizationId,
        Tags & TimeZone
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List the devices in a network
    name: meraki-fetch-devices
    outputs:
    - contextPath: Device
      description: List of devices, each includes Serial, Name, Lat, Lng, Model, NetworkId,
        Tags, MAC & Address
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Device serial#
      name: serial
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List of uplink information for a device.
    name: meraki-fetch-device-uplink
    outputs:
    - contextPath: Uplink
      description: List of device uplink, each includes Status & Interface
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List the SSIDs in a network
    name: meraki-fetch-ssids
    outputs:
    - contextPath: SSID
      description: List of SSIDs, each includes Number, NetworkId, Name, SplashPage,
        BandSelection, Enabled, AuthMode & WalledGardenRanges
  - arguments:
    - description: Device serial#
      name: serial
      required: true
    - description: ' The timespan(in seconds) for which clients will be fetched. Must
        be at most one month and in seconds (e.g. 1 day is 86400 seconds).'
      name: timespan
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List the clients of a device, up to a maximum of a month ago
    name: meraki-fetch-clients
    outputs:
    - contextPath: Client
      description: List of clients, each includes ID, MAC, IP, Description, mDNSName,
        Hostname, Usage & VLAN
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: SSID number
      name: number
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: List of L3 firewall rules for an SSID
    name: meraki-fetch-firewall-rules
    outputs:
    - contextPath: Firewall
      description: List of firewalls, each includes Number, NetworkId, Policy, Protocol,
        DestPort, DestCidr & Comment
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Device serial to remove
      name: serial
      required: true
    description: Remove a single device
    name: meraki-remove-device
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Device serial
      name: serial
      required: true
    - description: Table's headers to be shown by order
      name: headers
    description: Get a single device
    name: meraki-get-device
    outputs:
    - contextPath: Device
      description: Device which includes Serial, Name, Lat, Lng, Model, NetworkId,
        Tags, MAC & Address
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Device serial to update
      name: serial
      required: true
    - description: New name of the device
      name: name
    - description: New tags of the device
      name: tags
    - description: New address of the device
      name: address
    - description: New latitude of the device
      name: lat
    - description: New longitude of the device
      name: lng
    description: Update the attributes of a device
    name: meraki-update-device
    outputs:
    - contextPath: Device
      description: Updated evice which includes Serial, Name, Lat, Lng, Model, NetworkId,
        Tags, MAC & Address
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - description: Device serial to claim
      name: serial
      required: true
    description: Claim a device into a network
    name: meraki-claim-device
  - arguments:
    - description: Network id
      name: networkId
      required: true
    - defaultValue: ' '
      description: SSID number
      name: number
      required: true
    - auto: PREDEFINED
      description: allow or deny wireless client access to local LAN, true allows
        access and false denies access
      name: allowLanAccess
      predefined:
      - 'true'
      - 'false'
      required: true
    - auto: PREDEFINED
      description: ' Whether or not you want to allow or deny a protocol (value must
        be ''allow'' or ''deny'')'
      name: policy
      predefined:
      - allow
      - deny
      required: true
    - auto: PREDEFINED
      description: The type of protocol (must be 'tcp','udp', 'icmp' or 'any')
      name: protocol
      predefined:
      - tcp
      - udp
      - icmp
      - any
      required: true
    - description: ' The destination port (can be ''any'' or an integer within the
        range of 1-65535)'
      name: destPort
      required: true
    - description: The destination IP address or subnet in CIDR form, can also be
        'any'
      name: destCidr
      required: true
    - description: A note about the rule
      name: comment
    - auto: PREDEFINED
      description: true to remove all others rule, false to only add rule
      name: removeOthers
      predefined:
      - 'true'
      - 'false'
      required: true
    description: update rule to L3 firewall rules of an SSID
    name: meraki-update-firewall-rules
    outputs:
    - contextPath: Firewall
      description: List of firewalls, each includes Number, NetworkId, Policy, Protocol,
        DestPort, DestCidr & Comment
  script: "/**\n   * flatten nested object to top level fields\n   * @param {Object\
    \ | Array<Object>} ob - object to flatten\n   * @returns {String} the flatten\
    \ object\n   * { \"a\": \"bla\", \"b\": { \"c\": \"hello\", \"d\": \"there\" }\
    \ } => { \"a\": \"bla\", \"b.c\" = \"hello\", \"b.d\": \"there\" }\n*/\nvar flattenObject\
    \ = function(ob) {\n    var toReturn = {};\n\n    for (var i in ob) {\n      \
    \  if (!ob.hasOwnProperty(i)) continue;\n\n        if ((typeof ob[i]) == 'object')\
    \ {\n            var flatObject = flattenObject(ob[i]);\n            for (var\
    \ x in flatObject) {\n                if (!flatObject.hasOwnProperty(x)) continue;\n\
    \n                toReturn[i + '.' + x] = flatObject[x];\n            }\n    \
    \    } else {\n            toReturn[i] = ob[i];\n        }\n    }\n    return\
    \ toReturn;\n};\n\n/**\n   * Converts a demisto table in JSON form to a Markdown\
    \ table\n   * @param {String} name - the name of the table\n   * @param {Object\
    \ | Array<Object>} table - the JSON table - Array of objects with the same keys\n\
    \   * @param {Array} headers - optinal, the output markdown table will show only\
    \ this headers (by order)\n   * @returns {String} Markdown representation of the\
    \ original list\n*/\nvar tableToMd = function(name, table, headers) {\n\n    if\
    \ (!(table instanceof Array)){\n          table = [table];\n      }\n\n    var\
    \ res = '### ' + name + '\\n';\n    table = table.map(flattenObject);\n    if(table\
    \ && table.length) {\n        // use table's keys if headers are not provieded\n\
    \        if(!headers) {\n            headers = Object.keys(table[0]);\n      \
    \  }\n\n        // headers\n        res += headers.join('|') + '\\n';\n      \
    \  res += headers.map(function(h) { return '-'; }).join('|') + '\\n';\n\n    \
    \    // body\n        for(var i = 0; i< table.length; i++) {\n            var\
    \ obj = table[i];\n            var values = [];\n            var val;\n      \
    \      headers.forEach(function(key) {\n                val = '-';\n         \
    \       if (obj[key] || obj[key] === '0' || obj[key] === '0') {\n            \
    \        val = obj[key];\n                }\n                values.push(val);\n\
    \            });\n            res += values.join('|') + '\\n';\n        }\n  \
    \  } else {\n        res += '**No entries.**\\n';\n    }\n    return res;\n}\n\
    \nvar createTableEntry = function (name, contents, context, headers) {\n    return\
    \ {\n        // type\n        Type: entryTypes.note,\n         // contents\n \
    \       ContentsFormat: formats.json, Contents: contents,\n        // human-readable\n\
    \        ReadableContentsFormat: formats.markdown, HumanReadable: tableToMd(name,\
    \ contents, headers),\n        // context\n        EntryContext: context\n   \
    \ };\n}\n\nvar createTextEntry = function(text) {\n    return text;\n}\n\nvar\
    \ createMapEntry = function(obj) {\n\n    var location = {\n        lat: obj.lat,\n\
    \        lng: obj.lng\n    };\n\n    return {\n        // type\n        Type:\
    \ 15, // entryTypes.map,\n         // contents\n        ContentsFormat: formats.json,\
    \ Contents: location\n    };\n}\n\nvar merakiUrlPrefix = 'https://api.meraki.com/api/v0/';\n\
    var apiKey = params.apiKey;\nvar insecure = params.insecure;\nvar proxy = params.proxy;\n\
    \nvar sendRequest = function(url, method, body) {\n\n    var requestMethod = method\
    \ || 'GET';\n    var requestUrl = merakiUrlPrefix + url;\n\n    var httpParams\
    \ = {\n        Method: requestMethod,\n        Headers: {\n            'X-Cisco-Meraki-API-Key':\
    \ [apiKey],\n            'Content-Type': ['application/json'],\n        },\n \
    \       Body: body\n    };\n\n    var res = http(\n        requestUrl,\n     \
    \   httpParams,\n        insecure,\n        proxy,\n        true // no redirect\
    \ (e.i. request is not automatically redirect - instead it will return 302)\n\
    \    );\n\n    // catch redirect response\n    if (res && (res.StatusCode ===\
    \ 302 || res.StatusCode === 308)) {\n        var redirectUrl = res.Headers.Location;\n\
    \n        res = http(\n                redirectUrl,\n                httpParams,\n\
    \                insecure,\n                proxy\n        );\n    }\n\n    if\
    \ (!res || res.StatusCode < 200 || res.StatusCode >= 300) {\n        throw 'Request\
    \ Failed. '\n        + '\\nUrl: ' + requestUrl\n        + '\\nStatus code: ' +\
    \ res.StatusCode\n        + '\\nSurl: ' + res.StatusCode\n        + '.\\nBody:\
    \ ' + JSON.stringify(res) + '.';\n    }\n\n    if(requestMethod === 'POST') {\n\
    \        // action succeed - than just return true\n        return true;\n   \
    \ } else {\n         var resBody = JSON.parse(res.Body);\n    if (resBody ===\
    \ undefined) {\n       throw 'Request Failed, returned response with no body';\n\
    \    }\n    return resBody;\n    }\n};\n\n/**\n   * return a function that transform\
    \ object from some structure to other\n   * @param {Array} fields - array of {from:\
    \ String, to: String} - to transform by\n   * @returns {Function} array from the\
    \ original string-list\n*/\nvar mapObjFunction = function(mapFields) {\n    return\
    \ function(obj) {\n        var res = {};\n        mapFields.forEach(function(f)\
    \ {\n           res[f.to] = (obj[f.from] !== undefined) ? obj[f.from] : null;\n\
    \        });\n        return res;\n    }\n}\n\n// maps device api-object to context-object\n\
    var mapDeviceFunction = mapObjFunction([\n    { from: 'serial', to: 'Serial' },\n\
    \    { from: 'name', to: 'Name' },\n    { from: 'mac', to: 'MAC' },\n    { from:\
    \ 'lat', to: 'Lat' },\n    { from: 'lng', to: 'Lng' },\n    { from: 'address',\
    \ to: 'Address' },\n    { from: 'lanIp', to: 'LanIp' },\n    { from: 'tags', to:\
    \ 'Tags' },\n    { from: 'networkId', to: 'NetworkId' },\n    { from: 'model',\
    \ to: 'Model' },\n    { from: 'claimedAt', to: 'ClaimedAt' },\n    { from: 'publicIp',\
    \ to: 'PublicIp' }\n]);\n\n// maps firewall api-object to context-object\nvar\
    \ mapFirewallFunction = mapObjFunction([\n    { from: 'comment', to: 'Comment'\
    \ },\n    { from: 'policy', to: 'Policy' },\n    { from: 'protocol', to: 'Protocol'\
    \ },\n    { from: 'destPort', to: 'DestPort' },\n    { from: 'destCidr', to: 'DestCidr'\
    \ }\n]);\n\n// --------- organizations ------- //\nvar fetchOrganizations = function()\
    \ {\n    // get result from http\n    var organizations = sendRequest('organizations');\n\
    \n    // create context\n    var context = {};\n    if(organizations && organizations.length)\
    \ {\n        context.Organization = organizations.map(mapObjFunction([\n     \
    \       { from: 'id', to: 'ID' },\n            { from: 'name', to: 'Name' }\n\
    \        ]));\n    }\n    return createTableEntry(\"Organizations\", organizations,\
    \ context);\n};\n\nvar getOrganizationLiceseState = function(organizationId, headers)\
    \ {\n    // get result from http\n    var license = sendRequest('organizations/'\
    \ + organizationId + '/licenseState');\n\n    return createTableEntry(\"Organization\
    \ License State\", license, {}, headers);\n};\n\nvar fetchOrganizationInventory\
    \ = function(organizationId, headers) {\n    // get result from http\n    var\
    \ devices = sendRequest('organizations/' + organizationId + '/inventory');\n\n\
    \     // create context\n    var context = {};\n    if(devices && devices.length)\
    \ {\n        context.Device = devices.map(mapDeviceFunction);\n    }\n\n    return\
    \ createTableEntry(\"Organization Inventory\", devices, context, headers);\n};\n\
    \n// --------- networks ------- //\n\nvar fetchNetworks = function(organizationId,\
    \ headers) {\n     // get result from http\n    var networks = sendRequest('organizations/'\
    \ + organizationId + '/networks');\n\n     // create context\n    var context\
    \ = {};\n    if(networks && networks.length) {\n        context.Network = networks.map(mapObjFunction([\n\
    \            { from: 'id', to: 'ID' },\n            { from: 'organizationId',\
    \ to: 'OrganizationId' },\n            { from: 'type', to: 'Type' },\n       \
    \     { from: 'name', to: 'Name' },\n            { from: 'timeZone', to: 'Timezone'\
    \ },\n            { from: 'tags', to: 'Tags' },\n        ]));\n    }\n\n    return\
    \ createTableEntry(\"Networks\", networks, context, headers);\n};\n\n// ---------\
    \ devices ------- //\n\nvar fetchDevices = function(networkId, headers) {\n  \
    \   // get result from http\n    var devices = sendRequest('networks/' + networkId\
    \ + '/devices');\n\n     // create context\n    var context = {};\n    if(devices\
    \ && devices.length) {\n        context.Device = devices.map(mapDeviceFunction);\n\
    \    }\n\n    return createTableEntry(\"Devices\", devices, context, headers);\n\
    };\n\nvar fetchDeviceUplink = function(networkId, serial, headers) {\n    // get\
    \ result from http\n    var uplinks = sendRequest('networks/' + networkId + '/devices/'\
    \ + serial + '/uplink');\n\n     // create context\n    var context = {};\n  \
    \  if(uplinks && uplinks.length) {\n        context.Uplink = uplinks.map(mapObjFunction([\n\
    \            { from: 'status', to: 'Status' },\n            { from: 'interface',\
    \ to: 'Interface' }\n        ]));\n    }\n    return createTableEntry(\"Device\
    \ Uplink\", uplinks, context, headers);\n};\n\nvar fetchDeviceClients = function(serial,\
    \ timespan, headers) {\n    // get result from http\n    var clients = sendRequest('devices/'\
    \ + serial + '/clients?timespan=' + timespan);\n\n     // create context\n   \
    \ var context = {};\n    if(clients && clients.length) {\n        context.Client\
    \ = clients.map(mapObjFunction([\n            { from: 'description', to: 'Description'\
    \ },\n            { from: 'mdnsName', to: 'mDNSName' },\n            { from: 'dhcpHostname',\
    \ to: 'Hostname' },\n            { from: 'usage', to: 'Usage' },\n           \
    \ { from: 'mac', to: 'MAC' },\n            { from: 'ip', to: 'IP' },\n       \
    \     { from: 'id', to: 'ID' },\n            { from: 'vlan', to: 'VLAN' }\n  \
    \      ]));\n    }\n\n    return createTableEntry(\"Clients\", clients, context,\
    \ headers);\n};\n\nvar getDevice = function(networkId, serial, headers) {\n  \
    \   // get result from http\n    var device = sendRequest('networks/' + networkId\
    \ + '/devices/' + serial);\n\n     // create context\n    var context = {};\n\
    \    if(device) {\n        context.Device = mapDeviceFunction(device);\n    }\n\
    \n    return [createTableEntry(\"Device \" + serial, device, context, headers),\
    \ createMapEntry(device)];\n};\n\nvar removeDevice = function(networkId, serial)\
    \ {\n    var res = sendRequest('networks/' + networkId + '/devices/' + serial\
    \ + '/remove', 'POST');\n\n    var textResult;\n    if(res) {\n            textResult\
    \ = 'Successfully removed device ' + serial + ' from network ' + networkId;\n\
    \    } else {\n        textResult = 'Failed to removed device ' + serial + ' from\
    \ network ' + networkId;\n    }\n    return createTextEntry(textResult);\n};\n\
    \nvar updateDevice = function(networkId, serial, updateArgs) {\n    //send update\
    \ request\n    var url = 'networks/' + networkId + '/devices/' + serial;\n\n \
    \   var body = {};\n    var keys = Object.keys(updateArgs);\n    keys.forEach(function\
    \ (key) {\n       if(updateArgs[key]) {\n           body[key] = updateArgs[key];\n\
    \       }\n    });\n\n    var device = sendRequest(url, 'PUT', JSON.stringify(body));\n\
    \n    // create context\n    var context = {};\n    if(device) {\n        context.Device\
    \ = mapDeviceFunction(device);\n    }\n\n    return createTableEntry(\"Successfully\
    \ Updated Device \" + serial, device, context);\n}\n\nvar claimDevice = function(networkId,\
    \ serial) {\n    var url = 'networks/' + networkId + '/devices/claim';\n    var\
    \ body = { serial: serial };\n\n    var succeed = succeed(url, 'POST', JSON.stringify(body));\n\
    \n    var resStr;\n    if(succeed) {\n        resStr = 'Successfully joined device\
    \ ' + serial + ' to network ' + networkId;\n    } else {\n        resStr = 'Failed\
    \ to claim device ' + serial + ' to network ' + networkId;\n    }\n};\n\nvar fetchSsids\
    \ = function(networkId, headers) {\n    // get result from http\n    var ssids\
    \ = sendRequest('networks/' + networkId + '/ssids');\n\n\n     // create context\n\
    \    var context = {};\n    if(ssids && ssids.length) {\n        context.SSID\
    \ = ssids\n        .map(mapObjFunction([\n            { from: 'name', to: 'Name'\
    \ },\n            { from: 'splashPage', to: 'SplashPage' },\n            { from:\
    \ 'bandSelection', to: 'BandSelection' },\n            { from: 'enabled', to:\
    \ 'Enabled' },\n            { from: 'authMode', to: 'AuthMode' },\n          \
    \  { from: 'walledGardenRanges', to: 'WalledGardenRanges' },\n            { from:\
    \ 'number', to: 'Number' }\n        ]))\n        .map(function(ssid) {\n     \
    \       ssid.NetworkId = networkId;\n            return ssid;\n        });\n \
    \   }\n    return createTableEntry(\"SSIDs\", ssids, context, headers);\n};\n\n\
    var fetchFirewallRules = function(networkId, number, headers) {\n    // get result\
    \ from http\n    var firewalls = sendRequest('networks/' + networkId + '/ssids/'\
    \ + number + '/l3FirewallRules');\n     // create context\n    var context = {};\n\
    \    if(firewalls && firewalls.length) {\n        context.Firewall = firewalls\n\
    \        .map(mapFirewallFunction)\n        .map(function(fireWall) {\n      \
    \      fireWall.NetworkId = networkId;\n            fireWall.Number = number;\n\
    \            return fireWall;\n        });\n    }\n    return createTableEntry(\"\
    Firewall Rules\", firewalls, context, headers);\n};\n\nvar updateFirewallRules\
    \ = function(networkId, number, allowLanAccess, removeOthers, rule) {\n    var\
    \ url = 'networks/' + networkId + '/ssids/' + number + '/l3FirewallRules';\n\n\
    \    var rules;\n    if(removeOthers) {\n        rules = [rule];\n    } else {\n\
    \        rules = sendRequest('networks/' + networkId + '/ssids/' + number + '/l3FirewallRules');\n\
    \        rules = rules.slice(0, -2); // remove defulat & local LAN access rules\n\
    \        rules.push(rule);\n    }\n    var body = {\n        allowLanAccess: allowLanAccess,\n\
    \        rules: rules\n    };\n\n    var firewalls = sendRequest(url, 'PUT', JSON.stringify(body));\n\
    \n     // create context\n    var context = {};\n    if(firewalls && firewalls.length)\
    \ {\n        context.Firewall = firewalls\n        .map(mapFirewallFunction)\n\
    \        .map(function(fireWall) {\n            fireWall.NetworkId = networkId;\n\
    \            fireWall.Number = number;\n            return fireWall;\n       \
    \ });\n    }\n    return createTableEntry(\"Firewall Rules\", firewalls, context);\n\
    };\n\n\n// --------------------- main -------------------- //\nswitch (command)\
    \ {\n    case 'test-module':\n        fetchOrganizations();\n        return 'ok';\n\
    \    // organization\n    case 'meraki-fetch-organizations':\n        return fetchOrganizations();\n\
    \    case 'meraki-fetch-organization-inventory':\n        return fetchOrganizationInventory(\n\
    \            args.organizationId,\n            args.headers && args.headers.split(',')\n\
    \        );\n    case 'meraki-get-organization-license-state':\n        return\
    \ getOrganizationLiceseState(\n            args.organizationId,\n            args.headers\
    \ && args.headers.split(',')\n        );\n    // network\n    case 'meraki-fetch-networks':\n\
    \        return fetchNetworks(\n            args.organizationId,\n           \
    \ args.headers && args.headers.split(',')\n        );\n    // device\n    case\
    \ 'meraki-fetch-devices':\n        return fetchDevices(\n            args.networkId,\n\
    \            args.headers && args.headers.split(',')\n        );\n    case 'meraki-get-device':\n\
    \        return getDevice(\n            args.networkId,\n            args.serial,\n\
    \            args.headers && args.headers.split(',')\n        );\n    case 'meraki-update-device':\n\
    \        return updateDevice(\n            args.networkId,\n            args.serial,\n\
    \            { // updateArgs\n                name: args.name,\n             \
    \   tags: args.tags,\n                address: args.address,\n               \
    \ lat: args.lat,\n                lng: args.lng\n            }\n        );\n \
    \   case 'meraki-claim-device':\n        return claimDevice(\n            args.serial,\n\
    \            args.networkId\n        );\n    case 'meraki-fetch-device-uplink':\n\
    \         return fetchDeviceUplink(\n            args.networkId,\n           \
    \ args.serial,\n            args.headers && args.headers.split(',')\n        );\n\
    \    case 'meraki-fetch-clients':\n        return fetchDeviceClients(\n      \
    \      args.serial,\n            args.timespan,\n            args.headers && args.headers.split(',')\n\
    \        );\n    case 'meraki-fetch-firewall-rules':\n        return fetchFirewallRules(\n\
    \            args.networkId,\n            args.number,\n            args.headers\
    \ && args.headers.split(',')\n        );\n    case 'meraki-update-firewall-rules':\n\
    \        return updateFirewallRules(\n            args.networkId,\n          \
    \  args.number,\n            (args.allowLanAccess === \"true\"),\n           \
    \ (args.removeOthers === \"true\"),\n            {\n                policy: args.policy,\n\
    \                protocol: args.protocol,\n                destPort: args.destPort,\n\
    \                destCidr: args.destCidr,\n                comment: args.comment\n\
    \            }\n        );\n    case 'meraki-remove-device':\n        var networkId\
    \ = args.networkId;\n        var serial = args.serial;\n        return removeDevice(networkId,\
    \ serial);\n    // ssid\n    case 'meraki-fetch-ssids':\n        return fetchSsids(\n\
    \            args.networkId,\n            args.headers && args.headers.split(',')\n\
    \        );\n    default:\n        throw 'Unrecognized command';\n}\n"
  type: javascript
tests:
- Cisco-Meraki-Test
toversion: 4.1.9
