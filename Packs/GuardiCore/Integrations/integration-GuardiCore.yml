category: Deception
commonfields:
  id: GuardiCore
  version: -1
configuration:
- defaultvalue: ''
  display: Server URL (e.g. https://192.168.0.1)
  name: server
  required: true
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Data center breach detection
display: GuardiCore
fromversion: 3.5.0
image: data:image/png;base64,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
name: GuardiCore
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: Filter by severity.
      name: severity
      predefined:
      - High
      - Low
      - Medium
    - description: Filter by tag.
      name: tag
    - description: Filter by type of incidents, e.g. Deception, Lateral Movement.
      name: incident_type
    - description: Filter by source (hostname or IP address).
      name: source
    - description: Filter by destination (hostname or IP address).
      name: destination
    description: Display information about incidents (with filters).
    name: guardicore-get-incidents
  - arguments: []
    description: Display the uncommon domains.
    name: guardicore-uncommon-domains
  - arguments: []
    description: Display the unresolved domains.
    name: guardicore-unresolved-domains
  - arguments:
    - description: The host ID.
      name: host_id
      required: true
    description: Display information about the endpoint given its ID.
    name: guardicore-show-endpoint
  - arguments: []
    description: Display the DNS requests.
    name: guardicore-dns-requests
  - arguments:
    - description: The IP address of the endpoint.
      name: ip_address
    - description: The hostname of the endpoint.
      name: name
    description: Display information about the endpoint by its hostname or IP address.
    name: guardicore-search-endpoint
  - arguments: []
    description: Display the misconfigurations.
    name: guardicore-misconfigurations
  - arguments:
    - default: true
      description: The ID of the incident.
      name: id
      required: true
    description: Display information about the given incident.
    name: guardicore-get-incident
  - arguments:
    - default: true
      description: The ID of the incident.
      name: id
      required: true
    description: Display the IOCs (Indicators of Compromise) of the given incident.
    name: guardicore-get-incident-iocs
  - arguments:
    - description: The ID of the incident.
      name: id
      required: true
    description: Display the events related to the given incidents.
    name: guardicore-get-incident-events
  - arguments:
    - description: The ID of the incident.
      name: id
      required: true
    description: Retrieve the PCAP file attached to the given incident.
    name: guardicore-get-incident-pcap
  - arguments:
    - description: The ID of the incident.
      name: id
      required: true
    description: Retrieve the files attached to the given incidents.
    name: guardicore-get-incident-attachments
  - arguments:
    - description: Filter by source (hostname or IP address).
      name: source
    - description: Filter by destination (hostname or IP address).
      name: destination
    - description: Filter by port number.
      name: port
    - description: Filter by Event ID.
      name: uuid
    description: Searches within the network log (with filters).
    name: guardicore-search-network-log
  script: "var server = params.server.replace(/[\\/]+$/, '') + '/api/v3.0/';\n\nvar\
    \ urlDictionary = {\n    login: 'authenticate',\n    logout: 'logout',\n\n   \
    \ 'guardicore-get-incidents': 'incidents',\n    'guardicore-get-incident': 'incidents/%id%',\n\
    \    'guardicore-get-incident-iocs': 'incidents/%id%/iocs',\n    'guardicore-get-incident-events':\
    \ 'incidents/%id%/events',\n    'guardicore-get-incident-pcap': 'honeypots/%honeypotId%/files/%fileId%',\n\
    \    'guardicore-get-incident-attachments': 'honeypots/%honeypotId%/files/%fileId%',\n\
    \n    'guardicore-show-endpoint': 'assets/%host_id%',\n    'guardicore-search-endpoint':\
    \ 'assets',\n\n    'guardicore-uncommon-domains': 'connections/stats/dns-stats',\n\
    \    'guardicore-unresolved-domains': 'connections/stats/missing-hosts',\n   \
    \ 'guardicore-dns-requests': 'labs/dns-requests',\n    'guardicore-misconfigurations':\
    \ 'connections/stats/network-misconfigurations',\n\n    'guardicore-search-network-log':\
    \ 'network-events',\n};\n\nvar methodDictionary = {\n    login: 'POST',\n    logout:\
    \ 'POST',\n    'guardicore-get-incidents': 'GET',\n    'guardicore-get-incident':\
    \ 'GET',\n    'guardicore-get-incident-iocs': 'GET',\n    'guardicore-get-incident-events':\
    \ 'GET',\n    'guardicore-get-incident-pcap': 'GET',\n    'guardicore-get-incident-attachments':\
    \ 'GET',\n\n    'guardicore-show-endpoint': 'GET',\n    'guardicore-search-endpoint':\
    \ 'GET',\n\n    'guardicore-uncommon-domains' : 'GET',\n    'guardicore-unresolved-domains':\
    \ 'GET',\n    'guardicore-dns-requests': 'GET',\n    'guardicore-misconfigurations':\
    \ 'GET',\n\n    'guardicore-search-network-log': 'GET'\n};\n\n\n// converts raw\
    \ data to readable strings, for both the war room and the context\nOUTPUT_DOMAINS\
    \ = [\n    {from: 'domain', to: 'Domain'},\n    {from: 'count', to: 'Count'},\n\
    \    {from: 'clients_count', to: 'Clients Count'},\n    {from: 'clients', to:\
    \ 'Clients', parser: function(clients) {\n        var output = [];\n        for\
    \ (var i = 0; i < clients.length; i++) {\n            clientStr = buildClientStr(clients[i].vm.display_name,\
    \ clients[i].ip, clients[i].vm.id)\n            output.push(clientStr);\n    \
    \    }\n\n        return output.join('<br>');\n    }}\n];\n\n// Used for direct\
    \ parsing/formatting.\n// In case several inputs are needed for a single output,\
    \ it will be done in the specific parsing function.\nvar outputsDictionary = {\n\
    \    'guardicore-get-incident': [\n        {from: 'source_ip', to: 'Source IP'},\n\
    \        {from: 'source_port', to: 'Source Port'},\n        {from: 'destination_ip',\
    \ to: 'Destination IP'},\n        {from: 'destination_port', to: 'Destination\
    \ Port'},\n        {from: '_id', to: 'ID'},\n        {from: 'os', to: 'OS'},\n\
    \        {from: 'incident_type', to: 'Incident Type'},\n        {from: 'honeypot_id',\
    \ to: 'Honeypot ID'},\n        {from: 'start_time', to: 'Start Time', parser:\
    \ convertTimestampToString},\n        {from: 'end_time', to: 'End Time', parser:\
    \ convertTimestampToString},\n        {from: 'closed_time', to: 'Closed Time',\
    \ parser: convertTimestampToString},\n        {from: 'severity', to: 'Severity',\
    \ parser: function(sev) {\n            if (sev <= 30) {\n                return\
    \ 'Low';\n            } else if (sev >= 50) {\n                return 'High';\n\
    \            } else {\n                return 'Medium';\n            }\n     \
    \   }},\n        {from: 'incident_group', to: 'Incident Group', parser: function(ig)\
    \ {\n            return ig[0].gname + ' ' + ig[0].gid;\n        }},\n        {from:\
    \ 'concatenated_tags', to: 'Tags', parser: function(tags) {\n            var str\
    \ = '';\n            for (var i = 0; i < tags.length; i++) {\n               \
    \ str += tags[i].display_name + ', ';\n            }\n\n            return str.replace(/,\
    \ $/, '');\n        }}\n    ],\n    'guardicore-get-incident-iocs': [\n      \
    \  {from: '_id', to: 'ID'},\n        {from: '_cls', to: 'Type'},\n        {from:\
    \ 'creation_time', to: 'Creation Time', parser: convertTimestampToString},\n \
    \       {from: 'first_seen', to: 'First Seen', parser: convertTimestampToString},\n\
    \        {from: 'last_seen', to: 'Last Seen', parser: convertTimestampToString},\n\
    \    ],\n    'guardicore-uncommon-domains': OUTPUT_DOMAINS,\n    'guardicore-unresolved-domains':\
    \ OUTPUT_DOMAINS,\n    'guardicore-show-endpoint': [\n        {from: '_id', to:\
    \ 'ID'},\n        {from: 'ip_addresses', to: 'IP Addresses', parser: function(ipAddresses)\
    \ {\n            return ipAddresses.join('<br>');\n        }},\n        {from:\
    \ 'mac_addresses', to: 'MAC Addresses', parser: function(macAddresses) {\n   \
    \         return macAddresses.join('<br>');\n        }},\n        {from: 'recent_domains',\
    \ to: 'Recent Domains', parser: function(recentDomains) {\n            return\
    \ recentDomains.join('<br>');\n        }},\n        {from: 'comments', to: 'Comments'},\n\
    \        {from: 'first_seen', to: 'First Seen', parser: convertTimestampToString},\n\
    \        {from: 'last_seen', to: 'Last Seen', parser: convertTimestampToString},\n\
    \        {from: 'last_summary_update', to: 'Last Summary Update', parser: convertTimestampToString},\n\
    \        {from: 'risk_title', to: 'Risk Level'},\n        {from: 'status', to:\
    \ 'Status'},\n    ],\n    'guardicore-misconfigurations': [\n        {from: 'port_count',\
    \ to: 'Port Count'},\n        {from: 'flow_count', to: 'Flow Count'}\n    ],\n\
    \    'guardicore-dns-requests': [\n        {from: 'client_ip', to: 'Client IP'},\n\
    \        {from: 'packet_arrival_time', to: 'Packet Arrival Time', parser: convertTimestampToString},\n\
    \        {from: 'requested_host_name', to: 'Requested Hostname'}\n    ],\n   \
    \ 'guardicore-search-network-log': [\n        {from: '_cls', to: 'Class'},\n \
    \       {from: '_id', to: 'ID'},\n        {from: 'action', to: 'Action'},\n  \
    \      {from: 'description', to: 'Description'},\n        {from: 'destination_ip',\
    \ to: 'Destination IP'},\n        {from: 'destination_mac', to: 'Destination MAC'},\n\
    \        {from: 'destination_port', to: 'Destination Port'},\n        {from: 'processed_time',\
    \ to: 'Processed Time'},\n        {from: 'received_time', to: 'Received Time'},\n\
    \        {from: 'source_ip', to: 'Source IP'},\n        {from: 'source_mac', to:\
    \ 'Source MAC'},\n        {from: 'source_port', to: 'Source Port'}\n    ]\n};\n\
    \nvar mapObjFunction = function(mapFields) {\n    return function(obj) {\n   \
    \     var res = {};\n        mapFields.forEach(function(f) {\n            if (f.parser)\
    \ {\n                res[f.to] = f.parser(dq(obj, f.from)) || null;\n        \
    \    } else {\n                res[f.to] = dq(obj, f.from) || null;\n        \
    \    }\n        });\n\n        return res;\n    }\n}\n\nvar convertKeysToPascalCase\
    \ = function(dict) {\n    var pascalDict = {};\n    for (var key in dict) {\n\
    \        var pascalCaseKey = key.replace(/\\w+/g, function(w) { return w[0].toUpperCase()\
    \ + w.slice(1).toLowerCase(); }).replace(' ', '');\n        pascalDict[pascalCaseKey]\
    \ = dict[key];\n    }\n\n    return pascalDict;\n}\n\nvar doesResultExist = function(result)\
    \ {\n    return (\n        result &&\n        (!(result instanceof Array) || result.length)\
    \ &&\n        (!(result instanceof Object) || Object.keys(result).length)\n  \
    \  );\n}\n\nvar formatIncidentDescription = function(unformattedDescription) {\n\
    \    var description = '';\n    for (var j in unformattedDescription) {\n    \
    \    description += unformattedDescription[j].value;\n    }\n\n    return description;\n\
    }\n\nvar buildEmptyEntryContext = function() {\n    return {Type: entryTypes.note,\
    \ Contents: null, ContentsFormat: formats.json, EntryContext: {}};\n}\n\nvar parseGetIncident\
    \ = function(command, response) {\n    var output = mapObjFunction(outputsDictionary[command])(response);\n\
    \    output.Description = formatIncidentDescription(response.description);\n\n\
    \    var entry = buildEmptyEntryContext();\n    entry.HumanReadable = objToMd(output);\n\
    \    entry.EntryContext['GuardiCore.Incidents'] = convertKeysToPascalCase(output);\n\
    \n    return entry;\n}\n\nIOCS_NON_VALUE_KEYS = ['_id', '_cls', 'creation_time',\
    \ 'first_seen', 'last_seen', 'doc_version'];\nvar parseGetIncidentIOCs = function(command,\
    \ response) {\n    var outputs = [];\n    var contexts = [];\n    for (var i =\
    \ 0; i < response.length; i++) {\n        var output = mapObjFunction(outputsDictionary[command])(response[i]);\n\
    \n        // collect data for the Values field\n        var values = {};\n   \
    \     for (var responseKey in response[i]) {\n            if (IOCS_NON_VALUE_KEYS.indexOf(responseKey)\
    \ == -1) {\n                values[responseKey] = response[i][responseKey];\n\
    \            }\n        }\n\n        var valueList = [];\n        for (var valueKey\
    \ in values) {\n            valueList.push(valueKey + ': ' + values[valueKey]);\n\
    \        }\n\n        if (valueList.length > 0) {\n            output.Values =\
    \ valueList.join('<br>');\n        }\n\n        var contextData = convertKeysToPascalCase(output);\n\
    \n        // add endpoint\n        if (response[i]['_cls'] == 'IoC.NetworkIoc.NetworkVmIoc')\
    \ {\n            contextData.Endpoint = {\n                Hostname: response[i]['vm_name'],\n\
    \                IPAddress: response[i]['ip']\n            };\n        }\n\n \
    \       if (valueList.length > 0) {\n            contextData.Values = values;\n\
    \        }\n\n        outputs.push(output);\n        contexts.push(contextData);\n\
    \    }\n\n    if (outputs.length === 0) {\n        return 'No IOCs for this incident.';\n\
    \    }\n\n    var entry = buildEmptyEntryContext();\n    entry.HumanReadable =\
    \ tblToMd('GuardiCore IOCs', outputs);\n    entry.EntryContext['GuardiCore.IOCs']\
    \ = contexts;\n\n    return entry;\n}\n\nvar parseGetIncidents = function(command,\
    \ response) {\n    var internalCommand = 'guardicore-get-incident';\n    var outputs\
    \ = [];\n    var contexts = [];\n    for (var objects = dq(response, 'objects'),\
    \ i = 0; i < objects.length; i++) {\n        var output = mapObjFunction(outputsDictionary[internalCommand])(objects[i]);\n\
    \        output.Description = formatIncidentDescription(objects[i].description);\n\
    \        outputs.push(output);\n        contexts.push(convertKeysToPascalCase(output));\n\
    \    }\n\n    if (outputs.length === 0) {\n        return 'No matching incidents\
    \ were found.';\n    }\n\n    var entry = buildEmptyEntryContext();\n    entry.HumanReadable\
    \ = tblToMd('GuardiCore Incidents', outputs);\n    entry.EntryContext['GuardiCore.Incidents']\
    \ = contexts;\n\n    return entry;\n}\n\nvar parseGetIncidentEvents = function(command,\
    \ response) {\n    var outputs = [];\n    var contexts = [];\n    for (var events\
    \ = dq(response, 'events'), i = 0; i < events.length; i++) {\n        var output\
    \ = {'Class': events[i]._cls, 'Data': ''};\n        var context = {'Class' : events[i]._cls,\
    \ 'Data': events[i]};\n\n        var eventData = [];\n        for (var key in\
    \ events[i]) {\n            eventData.push(key + ': ' + JSON.stringify(events[i][key]));\n\
    \        }\n\n        if (eventData.length > 0) {\n            output.Data = eventData.join('<br>');\n\
    \        }\n\n        outputs.push(output);\n        contexts.push(context);\n\
    \    }\n\n    var entry = buildEmptyEntryContext();\n    entry.HumanReadable =\
    \ tblToMd('GuardiCore Incident Events', outputs);\n    entry.EntryContext['GuardiCore.IncidentEvents']\
    \ = contexts;\n\n    return entry;\n}\n\nvar buildClientStr = function(displayName,\
    \ ip, id) {\n    return '{0} - {1} - {2}'.format(displayName, ip, id);\n}\n\n\
    var parseDomainClients = function(clients) {\n    var contextData = [];\n    for\
    \ (var i = 0; i < clients.length; i++) {\n        contextData.push({\n       \
    \     displayName: clients[i].vm.display_name,\n            name: clients[i].vm.name,\n\
    \            ip: clients[i].ip,\n            id: clients[i].vm.id,\n         \
    \   domain: clients[i].vm.domain\n        });\n    }\n\n    return contextData;\n\
    }\n\nvar parseDomains = function(command, response) {\n    var outputs = [];\n\
    \    var domains = [];\n    var endpoints = [];\n    for (var i = 0; i < response.length;\
    \ i++) {\n        var output = mapObjFunction(outputsDictionary[command])(response[i]);\n\
    \        var contextData = {'Clients': parseDomainClients(response[i].clients)};\n\
    \        outputs.push(output);\n\n        var contextClientsData = [];\n     \
    \   for (var j = 0; j < contextData.Clients.length; j++) {\n            endpoints.push({\n\
    \                Hostname: contextData.Clients[j].name,\n                IP: contextData.Clients[j].ip,\n\
    \                Domain: contextData.Clients[j].domain\n            });\n\n  \
    \          contextClientsData.push({\n                DisplayName: contextData.Clients[j].displayName,\n\
    \                IP: contextData.Clients[j].ip,\n                ID: contextData.Clients[j].id,\n\
    \            });\n        }\n\n        domains.push({\n            Name: output.Domain,\n\
    \            Count: output.Count,\n            ClientsCount: output['Clients Count'],\n\
    \            Clients: contextClientsData\n        });\n    }\n\n    var domainType\
    \ = (command == 'guardicore-uncommon-domains') ? 'Uncommon' : 'Unresolved';\n\
    \    var tableTitle = 'GuardiCore {0} Domains'.format(domainType);\n    var entryContextDomainType\
    \ = 'GuardiCore.Domain.' + domainType;\n\n    var entry = buildEmptyEntryContext();\n\
    \    entry.HumanReadable = tblToMd(tableTitle, outputs);\n    entry.EntryContext\
    \ = {'GuardiCore.Endpoint.Suspicious': endpoints};\n    entry.EntryContext[entryContextDomainType]\
    \ = domains;\n\n    return entry;\n}\n\nvar parseMisconfigurations = function(command,\
    \ response) {\n    var outputs = [];\n    var contexts = [];\n    for (var i =\
    \ 0; i < response.length; i++) {\n        var output = mapObjFunction(outputsDictionary[command])(response[i]);\n\
    \        if (response[i].destination && response[i].destination[0] && response[i].destination[0].vm)\
    \ {\n            destination = response[i].destination[0].vm.display_name + '\
    \ - ' + response[i].destination[0].ip;\n        } else {\n            destination\
    \ = 'undefined';\n        }\n\n        output.Destination = destination;\n   \
    \     output.Port = response[i].port + ' - ' + response[i].port_name;\n\n    \
    \    var sources = [];\n        for (var j = 0; j < response[i].source.length;\
    \ j++) {\n            var currentSource = response[i].source[j];\n           \
    \ if (currentSource && currentSource.vm) {\n                var sourceStr = currentSource.vm.display_name\
    \ + ' (' + currentSource.ip + ') - ' + currentSource.count.toString();\n     \
    \       } else {\n                var sourceStr = 'undefined';\n            }\n\
    \n            sources.push(sourceStr);\n        }\n\n        output.Sources =\
    \ sources.join('<br>');\n        var context = convertKeysToPascalCase(output);\n\
    \        context.Sources = sources;\n        outputs.push(output);\n        contexts.push(context);\n\
    \    }\n\n    var entry = buildEmptyEntryContext();\n    entry.HumanReadable =\
    \ tblToMd('GuardiCore Misconfigurations', outputs);\n    entry.EntryContext =\
    \ {'GuardiCore.Misconfigurations': contexts};\n\n    return entry;\n}\n\nvar parseDnsRequests\
    \ = function(command, response) {\n    var outputs = [];\n    var contexts = [];\n\
    \    for (var objects = dq(response, 'objects'), i = 0; i < objects.length; i++)\
    \ {\n        var output = mapObjFunction(outputsDictionary[command])(objects[i]);\n\
    \        var context = convertKeysToPascalCase(output);\n\n        var answer\
    \ = {};\n        var answerDocumentsStr = '';\n        if (objects[i].answer_infos[0])\
    \ {\n            answer.ResponderIp = objects[i].answer_infos[0].responder_ip;\n\
    \            var answerDocuments = [];\n            objects[i].answer_infos[0].answer_documents.forEach(function(ans)\
    \ {\n                if (ans.answer_type) {\n                    answerDocuments.push({'AnswerType':\
    \ ans.answer_type, 'Hostname': ans.host_name});\n                    answerDocumentsStr\
    \ += 'Type: ' + ans.answer_type + ', Hostname: ' + ans.host_name + '<br>';\n \
    \               }\n            });\n\n            answer.AnswerDocuments = answerDocuments;\n\
    \        }\n\n        output.Answers = 'Responder IP: ' + answer.ResponderIp;\n\
    \        if (answerDocumentsStr.length > 0) {\n            output.Answers += '<br>Answers:<br>'\
    \ + answerDocumentsStr;\n        }\n        outputs.push(output)\n\n        context.Answer\
    \ = answer;\n        contexts.push(context);\n    }\n\n    var entry = buildEmptyEntryContext();\n\
    \    entry.HumanReadable = tblToMd('GuardiCore DNS Requests', outputs);\n    entry.EntryContext\
    \ = {'GuardiCore.DNSRequests': contexts};\n\n    return entry;\n}\n\nRELEVANT_SUMMARY_KEYS\
    \ = [\n    'blocked_connections_count',\n    'file_detected_incidents_count',\n\
    \    'file_detection_rules_count',\n    'file_quarantined_count',\n    'honeypot_incidents_count',\n\
    \    'network_rules_count',\n    'network_scan_incidents_count',\n    'total_incidents_count'\n\
    ]\nvar parseShowEndpoint = function(command, response) {\n    var output = mapObjFunction(outputsDictionary[command])(response);\n\
    \    var context = {\n        'Hostname': response.full_name,\n        'IP': (response.ip_addresses.length\
    \ > 1) ? response.ip_addresses : response.ip_addresses[0]\n    };\n\n    var entries\
    \ = [];\n    var endpointDetailsEntry = buildEmptyEntryContext();\n    endpointDetailsEntry.HumanReadable\
    \ = tblToMd('GuardiCore Details for Endpoint ' + response.full_name, output);\n\
    \    endpointDetailsEntry.EntryContext = {'GuardiCore.Endpoint': context};\n \
    \   entries.push(endpointDetailsEntry)\n\n    if (response.unhandled_recommendations\
    \ && (response.unhandled_recommendations.length > 0)) {\n        var recommendationsEntry\
    \ = buildEmptyEntryContext();\n        recommendationsEntry.HumanReadable = tblToMd('GuardiCore\
    \ Details for Endpoint ' + response.full_name, response.unhandled_recommendations);\n\
    \        entries.push(recommendationsEntry);\n    }\n\n    var summary = [];\n\
    \    for (var key in response.summary) {\n        if (RELEVANT_SUMMARY_KEYS.indexOf(key)\
    \ != -1) {\n            summary.push({'Key': key, 'Value': response.summary[key]});\n\
    \        }\n    }\n    if (summary.length > 0) {\n        var summaryEntry = buildEmptyEntryContext();\n\
    \        summaryEntry.HumanReadable = tblToMd('GuardiCore Summary for Endpoint\
    \ ' + response.full_name, summary);\n        entries.push(summaryEntry);\n   \
    \ }\n\n    return entries;\n}\n\nvar parseHostIds = function(response) {\n   \
    \ var hostIds = [];\n    for (var objects = dq(response, 'objects'), i = 0; i\
    \ < objects.length; i++) {\n        hostIds.push(objects[i]._id);\n    }\n\n \
    \   return hostIds;\n}\n\nvar parseIncidentPcap = function(response) {\n    return\
    \ {'honeypotId': response.honeypot_id, 'fileId': response.pcap.file_id};\n}\n\n\
    var parseIncidentAttachments = function(response) {\n    var attachmentsInfo =\
    \ {'honeypotId': response.honeypot_id, 'filesData': []};\n    for (var events\
    \ = dq(response, 'events'), i = 0; i < events.length; i++) {\n        if (events[i].file_id)\
    \ {\n            var fileData = {'fileId': events[i].file_id, 'path': events[i].path};\n\
    \            attachmentsInfo.filesData.push(fileData);\n        }\n    }\n\n \
    \   return attachmentsInfo;\n}\n\nvar parseSearchNetworkLog = function(command,\
    \ response) {\n    var outputs = [];\n    var contexts = [];\n    for (var objects\
    \ = dq(response, 'objects'), i = 0; i < objects.length; i++) {\n        var output\
    \ = mapObjFunction(outputsDictionary[command])(objects[i]);\n        outputs.push(output);\n\
    \        contexts.push(convertKeysToPascalCase(output));\n    }\n\n    var entry\
    \ = buildEmptyEntryContext();\n    entry.HumanReadable = tblToMd('GuardiCore Network\
    \ Log Results', outputs);\n    entry.EntryContext = {'GuardiCore.NetworkLog':\
    \ contexts};\n\n    return entry;\n}\n\nvar entriesFromResponse = function(command,\
    \ response, token) {\n    var entry;\n    switch (command) {\n        case 'guardicore-get-incidents':\n\
    \            entry = parseGetIncidents(command, response);\n            break;\n\
    \n        case 'guardicore-get-incident':\n            entry = parseGetIncident(command,\
    \ response);\n            break;\n\n        case 'guardicore-get-incident-iocs':\n\
    \            entry = parseGetIncidentIOCs(command, response);\n            break;\n\
    \n        case 'guardicore-get-incident-events':\n            entry = parseGetIncidentEvents(command,\
    \ response);\n            break;\n\n        case 'guardicore-get-incident-pcap':\n\
    \            var incidentId = response._id;\n            if (!response.pcap) {\n\
    \                return 'No PCAP was found for the given incident.';\n       \
    \     }\n\n            var pcapInfo = parseIncidentPcap(response);\n         \
    \   args.honeypotId = pcapInfo.honeypotId;\n            args.fileId = pcapInfo.fileId;\n\
    \n            var internalCommand = 'guardicore-get-incident-pcap';\n        \
    \    var pcapFile = sendRequest(\n                methodDictionary[internalCommand],\n\
    \                replaceInTemplatesAndRemove(urlDictionary[internalCommand], args),\n\
    \                token,\n                args,\n                true\n       \
    \     );\n\n            var fileName = 'incident_' + incidentId + '.pcap';\n \
    \           entry = {Type: 3, FileID: pcapFile, File: fileName, Contents: fileName};\n\
    \            break;\n\n        case 'guardicore-get-incident-attachments':\n \
    \           var incidentId = response._id;\n            var attachments = parseIncidentAttachments(response);\n\
    \            if (attachments.filesData.length === 0) {\n                return\
    \ 'No attachments were found for the given incident.';\n            }\n\n    \
    \        entry = [];\n            for (var i = 0; i < attachments.filesData.length;\
    \ i++) {\n                args.honeypotId = attachments.filesData[i].honeypotId;\n\
    \                args.fileId = attachments.filesData[i].fileId;\n            \
    \    var internalCommand = 'guardicore-get-incident-attachments';\n          \
    \      var attachment = sendRequest(\n                    methodDictionary[internalCommand],\n\
    \                    replaceInTemplatesAndRemove(urlDictionary[internalCommand],\
    \ args),\n                    token,\n                    args,\n            \
    \        true\n                );\n\n                var fileName = 'attachment_'\
    \ + incidentId + '_' + attachments.filesData[i].path;\n                entry.push({Type:\
    \ 3, FileID: attachment, File: fileName, Contents: fileName});\n            }\n\
    \            break;\n\n        case 'guardicore-uncommon-domains':\n        case\
    \ 'guardicore-unresolved-domains':\n            entry = parseDomains(command,\
    \ response);\n            break;\n\n        case 'guardicore-dns-requests':\n\
    \            entry = parseDnsRequests(command, response);\n            break;\n\
    \n        case 'guardicore-misconfigurations':\n            entry = parseMisconfigurations(command,\
    \ response);\n            break;\n\n        case 'guardicore-show-endpoint':\n\
    \            entry = parseShowEndpoint(command, response);\n            break;\n\
    \n        case 'guardicore-search-endpoint':\n            if (!args.ip_address\
    \ && !args.name) {\n                throw 'IP address or hostname must be provided.'\n\
    \            }\n\n            hostIds = parseHostIds(response);\n            if\
    \ (!hostIds || (hostIds.length === 0)) {\n                return 'Host was not\
    \ found.'\n            }\n\n            entry = [];\n            var internalCommand\
    \ = 'guardicore-show-endpoint';\n            for (var i = 0; i < hostIds.length;\
    \ i++) {\n                args.host_id = hostIds[i];\n                var result\
    \ = sendRequest(\n                    methodDictionary[internalCommand],\n   \
    \                 replaceInTemplatesAndRemove(urlDictionary[internalCommand],\
    \ args),\n                    token,\n                    args,\n            \
    \        false,\n                    true\n                );\n              \
    \  var currentEntry;\n                try {\n                    currentEntry\
    \ = entriesFromResponse(internalCommand, result, token);\n                } catch\
    \ (err) {\n                    currentEntry = 'Failed parsing host ID: ' + hostIds[i];\n\
    \                }\n\n                entry.push(currentEntry);\n            }\n\
    \n            return entry;\n\n        case 'guardicore-search-network-log':\n\
    \            entry = parseSearchNetworkLog(command, response);\n            break;\n\
    \n        default:\n            throw 'Unknown command';\n    }\n\n    if (command\
    \ != 'guardicore-get-incident-pcap') {\n        entry.Contents = response;\n \
    \       entry.ContentsFormat = formats.json;\n    }\n\n    return entry;\n}\n\n\
    var sendRequest = function(method, url, token, args, isRawOutput, shouldIgnoreUrlArgs)\
    \ {\n    var headers = {'Content-Type': ['application/json']};\n    if (token)\
    \ {\n        headers.Authorization = ['Bearer ' + token];\n    }\n\n    var body\
    \ = method !== 'GET' ? JSON.stringify(args) : '';\n    var shouldIgnoreArgs =\
    \ (shouldIgnoreUrlArgs !== undefined) && shouldIgnoreUrlArgs;\n    var urlExtra\
    \ = ((method === 'GET') && !shouldIgnoreArgs) ? encodeToURLQuery(args) : '';\n\
    \n    console.log('Sending request: ' + server + url + urlExtra);\n    var res\
    \ = http(\n        server + url + urlExtra,\n        {\n            Method: method,\n\
    \            Headers: headers,\n            Body: body,\n            SaveToFile:\
    \ isRawOutput ? true : false\n        },\n        params.insecure,\n        params.proxy\n\
    \    );\n\n    if (res.StatusCode < 200 || res.StatusCode >= 300) {\n        if\
    \ (token) {\n            sendRequest(methodDictionary.logout, urlDictionary.logout,\
    \ token);\n        }\n\n        throw 'Request to GuardiCore ' + url + ' failed,\
    \ request status code: ' + res.StatusCode + ' and Body: ' + res.Body + '.';\n\
    \    }\n\n    if (isRawOutput) {\n        return res.Path;\n    } else {\n   \
    \     return JSON.parse(res.Body);\n    }\n}\n\n// workaround - this parameter\
    \ should not be visible in the BYOI integration code\ndelete(args['raw-response']);\n\
    \nvar token = sendRequest(methodDictionary.login, urlDictionary.login, undefined,\
    \ {username: params.credentials.identifier, password: params.credentials.password}).access_token;\n\
    var commandUrlKey;\nswitch (command) {\n    case 'test-module':\n        sendRequest(methodDictionary.logout,\
    \ urlDictionary.logout, token);\n        return 'ok';\n\n    case 'guardicore-get-incident-pcap':\n\
    \    case 'guardicore-get-incident-attachments':\n        commandUrlKey = 'guardicore-get-incident';\n\
    \        break;\n\n    default:\n        commandUrlKey = command;\n        break\n\
    }\n\nvar result = sendRequest(\n    methodDictionary[command],\n    replaceInTemplatesAndRemove(urlDictionary[commandUrlKey],\
    \ args),\n    token,\n    args\n);\n\nvar entries = entriesFromResponse(command,\
    \ result, token);\nsendRequest(methodDictionary.logout, urlDictionary.logout,\
    \ token);\n\nreturn entries;\n\n"
  type: javascript
tests:
- No tests
toversion: 4.1.9
