beta: true
category: Forensics & Malware Analysis
commonfields:
  id: Trend Micro Deep Discovery Analyzer Beta
  version: -1
configuration:
- defaultvalue: ''
  display: DDA Server and Port  (e.g https://192.168.0.1:<port>)
  name: server
  required: true
  type: 0
- defaultvalue: ''
  display: Internal IP address (only needed if the server URL is external)
  name: ip_address
  required: false
  type: 0
- defaultvalue: ''
  display: API Key
  name: apiKey
  required: true
  type: 4
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: '1.5'
  display: Protocol Version
  name: protocol_version
  required: false
  type: 0
description: Deep Discovery Analyzer is a turnkey appliance that uses virtual images
  of endpoint configurations to analyze and detect targeted attacks.
detaileddescription: 'In order to allow the integration to work, the following configurations
  are required:

  1) Enter the DDA server and port into the server parameter in the integration

  2) Copy the IP address value from  Administration --> System Settings --> Network

  3) Paste this value into the ip_address parameter in the integration

  4) Copy the API key to the clipboard from Help --> About

  5) Paste this value into the apiKey parameter in the integration


  Note: This is a beta Integration, which lets you implement and test pre-release
  software. Since the integration is beta, it might contain bugs. Updates to the integration
  during the beta phase might include non-backward compatible features. We appreciate
  your feedback on the quality and usability of the integration to help us identify
  issues, fix them, and continually improve.'
display: Trend Micro Deep Discovery Analyzer (Beta)
image: data:image/png;base64,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
name: Trend Micro Deep Discovery Analyzer Beta
script:
  commands:
  - arguments:
    - description: The SHA1 of the sample to get
      name: sha1
      required: true
    - auto: PREDEFINED
      defaultValue: zip
      description: The export data type
      name: type
      predefined:
      - tgz
      - zip
    - auto: PREDEFINED
      defaultValue: '0'
      description: 0 (not encrypted) or 1 (Encrypted with password "virus")
      name: encrypted
      predefined:
      - '0'
      - '1'
    - description: A name for the retrieved archive
      name: archive_name
    description: Retrieves a sample
    name: trendmicro-dda-get-sample
    outputs:
    - contextPath: File.EntryID
      description: Demisto entry ID of archive
      type: string
    - contextPath: File.Size
      description: File size
      type: number
    - contextPath: File.SHA1
      description: File SHA1
      type: string
    - contextPath: File SHA256
      description: File SHA256
      type: string
    - contextPath: File.Name
      description: File name
      type: string
    - contextPath: File.SSDeep
      description: File SSDeep
      type: string
    - contextPath: File.Info
      description: File info
      type: string
    - contextPath: File.Type
      description: File type
      type: string
    - contextPath: File.MD5
      description: File MD5
      type: string
    - contextPath: File.Extension
      description: File extension
      type: string
  - arguments:
    - description: SHA1 of the submission
      name: sha1
    description: Retrieves IOC for a given submission, returns an error if submission
      has no IOC
    name: trendmicro-dda-get-openioc
  - arguments:
    - description: The SHA1 of the submission
      name: sha1
      required: true
    - auto: PREDEFINED
      defaultValue: '1'
      description: DDA severity score (greater or equal to) for which the submission
        will be considered malicious
      name: threshold
      predefined:
      - '0'
      - '1'
      - '2'
      - '3'
    - auto: PREDEFINED
      defaultValue: 'false'
      description: Return detailed report
      name: verbose
      predefined:
      - 'false'
      - 'true'
    description: Retrieves XML report of a given submission
    name: trendmicro-dda-get-report
    outputs:
    - contextPath: TrendMicroDDA.Submission.Status
      description: The status of the submission
      type: string
    - contextPath: TrendMicroDDA.Submission.SHA1
      description: SHA1 of the submission
      type: string
    - contextPath: TrendMicroDDA.Submission.RiskLevel
      description: The Risk Level of the submission
      type: number
    - contextPath: DBotScore.Score
      description: The actual score
      type: number
    - contextPath: DBotScore.Indicator
      description: The indicator we tested
      type: string
    - contextPath: DBotScore.Type
      description: The type of the indicator
      type: string
    - contextPath: DBotScore.Vendor
      description: Vendor used to calculate the score
      type: string
    - contextPath: InfoFile.MD5
      description: MD5 hash of the report file
      type: string
    - contextPath: InfoFile.SHA1
      description: SHA1 hash of the report file
      type: string
    - contextPath: InfoFile.SHA256
      description: SHA256 hash of the report  file
      type: string
    - contextPath: InfoFile.Name
      description: Report file name
      type: string
    - contextPath: InfoFile.Type
      description: Report file type e.g. "PE"
      type: string
    - contextPath: InfoFile.Size
      description: Report file size
      type: number
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision
      type: string
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason for the vendor to make the decision
      type: string
    - contextPath: IP.Address
      description: IPs relevant to the submission
      type: string
    - contextPath: Domain.Name
      description: Domains relevant to the submission
      type: string
    - contextPath: URL.Data
      description: URL data
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file
      type: string
    - contextPath: File.SHA1
      description: SHA1 hash of the file
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file
      type: string
    - contextPath: File.Size
      description: File size
      type: number
    - contextPath: File.Name
      description: File name
      type: string
    - contextPath: TrendMicroDDA.Submission.SHA256
      description: SHA256 of the submission
      type: string
    - contextPath: TrendMicroDDA.Submission.MD5
      description: MD5 of the submission
      type: string
    - contextPath: TrendMicroDDA.Submission.VirusDetected
      description: True if virus detected, else Flase
      type: boolean
    - contextPath: TrendMicroDDA.Submission.DownloadURL
      description: Download URL address of files
      type: string
  - arguments:
    - description: Interval start time, given in format ~~YYYY-MM-DD HH:MM:SS, e.g.
        2008-11-22 19:53:42
      name: interval_start
      required: true
    - description: Interval end time, given in format YYYY-MM-DD HH:MM:SS, e.g. 2008-11-22
        19:53:42
      name: interval_end
      required: true
    - auto: PREDEFINED
      defaultValue: '0'
      description: '0: Submission time, 1: Completion time'
      name: interval_type
      predefined:
      - '0'
      - '1'
    description: Retrieves a list of SHA1 of samples submitted within the given time
      interval
    name: trendmicro-dda-get-sample-list
  - arguments:
    - description: 'The SHA1 of the submissions. Example: "2492A18532745251FBC5DAF7160DAA49B90DBBE1,  52483514F07EB14570142F6927B77DEB7B4DA99F"'
      isArray: true
      name: sha1
      required: true
    description: Checks the analysis status of the submissions
    name: trendmicro-dda-check-status
    outputs:
    - contextPath: TrendMicroDDA.Submission.Status
      description: The status of the submission
      type: string
    - contextPath: TrendMicroDDA.Submission.SHA1
      description: The SHA1 of the submission
      type: string
  - arguments:
    - description: The URL to upload
      isArray: true
      name: url
      required: true
    description: 'Upload a URL to Trend Micro DDA '
    name: trendmicro-dda-upload-url
    outputs:
    - contextPath: TrendMicroDDA.Submission.SHA1
      description: The SHA1 of the submission
      type: string
    - contextPath: TrendMicroDDA.Submission.URL
      description: The submitted URL
      type: string
  - arguments:
    - description: EntryID of the file to upload
      isArray: true
      name: entryID
      required: true
    description: 'Upload a file to Trend Micro DDA '
    name: trendmicro-dda-upload-file
    outputs:
    - contextPath: TrendMicroDDA.Submission.SHA1
      description: The SHA1 of the submission
      type: string
  - arguments:
    - description: SHA1 of the submission
      name: sha1
      required: true
    - auto: PREDEFINED
      defaultValue: '1'
      description: DDA severity score (greater or equal to) for which the submission
        will be considered malicious
      name: threshold
      predefined:
      - '0'
      - '1'
      - '2'
      - '3'
    description: Retrieves a brief XML report of a given submission
    name: trendmicro-dda-get-brief-report
  dockerimage: demisto/python:2.7.17.5734
  runonce: false
  script: "import hashlib\nfrom datetime import datetime, timedelta\nimport uuid\n\
    import json\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom\
    \ requests.packages.urllib3.util.retry import Retry\nimport re\nimport platform\n\
    import os.path\nimport copy\nimport requests\nfrom collections import OrderedDict\n\
    \n# disable insecure warnings\nrequests.packages.urllib3.disable_warnings()\n\n\
    if not demisto.params().get(\"proxy\", True):\n    del os.environ[\"HTTP_PROXY\"\
    ]\n    del os.environ[\"HTTPS_PROXY\"]\n    del os.environ[\"http_proxy\"]\n \
    \   del os.environ[\"https_proxy\"]\n\n#HELPER FUNCTIONS#\n\ndef load_host_url():\n\
    \    ''' loads the host url from the configuration or strips the server url to\
    \ get valid host url '''\n    host = demisto.params()['ip_address']\n    if host:\n\
    \        #strip https://www. of the server address //disable-secrets-detection\n\
    \        url = re.compile(r\"https?://(www\\.)?\")\n        host = url.sub('',\
    \ demisto.params()['server']).strip().strip('/')\n        #strip :{port} of the\
    \ server address\n        host = host.split(':')[0]\n    return host\n\n\ndef\
    \ hash_file(filename):\n    '''Calculate the SHA1 of a file'''\n    h = hashlib.sha1()\n\
    \    with open(filename,'rb') as f:\n        chunk = 0\n        while chunk !=\
    \ '':\n            chunk = f.read(1024)\n            h.update(chunk)\n    return\
    \ h.hexdigest()\n\ndef hash_url(url):\n    '''Calculate the SHA1 of a URL'''\n\
    \    h = hashlib.sha1()\n    h.update(url)\n    return h.hexdigest()\n\ndef get_epoch_time():\n\
    \    '''Get the epoch time (for the X-DTAS-Time header value.'''\n    epoch_time\
    \ = str(int(time.time()))\n    return epoch_time\n\ndef get_epoch_from_datetime(dt):\n\
    \    '''Calculate epoch time from a datetime object'''\n    epoch_format = str(int(time.mktime(dt.timetuple())))\n\
    \    return epoch_format\n\ndef calculate_checksum(api_key, headers, body=''):\n\
    \    ''' Generates a Checksum for the api call '''\n    temp = api_key\n    if\
    \ 'X-DTAS-ChecksumCalculatingOrder' in headers:\n        x_dtas_checksum_calculating_order_list\
    \ = headers['X-DTAS-ChecksumCalculatingOrder'].split(\",\")\n        for key in\
    \ x_dtas_checksum_calculating_order_list:\n            temp += headers[key]\n\
    \    else:\n        for key, value in headers.iteritems():\n            if ('X-DTAS-'\
    \ in key and 'X-DTAS-Checksum' not in key and 'X-DTAS-ChecksumCalculatingOrder'\
    \ not in key):\n                temp += value\n\n    temp += body\n    return\
    \ hashlib.sha1(temp)\n\ndef http_request(uri, method, headers, body={}, params={},\
    \ files={}):\n    ''' Makes an API call to the server URL with the supplied uri,\
    \ method, headers, body and params '''\n    url = '%s/%s' % (SERVER_URL, uri)\n\
    \    if method not in ['put', 'post']:\n        body=json.dumps(body)\n    res\
    \ = requests.request(\n        method,\n        url,\n        headers=headers,\n\
    \        data=body,\n        verify=USE_SSL,\n        params=params,\n       \
    \ files=files\n    )\n\n    if (res.status_code != 102 and (res.status_code <\
    \ 200 or res.status_code >= 300)):\n        raise Exception('Got status code '\
    \ + str(res.status_code) + ' with body ' + res.content + ' with headers ' + str(res.headers))\n\
    \    return res\n\ndef file_uploaded_to_incident(file, file_sha1):\n    ''' Converts\
    \ an uploaded file to a Demisto incident '''\n    incident = {}\n    incident[\"\
    name\"] = \"Incident: %s \" % (file_sha1)\n    incident[\"occurred\"] = CURRENT_TIME\n\
    \    incident[\"rawJSON\"] = \"TODO\"\n\n    labels = []\n    incident[\"labels\"\
    ] = labels\n    return incident\n\ndef binary_to_booleanic_string(binary):\n \
    \   if (binary == '0'):\n        return 'False'\n    else:\n        return 'True'\n\
    \ndef binary_to_boolean(binary):\n    if (binary == '0'):\n        return False\n\
    \    else:\n        return True\n\n#GLOBAL VARIABLES#\nAPI_KEY = demisto.params()['apiKey']\n\
    PROTOCOL_VERSION = demisto.params()['protocol_version']\nSERVER_URL = demisto.params()['server'][:-1]\
    \ if demisto.params()['server'].endswith('/') else demisto.params()['server']\n\
    USE_SSL = not demisto.params().get('insecure', True)\nUUID = str(uuid.uuid4())\n\
    HOST = load_host_url()\n\nDEFAULT_HEADERS = {\n    'Host' : HOST,\n    'X-DTAS-ProtocolVersion'\
    \ : PROTOCOL_VERSION,\n    'X-DTAS-ClientUUID': UUID,\n    'X-DTAS-Time': get_epoch_time(),\n\
    \    'X-DTAS-Challenge': str(uuid.uuid4()),\n    'X-DTAS-ProductName': 'TDA',\n\
    \    'X-DTAS-ClientHostname': platform.node(),\n    'X-DTAS-SourceID': '1',\n\
    \    'X-DTAS-SourceName': 'DemistoIntegration',\n}\n\n#for fetch incident\nCURRENT_TIME\
    \ = datetime.utcnow()\n\n#COMMAND FUNCTIONS#\n\ndef register():\n    headers_register\
    \ = copy.deepcopy(DEFAULT_HEADERS)\n    tmp_checksum = calculate_checksum(API_KEY,\
    \ headers_register)\n    headers_register['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\
    \    res = http_request(\n        'web_service/sample_upload/register',\n    \
    \    'get',\n        headers_register\n    )\n\ndef unregister():\n    headers_unregister\
    \ = copy.deepcopy(DEFAULT_HEADERS)\n    tmp_checksum = calculate_checksum(API_KEY,\
    \ headers_unregister)\n    headers_unregister['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\
    \    res = http_request(\n        'web_service/sample_upload/unregister',\n  \
    \      'get',\n        headers_unregister\n    )\n\ndef test():\n    headers_test\
    \ = copy.deepcopy(DEFAULT_HEADERS)\n    tmp_checksum = calculate_checksum(API_KEY,\
    \ headers_test)\n    headers_test['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\
    \    res = http_request(\n        'web_service/sample_upload/test_connection',\n\
    \        'get',\n        headers_test\n    )\n    demisto.results('ok')\n\ndef\
    \ prettify_simple_upload_sample_file(sha1):\n    pretty_sample = {\n        'SHA1':\
    \ sha1.upper()\n    }\n    return pretty_sample\n\ndef simple_upload_sample_file(sample_file):\n\
    \    '''Upload a file to Deep Discovery Analyzer for analysis'''\n    with open(demisto.getFilePath(sample_file)['path'],\
    \ 'rb') as f:\n        headers_simple_upload_sample_file = {\n            'X-DTAS-ProtocolVersion':\
    \ PROTOCOL_VERSION,\n            'X-DTAS-ClientUUID': UUID,\n            'X-DTAS-SourceID':\
    \ '1',\n            'X-DTAS-SourceName': 'DemistoIntegration',\n            'X-DTAS-SHA1':\
    \ hash_file(demisto.getFilePath(sample_file)['path']),\n            'X-DTAS-Time':\
    \ get_epoch_time(),\n            'X-DTAS-SampleType': '0', #0 for file, 1 for\
    \ URL\n            'X-DTAS-Challenge': str(uuid.uuid4()),\n            'X-DTAS-ChecksumCalculatingOrder':\
    \ \"X-DTAS-ProtocolVersion,X-DTAS-ClientUUID,X-DTAS-SourceID,X-DTAS-SourceName,X-DTAS-SHA1,X-DTAS-Time,X-DTAS-SampleType,X-DTAS-Challenge\"\
    ,\n        }\n        tmp_checksum = calculate_checksum(API_KEY, headers_simple_upload_sample_file)\n\
    \        headers_simple_upload_sample_file['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\
    \        cmd_url = 'web_service/sample_upload/simple_upload_sample'\n        res\
    \ = http_request(\n            cmd_url,\n            'post',\n            headers_simple_upload_sample_file,\n\
    \            files = {'uploadsample': f}\n        )\n    pretty_res = prettify_simple_upload_sample_file(headers_simple_upload_sample_file['X-DTAS-SHA1'])\n\
    \    return res, pretty_res\n\ndef simple_upload_sample_file_command():\n    sample_file\
    \ = demisto.args().get('entryID')\n    res, pretty_res = simple_upload_sample_file(sample_file)\n\
    \n    demisto.results({\n        'Type': entryTypes['note'],\n        'ContentsFormat':\
    \ formats['text'],\n        'Contents': 'File was uploaded to Trend Micro DDA\
    \ successfully',\n        'EntryContext': {\n              'TrendMicroDDA.Submission(val.SHA1\
    \ && val.SHA1==obj.SHA1)': pretty_res\n        }\n    })\n\n\ndef prettify_simple_upload_sample_url(url,\
    \ sha1):\n    pretty_sample = {\n        'SHA1': sha1.upper(),\n        'URL':\
    \ url\n    }\n    return pretty_sample\n\ndef simple_upload_sample_url(sample_url):\n\
    \    '''Upload a URL to Analyzer for analysis'''\n    headers_simple_upload_sample_url\
    \ = {\n        'X-DTAS-ProtocolVersion': PROTOCOL_VERSION,\n        'X-DTAS-ClientUUID':\
    \ UUID,\n        'X-DTAS-SourceID': '1',\n        'X-DTAS-SourceName': 'DemistoIntegration',\n\
    \        'X-DTAS-SHA1': hash_url(sample_url),\n        'X-DTAS-Time': get_epoch_time(),\n\
    \        'X-DTAS-SampleType': '1', #0 for file, 1 for URL\n        'X-DTAS-Challenge':\
    \ str(uuid.uuid4()),\n        'X-DTAS-ChecksumCalculatingOrder': \"X-DTAS-ProtocolVersion,X-DTAS-ClientUUID,X-DTAS-SourceID,X-DTAS-SourceName,X-DTAS-SHA1,X-DTAS-Time,X-DTAS-SampleType,X-DTAS-Challenge\"\
    ,\n    }\n    tmp_checksum = calculate_checksum(API_KEY, headers_simple_upload_sample_url)\n\
    \    headers_simple_upload_sample_url['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\
    \n    cmd_url = 'web_service/sample_upload/simple_upload_sample'\n    res = http_request(\n\
    \        cmd_url,\n        'post',\n        headers_simple_upload_sample_url,\n\
    \        files = {'uploadsample' : sample_url}\n    )\n\n    pretty_res = prettify_simple_upload_sample_url(sample_url,\
    \ headers_simple_upload_sample_url['X-DTAS-SHA1'])\n    return res, pretty_res\n\
    \ndef simple_upload_sample_url_command():\n    sample_url = demisto.args().get('url')\n\
    \    res, pretty_res = simple_upload_sample_url(sample_url)\n\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'Contents': str(res.headers),\n\
    \        'ContentsFormat': formats['text'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': tableToMarkdown('URL was uploaded\
    \ to Trend Micro DDA successfully', pretty_res),\n        'EntryContext': {\n\
    \              'TrendMicroDDA.Submission(val.SHA1 && val.SHA1==obj.SHA1)': pretty_res\n\
    \        }\n    })\n\ndef get_sample(sha1, archive_type, archive_encrypted, archive_name):\n\
    \    '''Issue a request to retrieve an archive of the sample given its SHA1 hash'''\n\
    \    if not (re.match(r'\\b[0-9a-fA-F]{40}\\b', sha1)):\n        return_error('Provided\
    \ SHA1: {} is unvalid.'.format(sha1))\n\n    headers_get_sample = copy.deepcopy(DEFAULT_HEADERS)\n\
    \    headers_get_sample['X-DTAS-SHA1'] = sha1 # SHA1 of the file/URL to download\n\
    \    headers_get_sample['X-DTAS-ArchiveType'] = archive_type\n    headers_get_sample['X-DTAS-ArchiveEncrypted']\
    \ = archive_encrypted\n\n    tmp_checksum = calculate_checksum(API_KEY, headers_get_sample)\n\
    \    headers_get_sample['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\n    cmd_url\
    \ = 'web_service/sample_upload/get_sample'\n    res = http_request(\n        cmd_url,\n\
    \        'get',\n        headers_get_sample\n    )\n    file = fileResult(archive_name,\
    \ res.content)\n\n    return res, file\n\ndef get_sample_command():\n    sha1\
    \ = demisto.args()['sha1']\n    archive_type = demisto.args()['type']\n    archive_encrypted\
    \ = demisto.args()['encrypted']\n    archive_name = demisto.args()['archive_name']\
    \ if 'archive_name' in demisto.args() else sha1\n    archive_name += '.{}'.format(archive_type)\n\
    \    res, file = get_sample(sha1, archive_type, archive_encrypted, archive_name)\n\
    \n    return demisto.results(file)\n\ndef get_sample_list(interval_start, interval_end,\
    \ interval_type):\n\n    try:\n        interval_start_dt = datetime.strptime(interval_start,\
    \ \"%Y-%m-%d %H:%M:%S\")\n        interval_end_dt = datetime.strptime(interval_end,\
    \ \"%Y-%m-%d %H:%M:%S\")\n    except:\n        return_error('Given interval times\
    \ are not in the required format, which is: YYYY-MM-DD HH:MM:SS, e.g. 2008-11-22\
    \ 19:53:42')\n\n    headers_get_sample_list = copy.deepcopy(DEFAULT_HEADERS)\n\
    \    headers_get_sample_list['X-DTAS-IntervalStartingPoint'] = get_epoch_from_datetime(interval_start_dt)\n\
    \    headers_get_sample_list['X-DTAS-IntervalEndPoint'] = get_epoch_from_datetime(interval_end_dt)\n\
    \    headers_get_sample_list['X-DTAS-IntervalType'] = interval_type\n\n    tmp_checksum\
    \ = calculate_checksum(API_KEY, headers_get_sample_list)\n    headers_get_sample_list['X-DTAS-Checksum']\
    \ = tmp_checksum.hexdigest()\n\n    cmd_url = 'web_service/sample_upload/get_sample_list'\n\
    \    res = http_request(\n        cmd_url,\n        'get',\n        headers_get_sample_list\n\
    \    )\n\n    return res #returns a list of SHA1 of the samples\n\ndef get_sample_list_command():\n\
    \    '''Issue a request to get a semi-colon separated values list of submissions\
    \ within the given time interval'''\n    interval_start = demisto.args()['interval_start']\n\
    \    interval_end = demisto.args()['interval_end']\n    interval_type = demisto.args()['interval_type']\n\
    \    result = get_sample_list(interval_start, interval_end, interval_type)\n \
    \   if result.text:\n        sha1_list = result.text.split(';')\n        hr =\
    \ '### Trend Micro DDA submissions SHA1\\n'\n        for sha1 in sha1_list:\n\
    \            hr += '- {}\\n'.format(sha1)\n\n        demisto.results({\n     \
    \       'Type': entryTypes['note'],\n            'ContentsFormat': formats['text'],\n\
    \            'Contents': result.text,\n            'ReadableContentsFormat': formats['markdown'],\n\
    \            'HumanReadable': hr\n        })\n    else:\n        demisto.results('No\
    \ results found.')\n\ndef build_report(res, threshold, status, verbose):\n   \
    \ report_json = json.loads(xml2json(res.text))\n    reports = report_json['REPORTS']\n\
    \    #true if list, false if dict\n    reports_type_is_list = isinstance(reports['FILE_ANALYZE_REPORT'],\
    \ list)\n    hr = {}\n\n    if isinstance(reports, dict):\n        image_type_dict\
    \ = reports.get('IMAGE_TYPE', {})\n        if isinstance(image_type_dict, dict):\n\
    \            image_type_dict = image_type_dict.get('TYPE', {})\n\n           \
    \ if isinstance(image_type_dict, dict):\n                image_type = image_type_dict.get('#text',\
    \ 'Unknown')\n            else:\n                image_type = 'Unknown'\n\n  \
    \      else:\n            image_type = 'Unknown'\n    else:\n        image_type\
    \ = 'Unknown'\n\n    hr_headers = {\n        'Risk Level': reports['OVERALL_RISK_LEVEL'],\n\
    \        'Image Type': image_type,\n        'Sum of Files Analyzed': (len(reports['FILE_ANALYZE_REPORT']))\
    \ if reports_type_is_list  else '1',\n    }\n\n    context = {}\n    dbot_score\
    \ = 0\n    context['DBotScore'] = {\n        'Vendor': 'Trend Micro DDA',\n  \
    \      'Score': dbot_score, #check that------------------ TODO --------------------\n\
    \        'Type': 'hash',\n        'Indicator': reports['FILE_ANALYZE_REPORT']['FileSHA1']\
    \ if not reports_type_is_list else reports['FILE_ANALYZE_REPORT'][0]['FileSHA1']\n\
    \    }\n    #if type is list, the submission was divided to sub-files and the\
    \ first file_analyze_report is of the main submission\n    #context['DBotScore.Indicator']\
    \ = reports['FILE_ANALYZE_REPORT']['FileSHA1'] if not reports_type_is_list else\
    \ reports['FILE_ANALYZE_REPORT'][0]['FileSHA1']\n\n    if not reports_type_is_list:\
    \ #if the submission doesn't have sub-files\n        file_analyze_report = reports['FILE_ANALYZE_REPORT']\n\
    \        hr['File Name'] = file_analyze_report['OrigFileName']\n        hr['Malware\
    \ Source IP'] = file_analyze_report['MalwareSourceIP']\n        hr['Malware Source\
    \ Host'] = file_analyze_report['MalwareSourceHost']\n        hr['Total Dropped\
    \ Files'] = file_analyze_report['DroppedFiles']['@Total']\n        hr['Deny List']\
    \ = binary_to_booleanic_string(file_analyze_report['IsDenylisted'])\n        hr['White\
    \ List'] = binary_to_booleanic_string(file_analyze_report['IsWhitelisted'])\n\n\
    \        if '#text' in file_analyze_report['VirusName']: #the submission has a\
    \ detection\n            hr['Detection Name'] = file_analyze_report['VirusName']['#text']\n\
    \        #set the filename\n        filename = hr['Detection Name'] if ('Detection\
    \ Name' in hr) else file_analyze_report['FileSHA1']\n        if '.' not in filename:\n\
    \            filename = filename + \".txt\"\n\n        #add data regarding the\
    \ submission to the context\n        context['TrendMicroDDA.Submission(val.SHA1\
    \ && val.SHA1==obj.SHA1)'] = {\n            'Status': status,\n            'RiskLevel':\
    \ reports['OVERALL_RISK_LEVEL'],\n            'SHA1': file_analyze_report['FileSHA1'],\n\
    \            'SHA256': file_analyze_report['FileSHA256'],\n            'MD5':\
    \ file_analyze_report['FileMD5'],\n            'VirusDetected' : binary_to_boolean(file_analyze_report['VirusDetected']),\n\
    \        }\n\n        if file_analyze_report['TrueFileType'] == 'URL':\n     \
    \       #add the URL address\n            context[outputPaths['url']] = {\n  \
    \              'Data': file_analyze_report['OrigFileName']\n            }\n  \
    \      else:\n            context[outputPaths['file']] = {\n                'MD5':\
    \ file_analyze_report['FileMD5'],\n                'SHA1': file_analyze_report['FileSHA1'],\n\
    \                'SHA256': file_analyze_report['FileSHA256'],\n              \
    \  'Size': file_analyze_report['FileSize'],\n                'Name': file_analyze_report['OrigFileName'],\n\
    \            }\n\n        #add data regarding the submission to the context if\
    \ file is malicious\n        if (reports['OVERALL_RISK_LEVEL'] >= threshold):\n\
    \            dbot_score = 3\n            if file_analyze_report['TrueFileType']\
    \ == 'URL':\n                context[outputPaths['url']].update({\n          \
    \          'Malicious': {\n                        'Vendor': 'Trend Micro DDA',\n\
    \                        'Description': 'RiskLevel: ' + reports['OVERALL_RISK_LEVEL']\n\
    \                    }\n                })\n            else:\n              \
    \  context[outputPaths['file']].update({\n                    'Malicious' : {\n\
    \                        'Vendor': 'Trend Micro DDA',\n                      \
    \  'Description': 'RiskLevel: ' + reports['OVERALL_RISK_LEVEL']\n            \
    \        }\n                })\n\n        #extracting IP and Domains from the\
    \ report\n        if file_analyze_report['MalwareSourceIP']:\n            context['IP.Address(val.Address\
    \ && val.Address == obj.Address)'] = file_analyze_report['MalwareSourceIP']\n\
    \        if file_analyze_report['MalwareSourceHost']:\n            context['Domain.Name(val.Name\
    \ && val.Name == obj.Name)'] = file_analyze_report['MalwareSourceHost']\n    \
    \    if verbose == 'true':\n            dropped_files = file_analyze_report['DroppedFiles']\n\
    \            if 'FileItem' in dropped_files:\n                if 'DownloadURL'\
    \ in dropped_files['FileItem']:\n                    context['URL.Data(val.Data\
    \ && val.Data == obj.Data)'] = dropped_files['FileItem']['DownloadURL']\n    \
    \                hr['Download URL'] = dropped_files['FileItem']['DownloadURL']\n\
    \                    context['TrendMicroDDA.Submission'].update({\n          \
    \              'DownloadURL': dropped_files['FileItem']['DownloadURL']\n     \
    \               })\n\n    else: #if the submission have sub-files\n\n        main_file_analyze_report\
    \ = reports['FILE_ANALYZE_REPORT'][0]\n\n        #add data to the war room\n \
    \       hr = copy.deepcopy(reports['FILE_ANALYZE_REPORT'])\n        for item in\
    \ hr:\n            item['File Name'] = item['OrigFileName']\n            item['Detection\
    \ Name'] = item['VirusName']['#text'] if '#text' in item['VirusName'] else None\n\
    \            item['Malware Source IP'] = item['MalwareSourceIP']\n           \
    \ item['Malware Source Host'] = item['MalwareSourceHost']\n            if verbose\
    \ == 'true':\n                item['Download URL'] = item['DroppedFiles'].get('FileItem')\n\
    \            item['Deny List'] = binary_to_booleanic_string(item['IsDenylisted'])\
    \ if item['IsDenylisted'] else None\n            item['White List'] = binary_to_booleanic_string(item['IsWhitelisted'])\
    \ if item['IsWhitelisted'] else None\n\n        #set the filename\n        filename\
    \ = main_file_analyze_report['OrigFileName']\n        if '.' not in filename:\n\
    \            filename = filename + \".txt\"\n\n        if verbose == 'true':\n\
    \            hr['Download URL'] = download_url_list\n            context['URL.Data(val.Data\
    \ && val.Data == obj.Data)'] = download_url_list\n            context['TrendMicroDDA.Submission'].update({\n\
    \                'DownloadURL': download_url_list\n            })\n\n        #add\
    \ data regarding the submission to the context\n        file_analyzed_list = []\n\
    \        for file_analyzed in reports['FILE_ANALYZE_REPORT'][1:]: #iterate over\
    \ all the subfiles excluding the main file\n            file_analyzed_dict = {\n\
    \                'SHA1': file_analyzed['FileSHA1'],\n                'SHA256':\
    \ file_analyzed['FileSHA256'],\n                'MD5': file_analyzed['FileMD5'],\n\
    \                'Name': file_analyzed['VirusName']['#text'] if '#text' in file_analyzed['VirusName']\
    \ else '',\n                'VirusDetected': binary_to_boolean(file_analyzed['VirusDetected']),\n\
    \            }\n            if file_analyzed['TrueFileType'] == 'URL':\n     \
    \           #add the URL address\n                context[outputPaths['url']]\
    \ = {\n                    'Data': file_analyzed['OrigFileName']\n           \
    \     }\n            else:\n                context[outputPaths['file']] = {\n\
    \                    'MD5': file_analyzed['FileMD5'],\n                    'SHA1':\
    \ file_analyzed['FileSHA1'],\n                    'SHA256': file_analyzed['FileSHA256'],\n\
    \                    'Size': file_analyzed['FileSize'],\n                    'Name':\
    \ file_analyzed['VirusName']['#text'] if '#text' in file_analyzed['VirusName']\
    \ else '',\n                    ##add score of some sort from virusdetected? ask\
    \ michal.------------------ TODO --------------------\n                }\n   \
    \         file_analyzed_list.append(file_analyzed_dict)\n\n        context['TrendMicroDDA.Submission(val.SHA1\
    \ && val.SHA1==obj.SHA1)'] = {\n            'Status': status,\n            'RiskLevel':\
    \ reports['OVERALL_RISK_LEVEL'],\n            'SHA1': main_file_analyze_report['FileSHA1'],\n\
    \            'SHA256': main_file_analyze_report['FileSHA256'],\n            'MD5':\
    \ main_file_analyze_report['FileMD5'],\n            'VirusDetected': binary_to_boolean(main_file_analyze_report['VirusDetected']),\n\
    \            'FileAnalyzed': file_analyzed_list,\n        }\n        if main_file_analyze_report['TrueFileType']\
    \ == 'URL':\n            context['URL(val.Data && val.Data==obj.Data)'] = {\n\
    \                'Data': main_file_analyze_report['OrigFileName'],\n         \
    \   }\n        else:\n            context['File(val.SHA1 && val.SHA1==obj.SHA1)']\
    \ = {\n                'MD5': main_file_analyze_report['FileMD5'],\n         \
    \       'SHA1': main_file_analyze_report['FileSHA1'],\n                'SHA256':\
    \ main_file_analyze_report['FileSHA256'],\n                'Size': main_file_analyze_report['FileSize'],\n\
    \                'Name': main_file_analyze_report['VirusName']['#text'] if '#text'\
    \ in file_analyzed['VirusName'] else '',\n            }\n        #add data regarding\
    \ the submission to the context if it is malicious\n        if (reports['OVERALL_RISK_LEVEL']\
    \ >= threshold):\n            context['DBotScore.Score'] = 3\n            if (main_file_analyze_report['TrueFileType']\
    \ == 'URL'):\n                context[outputPaths['url']] = {\n              \
    \      'Malicious' : {\n                        'Vendor' : 'Trend Micro DDA',\n\
    \                        'Description' : 'RiskLevel: ' + reports['OVERALL_RISK_LEVEL']\n\
    \                        }\n                }\n            else:\n           \
    \     context[outputPaths['file']] = {\n                    'Malicious' : {\n\
    \                        'Vendor' : 'Trend Micro DDA',\n                     \
    \   'Description' : 'RiskLevel: ' + reports['OVERALL_RISK_LEVEL']\n          \
    \              }\n                }\n\n        #extracting IP and Domains from\
    \ the report\n        if main_file_analyze_report['MalwareSourceIP']:\n      \
    \      context['IP.Address(val.Address && val.Address == obj.Address)'] = main_file_analyze_report['MalwareSourceIP']\n\
    \        if main_file_analyze_report['MalwareSourceHost']:\n            context['Domain.Name(val.Name\
    \ && val.Name == obj.Name)'] = main_file_analyze_report['MalwareSourceHost']\n\
    \n    return context, hr, hr_headers, filename\n\ndef get_report(sha1):\n    '''Issue\
    \ a request to retrieve XML report for a given SHA1'''\n    if not (re.match(r'\\\
    b[0-9a-fA-F]{40}\\b', sha1)):\n        return_error('Provided SHA1: {} is unvalid.'.format(sha1))\n\
    \n    headers_get_report = copy.deepcopy(DEFAULT_HEADERS)\n    headers_get_report['X-DTAS-SHA1']\
    \ = sha1 # SHA1 of the file/URL to download\n    headers_get_report['X-DTAS-Time']\
    \ = get_epoch_time()\n\n    tmp_checksum = calculate_checksum(API_KEY, headers_get_report)\n\
    \    headers_get_report['X-DTAS-Checksum'] = tmp_checksum.hexdigest()\n\n    cmd_url\
    \ = 'web_service/sample_upload/get_report'\n    res = http_request(\n        cmd_url,\n\
    \        'get',\n        headers_get_report\n    )\n\n    return res\n\ndef get_report_command():\n\
    \    sha1 = demisto.args()['sha1']\n    threshold = demisto.args()['threshold']\n\
    \    verbose = demisto.args()['verbose']\n    res = get_report(sha1)\n\n    if\
    \ res.status_code == 102:\n        ec = {\n            'Status': 'Analyzing',\n\
    \            'SHA1': sha1\n        }\n        demisto.results({\n            'Type':\
    \ entryTypes['note'],\n            'ContentsFormat': formats['text'],\n      \
    \      'Content': {\"value\": res},\n            'HumanReadable': 'Submission\
    \ analyzation was not finished yet.',\n            'EntryContext': {\n       \
    \         'TrendMicroDDA.Submission(val.SHA1 && val.SHA1==obj.SHA1)': ec\n   \
    \         }\n        })\n    else:\n        status = 'Completed'\n\n        context,\
    \ hr, hr_headers, filename = build_report(res, threshold, status, verbose)\n \
    \       markdown_table_headers = ['File Name', 'Detection Name', 'Malware Source\
    \ IP', 'Malware Source Host']\n        if verbose == 'true':\n            markdown_table_headers.append('Download\
    \ URL')\n        markdown_table_headers.extend(('Deny List', 'White List'))\n\n\
    \        tmp_file = fileResult(filename, res.text)\n\n        temp = demisto.uniqueFile()\n\
    \        demisto.results({ #add context and the Report File to the war room\n\
    \            'Type': entryTypes['file'],\n            'FileID': tmp_file.get('FileID'),\n\
    \            'Contents': '',\n            'ContentsFormat': formats['text'],\n\
    \            'File': tmp_file.get('File'),\n            'EntryContext': context,\n\
    \        })\n        demisto.results({ #add table to the war room\n          \
    \  'Type': entryTypes['note'],\n            'Contents': res.text,\n          \
    \  'ContentsFormat': formats['text'],\n            'HumanReadableFormat': formats['markdown'],\n\
    \            'HumanReadable':\n                '## Submission Report from TrendMicroDDA\\\
    n' +\n                '### Risk Level: {}, Sum of Files Analyzed: {}, Image Type:\
    \ {}\\n'.format(hr_headers['Risk Level'], hr_headers['Sum of Files Analyzed'],hr_headers['Image\
    \ Type']) +\n                tableToMarkdown('Report Summary', hr, headers=markdown_table_headers),\n\
    \        })\n\ndef build_brief_report(res, sha1, threshold):\n    report_json\
    \ = json.loads(xml2json(res.text))\n    brief_report_json = report_json['REPORT']['BRIEF_REPORT']\n\
    \    hr = {\n        'SHA1': sha1,\n        'Risk Level': brief_report_json['RiskLevel'],\n\
    \        'Status': brief_report_json['STATUS'],\n    }\n    return hr\n\n\ndef\
    \ get_brief_report(sha1):\n    if not (re.match(r'\\b[0-9a-fA-F]{40}\\b', sha1)):\n\
    \        return_error('Provided SHA1 is unvalid.')\n\n    headers_get_brief_report\
    \ = {\n        'Content-Type': 'text/plain',\n        'X-DTAS-ProtocolVersion':\
    \ PROTOCOL_VERSION,\n        'X-DTAS-ClientUUID': UUID,\n        'X-DTAS-Time':\
    \ get_epoch_time(),\n        'X-DTAS-Challenge': str(uuid.uuid4()),\n        'X-DTAS-ChecksumCalculatingOrder':\
    \ \"X-DTAS-ProtocolVersion,X-DTAS-ClientUUID,X-DTAS-Time,X-DTAS-Challenge\",\n\
    \    }\n    sha1_list = argToList(sha1)\n    data = ';'.join(sha1_list)\n    tmp_checksum\
    \ = calculate_checksum(API_KEY, headers_get_brief_report, data)\n    headers_get_brief_report['X-DTAS-Checksum']\
    \ = tmp_checksum.hexdigest()\n\n    cmd_url = 'web_service/sample_upload/get_brief_report'\n\
    \    res = http_request(\n        cmd_url,\n        'put',\n        headers=headers_get_brief_report,\n\
    \        body=data\n    )\n    return res\n\ndef get_brief_report_command():\n\
    \    '''Issue a request to retrieve the brief XML report for a given SHA1'''\n\
    \    sha1 = demisto.args()['sha1']\n    threshold = demisto.args()['threshold']\n\
    \    res = get_brief_report(sha1)\n\n    hr = build_brief_report(res, sha1, threshold)\n\
    \    demisto.results({\n        'Type': entryTypes['note'],\n        'ContentsFormat':\
    \ formats['text'],\n        'Contents': res.text,\n        'HumanReadableFormat':\
    \ formats['markdown'],\n        'HumanReadable': tableToMarkdown('Sample Brief\
    \ Report from TrendMicroDDA', hr, removeNull=True),\n        #'EntryContext':\
    \ {\n        #    'TrendMicroDDA.Submission(val.SHA1 && val.SHA1==obj.SHA1)':\
    \ context\n        #}\n    })\n\ndef check_status(sha1_list):\n    for sha1 in\
    \ sha1_list:\n        if not (re.match(r'\\b[0-9a-fA-F]{40}\\b', sha1)):\n   \
    \         return_error('Provided SHA1: {} is unvalid.'.format(sha1))\n    manyRes\
    \ = []\n    manyEC = []\n\n    for sha1 in sha1_list:\n        res = get_report(sha1)\n\
    \        manyRes.append(res.text)\n        if res.status_code == 102:\n      \
    \      manyEC.append({\n                'Status': 'Analyzing',\n             \
    \   'SHA1': sha1\n            })\n        else:\n            manyEC.append({\n\
    \                'Status': 'Completed',\n                'SHA1': sha1\n      \
    \      })\n\n    return manyRes, manyEC\n\ndef check_status_command():\n    sha1_list\
    \ = argToList(demisto.args()['sha1'])\n    manyRes, manyEC, = check_status(sha1_list)\n\
    \n    demisto.results({\n        'Type': entryTypes['note'],\n        'Contents':\
    \ manyRes,\n        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': tableToMarkdown('Status of the\
    \ submissions in TrendMicroDDA', manyEC),\n        'EntryContext': {\n       \
    \       'TrendMicroDDA.Submission(val.SHA1 && val.SHA1==obj.SHA1)': manyEC\n \
    \       }\n    })\n\n# EXECUTION\nLOG('command is %s' % (demisto.command(), ))\n\
    \ntry:\n    register()\n    if demisto.command() == 'test-module':\n        test()\n\
    \n    elif demisto.command() == 'fetch-incidents':\n        fetch_incidents()\n\
    \n    elif demisto.command() == 'trendmicro-dda-upload-file':\n        simple_upload_sample_file_command()\n\
    \n    elif demisto.command() == 'trendmicro-dda-upload-url':\n        simple_upload_sample_url_command()\n\
    \n    elif demisto.command() == 'trendmicro-dda-get-sample':\n        get_sample_command()\n\
    \n    elif demisto.command() == 'trendmicro-dda-check-status':\n        check_status_command()\n\
    \n    elif demisto.command() == 'trendmicro-dda-get-brief-report':\n        get_brief_report_command()\n\
    \n    elif demisto.command() == 'trendmicro-dda-get-report':##add !file !url command?\
    \ ask anar\n        get_report_command()\n\n    elif demisto.command() == 'trendmicro-dda-get-openioc':\n\
    \        get_openioc_report_command()\n\n    elif demisto.command() == 'trendmicro-dda-get-sample-list':\n\
    \        get_sample_list_command()\n\nexcept Exception as e:\n    LOG(str(e))\n\
    \    LOG.print_log()\n    raise\n\nfinally:\n    unregister()"
  subtype: python2
  type: python
tests:
- No Test - run "Test Playbook TrendMicroDDA" manually
toversion: 4.1.9
