args:
- default: true
  description: Active Directory Distinguished Name for the desired user
  name: dn
- description: Name of the desired user
  name: name
- description: Include these AD attributes of the resulting objects in addition to
    the default ones
  name: attributes
- description: Search user by this custom field type
  name: customFieldType
- description: Search user by this custom field data (relevant only if `customFieldType`
    is provided)
  name: customFieldData
- description: The columns headers to show by order
  name: headers
- auto: PREDEFINED
  description: ' Enter ''true'' to allow nested groups search as well'
  name: nestedSearch
  predefined:
  - 'true'
  - 'false'
- description: samAccountName of the desire user
  name: username
- description: Maximum number of objects to return (default is 20)
  name: limit
- description: mail attribute of desire user
  name: email
- auto: PREDEFINED
  description: Include verbose translation for UserAccountControl flags
  name: userAccountControlOut
  predefined:
  - 'true'
  - 'false'
- description: Select instance name
  name: using
comment: 'Use Active Directory to retrieve detailed information about a user account.
  The user can be specified by name, email or as an Active Directory Distinguished
  Name (DN).

  If no filter is provided, the result will show all users.'
commonfields:
  id: ADGetUser
  version: -1
dependson:
  must:
  - activedir|||ad-search
enabled: true
name: ADGetUser
outputs:
- contextPath: Account
  description: Active Directory Account
- contextPath: Account.Type
  description: Type of the Account entity
  type: string
- contextPath: Account.ID
  description: The unique Account DN (Distinguished Name)
  type: string
- contextPath: Account.Username
  description: The Account username
  type: string
- contextPath: Account.Email
  description: The email object associated with the Account
- contextPath: Account.Groups
  description: The groups the Account is part of
  type: string
- contextPath: Account.DisplayName
  description: The Account display name
  type: string
- contextPath: Account.Manager
  description: The Account's manager
  type: string
- contextPath: Account.Email.Address
  description: The email address object associated with the Account
  type: string
- contextPath: DBotScore.Indicator
  description: The indicator value
  type: string
- contextPath: DBotScore.Type
  description: The indicator's type
  type: string
- contextPath: DBotScore.Vendor
  description: The indicator's vendor
  type: string
- contextPath: DBotScore.Score
  description: The indicator's score
  type: number
script: "import re\n\nUserAccountControlFlags = {\n    'SCRIPT': 0x0001,\n    'ACCOUNTDISABLE':\
  \ 0x0002,\n    'HOMEDIR_REQUIRED': 0x0008,\n    'LOCKOUT': 0x0010,\n    'PASSWD_NOTREQD':\
  \ 0x0020,\n    'PASSWD_CANT_CHANGE': 0x0040,\n    'ENCRYPTED_TEXT_PWD_ALLOWED':\
  \ 0x0080,\n    'TEMP_DUPLICATE_ACCOUNT': 0x0100,\n    'NORMAL_ACCOUNT': 0x0200,\n\
  \    'INTERDOMAIN_TRUST_ACCOUNT': 0x0800,\n    'WORKSTATION_TRUST_ACCOUNT': 0x1000,\n\
  \    'SERVER_TRUST_ACCOUNT': 0x2000,\n    'DONT_EXPIRE_PASSWORD': 0x10000,\n   \
  \ 'MNS_LOGON_ACCOUNT': 0x20000,\n    'SMARTCARD_REQUIRED': 0x40000,\n    'TRUSTED_FOR_DELEGATION':\
  \ 0x80000,\n    'NOT_DELEGATED': 0x100000,\n    'USE_DES_KEY_ONLY': 0x200000,\n\
  \    'DONT_REQ_PREAUTH': 0x400000,\n    'PASSWORD_EXPIRED': 0x800000,\n    'TRUSTED_TO_AUTH_FOR_DELEGATION':\
  \ 0x1000000,\n    'PARTIAL_SECRETS_ACCOUNT': 0x04000000\n}\n\nlimit = 20\nif demisto.get(demisto.args(),\
  \ 'limit'):\n    limit = demisto.args()['limit']\n\n\ndef escapeSpecialCharacters(s):\n\
  \    return re.sub(r'([\\()])', lambda r : '\\\\' + r.group(), s)\n\n\ndef createAccountEntities(t,attrs):\n\
  \    accounts = []\n    for l in t:\n        account = {}\n        account['Type']\
  \ = 'AD'\n        account['ID'] = demisto.get(l,'dn')\n        account['Email']\
  \ = {'Address':demisto.get(l,'mail')}\n        account['Username'] = demisto.get(l,'samAccountName')\n\
  \        account['DisplayName'] = demisto.get(l,'displayName')\n        account['Manager']\
  \ = demisto.get(l,'manager')\n        account['Groups'] = demisto.get(l,'memberOf').split('<br>')\
  \ if demisto.get(l,'memberOf') else ''\n        for attr in set(argToList(attrs))\
  \ - set(['dn','mail','name','displayName','memberOf']):\n            account[attr.title()]\
  \ = demisto.get(l,attr)\n        accounts.append(account)\n\n    return accounts\n\
  \n\ndef prettifyDateTimeADFields(resAD):\n    try:\n        for m in resAD:\n  \
  \          if isError(m):\n                continue\n            m['ContentsFormat']\
  \ = formats['table']\n            for f in [ 'lastlogon' , 'lastlogoff' , 'pwdLastSet'\
  \ , 'badPasswordTime' , 'lastLogonTimestamp' ]:\n                if f not in m['Contents'][0]:\n\
  \                    continue\n                if  m['Contents'][0][f] == \"0\"\
  :\n                    m['Contents'][0][f] = \"N/A\"\n                else:\n  \
  \                  try:\n                        m['Contents'][0][f] = FormatADTimestamp(\
  \ m['Contents'][0][f] )\n                    except:\n                        pass\
  \ # Could not prettify timestamp - return as is\n            for f in [ 'whenChanged'\
  \ , 'whenCreated' ]:\n                try:\n                    m['Contents'][0][f]\
  \ = PrettifyCompactedTimestamp( m['Contents'][0][f] )\n                except:\n\
  \                    pass # Could not prettify timestamp - return as is\n      \
  \  return resAD\n    except Exception as ex:\n        return { 'Type' : entryTypes['error'],\
  \ 'ContentsFormat' : formats['text'], 'Contents' : 'Error occurred while parsing\
  \ output from ad command. Exception info: ' + str(ex) + '\\nInvalid output:\\n'\
  \ + str( resAD ) }\n\ndef translateUserAccountControl(resAD, userAccountControlOut):\n\
  \    try:\n        for m in resAD:\n            if isError(m) or not demisto.get(m,\
  \ 'Contents') or not isinstance(m['Contents'], list):\n                continue\n\
  \            if 'UserAccountControl' not in m['Contents'][0] or m['Contents'][0]['UserAccountControl']\
  \ == \"\":\n                continue\n            if userAccountControlOut:\n  \
  \              accountControlFlags = []\n                for flag, mask in UserAccountControlFlags.iteritems():\n\
  \                    if int(m['Contents'][0]['UserAccountControl'],10) & mask !=\
  \ 0:\n                        accountControlFlags.append(flag)\n               \
  \ m['Contents'][0]['UserAccountControl'] = ', '.join(accountControlFlags)\n    \
  \        else:\n                m['Contents'][0]['ACCOUNTDISABLE'] = int(m['Contents'][0]['UserAccountControl'],10)\
  \ & 2 != 0\n        return resAD\n    except Exception as ex:\n        return {\
  \ 'Type' : entryTypes['error'], 'ContentsFormat' : formats['text'], 'Contents' :\
  \ 'Error occurred while parsing output from ad command. Exception info: ' + str(ex)\
  \ + '\\nInvalid output:\\n' + str( resAD ) }\n\ndef listAll(attrs, using, userAccountControlOut):\n\
  \    args = {}\n    args['filter'] = \"(objectClass=User)\"\n    args['attributes']\
  \ = attrs\n    args['size-limit'] = limit\n    args['using-brand'] = 'activedir'\n\
  \    if using:\n        args['using'] = using\n    resAD = getADSearchResp(args)\n\
  \    if isError(resAD[0]) or isinstance(demisto.get(resAD[0],'Contents'), str) or\
  \ isinstance(demisto.get(resAD[0],'Contents'), unicode):\n        return resAD\n\
  \    else:\n        resAD = prettifyDateTimeADFields(resAD)\n        resAD = translateUserAccountControl(resAD,\
  \ userAccountControlOut)\n        return resAD\n\ndef getGroups(userDN):\n    queryValue\
  \ = escapeSpecialCharacters(userDN)\n    group_attrs = 'name'\n    filterstr = r\"\
  (&(member{0}=\".format(':1.2.840.113556.1.4.1941:') + queryValue + \")(objectcategory=group))\"\
  \n    args = {\n        'filter' : filterstr,\n        'attributes' : group_attrs,\n\
  \        'size-limit' : limit,\n        'using-brand' : 'activedir'\n    }\n   \
  \ group_resp = getADSearchResp(args)\n    if isError(group_resp[0]):\n        return\
  \ group_resp\n    try:\n        data = demisto.get(group_resp[0],'Contents')\n \
  \       data = data if isinstance(data, list) else [data]\n        memberOf = \"\
  ,\".join([demisto.get(k,'dn') for k in data])\n        return memberOf\n    except\
  \ Exception as e:\n        return \"\"\n\n\ndef queryBuilder(queryType,queryValue,attrs,nested,using,\
  \ userAccountControlOut):\n    args = {}\n    args['size-limit'] = limit\n    args['using-brand']\
  \ = 'activedir'\n    if using:\n        args['using'] = using\n    filterstr = r\"\
  (&(objectClass=User)({0}={1}))\".format(queryType, queryValue)\n    args['filter']\
  \ = filterstr\n    args['attributes'] = attrs\n    resp = getADSearchResp(args)\n\
  \    if isError(resp) or isinstance(demisto.get(resp[0],'Contents'), str) or isinstance(demisto.get(resp[0],'Contents'),\
  \ unicode):\n        return resp\n    if nested:\n        for index,user in enumerate(resp[0]['Contents']):\n\
  \            memberOf = getGroups(user[\"dn\"])\n            if memberOf:\n    \
  \            resp[0]['Contents'][index]['memberOf'] = memberOf\n\n    resp = prettifyDateTimeADFields(resp)\n\
  \    resp = translateUserAccountControl(resp, userAccountControlOut)\n    return\
  \ resp\n\ndef getADSearchResp(args):\n    try:\n        return demisto.executeCommand(\
  \ 'ad-search', args )\n    except Exception as e:\n        if 'Unsupported Command'\
  \ in str(e):\n            return_error('No instances of \"Active Directory Query\"\
  \ are configured.\\nIf you are trying to run \"ADGetUser\" with \"Active Directory\
  \ Query V2\", please use the aquivilant command \"ad-get-user\" instead.')\n   \
  \         raise e\n\nattrs = 'dn,name,displayName,memberOf,mail,samAccountName,manager,UserAccountControl,ACCOUNTDISABLE,provider'\n\
  queryValue, queryType = \"\",\"\"\nheaders = argToList(demisto.get(demisto.args(),\
  \ 'headers'))\nuserAccountControlOut = False\n\nnestedSearch = True if demisto.get(demisto.args(),\
  \ 'nestedSearch') == 'true' else False\n\nif demisto.get(demisto.args(), 'attributes'):\n\
  \    attrs += \",\" + demisto.args()['attributes']\nif demisto.get(demisto.args(),\
  \ 'userAccountControlOut'):\n    userAccountControlOut = demisto.args()['userAccountControlOut']\
  \ == 'true'\n\nif demisto.get(demisto.args(), 'dn'):\n    queryValue = demisto.args()['dn']\n\
  \    queryType = \"distinguishedName\"\nelif demisto.get(demisto.args(), 'name'):\n\
  \    queryValue = demisto.args()['name']\n    queryType = \"name\"\nelif demisto.get(demisto.args(),\
  \ 'username'):\n    queryValue = demisto.args()['username']\n    queryType = \"\
  samAccountName\"\nelif demisto.get(demisto.args(), 'email'):\n    queryValue = demisto.args()['email']\n\
  \    queryType = \"mail\"\nelif demisto.get(demisto.args(), 'customFieldType'):\n\
  \    if not demisto.get(demisto.args(), 'customFieldData'):\n        demisto.results({\
  \ 'Type' : entryTypes['error'], 'ContentsFormat' : formats['text'], '' : 'To do\
  \ custom search, both \"customFieldType\" and \"customFieldData\" should be provided'\
  \ })\n    else:\n        queryValue = demisto.args()['customFieldData']\n      \
  \  queryType = demisto.args()['customFieldType']\nresp = None\nif queryValue and\
  \ queryType:\n    resp = queryBuilder(queryType,escapeSpecialCharacters(queryValue),attrs,nestedSearch,demisto.get(demisto.args(),'using'),\
  \ userAccountControlOut)\nelse:\n    resp = listAll(attrs, demisto.get(demisto.args(),'using'),\
  \ userAccountControlOut)\n\nif isError(resp):\n    demisto.results(resp)\nelse:\n\
  \    found = False\n    for response in resp:\n        context = {}\n        data\
  \ = demisto.get(response,'Contents')\n        if isinstance(data, str) or isinstance(data,\
  \ unicode) :\n            if data == 'No results':\n                continue\n \
  \           found = True\n            md = data\n        else:\n            data\
  \ = data if isinstance(data, list) else [data]\n            found = True\n     \
  \       md = tableToMarkdown(\"Active Directory User\", data, headers)\n       \
  \     context['Account(val.Email && val.Email === obj.Email || val.ID && val.ID\
  \ === obj.ID || val.Username && val.Username === obj.Username)'] = createAccountEntities(data,attrs)\n\
  \            if len(data) > 0 and demisto.get(data[0], 'name'):\n              \
  \  context['DBotScore'] = {'Indicator': data[0]['samAccountName'], 'Type': 'username',\
  \ 'Vendor': 'AD', 'Score': 0, 'isTypedIndicator': True}\n        demisto.results({'Type'\
  \ : entryTypes['note'],\n                        'Contents': data,\n           \
  \             'ContentsFormat' : formats['json'],\n                        'HumanReadable':\
  \ md,\n                        'ReadableContentsFormat' : formats['markdown'],\n\
  \                        'EntryContext' : context})\n    if not found:\n       \
  \ demisto.results({'Type' : entryTypes['note'],\n                        'Contents':\
  \ resp,\n                        'ContentsFormat' : formats['json'],\n         \
  \               'HumanReadable': 'No results found for user',\n                \
  \        'ReadableContentsFormat' : formats['markdown'],\n                     \
  \   'EntryContext' : {}})"
scripttarget: 0
subtype: python2
tags:
- active directory
- enhancement
- username
toversion: 4.1.9
type: python
