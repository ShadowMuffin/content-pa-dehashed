category: IT Services
commonfields:
  id: VMware
  version: -1
configuration:
- defaultvalue: ''
  display: Server URL (i.e. 192.168.0.1:30022)
  name: url
  required: true
  type: 0
- defaultvalue: ''
  display: Credentials
  name: credentials
  required: true
  type: 9
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: VMware vCenter server is a centralized management application that lets
  you manage virtual machines and ESXi hosts centrally.
display: VMware
image: data:image/png;base64,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
name: VMware
script:
  commands:
  - arguments: []
    description: Returns all virtual machines on a system.
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ''
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ''
    name: vmware-get-vms
    outputs:
    - contextPath: VMWare.Name
      description: VM name
    - contextPath: VMWare.Template
      description: true if template, else false
    - contextPath: VMWare.Path
      description: Path to VM
    - contextPath: VMWare.Guest
      description: Guest full name
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.IP
      description: VM IP address
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
    - contextPath: VMWare.HostName
      description: Host name of VM
    - contextPath: VMWare.MACAddress
      description: MAC Address of VM
  - arguments:
    - description: VM UUID of virtual machine to be powered on.
      name: vm-uuid
      required: true
    description: Powers on a powered-off or suspended virtual machine.
    execution: true
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ''
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ''
    name: vmware-poweron
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
  - arguments:
    - description: VM UUID of virtual machine to be powered on.
      name: vm-uuid
      required: true
    description: Powers off a powered-on or suspended virtual machine.
    execution: true
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ''
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ''
    name: vmware-poweroff
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
  - arguments:
    - description: VM UUID of virtual machine to reboot.
      name: vm-uuid
      required: true
    description: Reboots a powered-on virtual machine.
    execution: true
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ''
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ''
    name: vmware-hard-reboot
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
  - arguments:
    - description: VM UUID of virtual machine to be suspended.
      name: vm-uuid
      required: true
    description: Suspends a powered-on virtual machine.
    execution: true
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ''
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
      related: ''
    name: vmware-suspend
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.State
      description: VM State (i.e. poweredOn, poweredOff, suspended, HardRebooted)
  - arguments:
    - description: VM UUID of virtual machine to reboot.
      name: vm-uuid
      required: true
    description: Issues a command to the guest operating system asking it to perform
      a reboot.
    name: vmware-soft-reboot
  - arguments:
    - description: VM UUID of virtual machine to take snapshot of.
      name: vm-uuid
      required: true
    - description: Snapshot name
      name: name
    - description: Snapshot description
      name: description
    - auto: PREDEFINED
      defaultValue: 'True'
      description: Snapshot the virtual machine's memory
      name: memory
      predefined:
      - 'true'
      - 'false'
    - auto: PREDEFINED
      defaultValue: 'False'
      description: Quiesce guest file system (needs VMWare Tools installed).
      name: quiesce
      predefined:
      - 'true'
      - 'false'
    description: Creates VM snapshot
    name: vmware-create-snapshot
  - arguments:
    - description: Snapshot name to revert to
      name: snapshot-name
      required: true
    - description: VM UUID of virtual machine to revert snapshot.
      name: vm-uuid
      required: true
    description: Reverts VM to snapshot
    execution: true
    important:
    - contextPath: VMWare.UUID
      description: VM instance UUID
      related: ''
    - contextPath: VMWare.Snapshot
      description: Name of the snapshot reverted to.
      related: ''
    name: vmware-revert-snapshot
    outputs:
    - contextPath: VMWare.UUID
      description: VM instance UUID
    - contextPath: VMWare.Snapshot
      description: Name of the snapshot reverted to.
  - arguments:
    - description: VM UUID of virtual machine to get events of.
      name: vm-uuid
      required: true
    - defaultValue: VmGuestRebootEvent,VmGuestShutdownEvent,VmPoweredOnEvent,VmPoweredOffEvent,VmSuspendedEvent
      description: Type of events to get, given in CSV (i.e.  VmGuestRebootEvent,VmGuestShutdownEvent).
      name: event-type
    description: Gets events of VM
    name: vmware-get-events
  dockerimage: demisto/vmware:1.0-alpine
  script: "from pyVim.connect import SmartConnect, Disconnect\nfrom pyVim.task import\
    \ WaitForTask\nfrom pyVmomi import vim\nfrom pyVmomi import vmodl\nimport ssl\n\
    import os\nimport sys\nfrom datetime import datetime\n\nFULL_URL=demisto.params()['url'].split(':')\n\
    URL=FULL_URL[0]\nUSERNAME=demisto.params()['credentials']['identifier']\nPASSWORD=demisto.params()['credentials']['password']\n\
    PORT=str(FULL_URL[1])\n\ndef login():\n    s = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n\
    \    s.verify_mode = ssl.CERT_NONE\n    try:\n        si = SmartConnect(host=URL,\n\
    \                          user=USERNAME,\n                          pwd=PASSWORD,\n\
    \                          port=PORT)\n    except:\n        si = SmartConnect(host=URL,\n\
    \                          user=USERNAME,\n                          pwd=PASSWORD,\n\
    \                          port=PORT,\n                          sslContext=s)\n\
    \    return si\n\ndef logout(si):\n    Disconnect(si)\n\ndef get_vm(uuid):\n \
    \   vm = si.content.searchIndex.FindByUuid(None, uuid, True, True)\n    if vm\
    \ is None:\n        raise SystemExit('Unable to locate Virtual Machine.')\n  \
    \  return vm\n\ndef get_vms():\n    data = []\n    content = si.RetrieveContent()\n\
    \    container = content.rootFolder\n    viewType = [vim.VirtualMachine]\n   \
    \ recursive = True\n    containerView = content.viewManager.CreateContainerView(container,\
    \ viewType, recursive)\n    children = containerView.view\n    for child in children:\n\
    \        summary = child.summary\n        for dev in child.config.hardware.device:\n\
    \            if isinstance(dev, vim.vm.device.VirtualEthernetCard):\n        \
    \        macAddress = dev.macAddress\n                break\n        data.append\
    \ ({\n            'Name': summary.config.name,\n            'Template': summary.config.template,\n\
    \            'Path': summary.config.vmPathName,\n            'Guest': summary.config.guestFullName,\n\
    \            'UUID': summary.config.instanceUuid,\n            'IP': summary.guest.ipAddress\
    \ if summary.guest.ipAddress else ' ',\n            'State': summary.runtime.powerState,\n\
    \            'HostName': summary.guest.hostName if summary.guest.hostName else\
    \ ' ',\n            'MACAddress': macAddress if macAddress else ' '\n        })\n\
    \    ec = {\n        'VMWare(val.UUID && val.UUID === obj.UUID)': data\n    }\n\
    \    return create_entry(data, ec)\n\ndef create_entry(data, ec):\n    return\
    \ {\n        'ContentsFormat': formats['json'],\n        'Type': entryTypes['note'],\n\
    \        'Contents': data,\n        'ReadableContentsFormat': formats['markdown'],\n\
    \        'HumanReadable': tableToMarkdown('Virtual Machines', data) if data else\
    \ 'No result were found',\n        'EntryContext': ec\n    }\n\ndef power_on(uuid):\n\
    \    vm = get_vm(uuid)\n\n    if vm.runtime.powerState == 'poweredOn':\n     \
    \   raise SystemExit('Virtual Machine is already powered on.')\n    task = vm.PowerOn()\n\
    \    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:\n\
    \        time.sleep(1)\n    if task.info.state == 'success':\n        ec = {\n\
    \            'VMWare(val.UUID && val.UUID === obj.UUID)': {\n                'UUID':\
    \ uuid,\n                'State': 'poweredOn'\n            }\n        }\n    \
    \    return {\n            'ContentsFormat': formats['json'],\n            'Type':\
    \ entryTypes['note'],\n            'Contents': ec,\n            'ReadableContentsFormat':\
    \ formats['text'],\n            'HumanReadable': 'Virtual Machine was powered\
    \ on successfully.',\n            'EntryContext': ec\n        }\n    elif task.info.state\
    \ == 'error':\n        raise SystemExit('Error occured while trying to power on\
    \ Virtual Machine.')\n\ndef power_off(uuid):\n    vm = get_vm(uuid)\n    if vm.runtime.powerState\
    \ == 'poweredOff':\n        raise SystemExit('Virtual Machine is already powered\
    \ off.')\n    task = vm.PowerOff()\n    while task.info.state not in [vim.TaskInfo.State.success,\
    \ vim.TaskInfo.State.error]:\n        time.sleep(1)\n    if task.info.state ==\
    \ 'success':\n        ec = {\n            'VMWare(val.UUID && val.UUID === obj.UUID)':\
    \ {\n                'UUID': uuid,\n                'State': 'poweredOff'\n  \
    \          }\n        }\n        return {\n            'ContentsFormat': formats['json'],\n\
    \            'Type': entryTypes['note'],\n            'Contents': ec,\n      \
    \      'ReadableContentsFormat': formats['text'],\n            'HumanReadable':\
    \ 'Virtual Machine was powered off successfully.',\n            'EntryContext':\
    \ ec\n        }\n    elif task.info.state == 'error':\n        raise SystemExit('Error\
    \ occured while trying to power off Virtual Machine.')\n\ndef suspend(uuid):\n\
    \    vm = get_vm(uuid)\n    if vm.runtime.powerState == 'suspended':\n       \
    \  raise SystemExit('Virtual Machine is already suspended.')\n    task = vm.Suspend()\n\
    \    while task.info.state not in [vim.TaskInfo.State.success, vim.TaskInfo.State.error]:\n\
    \        time.sleep(1)\n    if task.info.state == 'success':\n        ec = {\n\
    \            'VMWare(val.UUID && val.UUID === obj.UUID)': {\n                'UUID':\
    \ uuid,\n                'State': 'suspended'\n            }\n        }\n    \
    \    return {\n            'ContentsFormat': formats['json'],\n            'Type':\
    \ entryTypes['note'],\n            'Contents': ec,\n            'ReadableContentsFormat':\
    \ formats['text'],\n            'HumanReadable': 'Virtual Machine was suspended\
    \ successfully.',\n            'EntryContext': ec\n        }\n    elif task.info.state\
    \ == 'error':\n        raise SystemExit('Error occured while trying to power on\
    \ Virtual Machine.')\n\ndef hard_reboot(uuid):\n    vm = get_vm(uuid)\n    task\
    \ = vm.ResetVM_Task()\n    wait_for_tasks(si, [task])\n    if task.info.state\
    \ == 'success':\n        ec = {\n            'VMWare(val.UUID && val.UUID ===\
    \ obj.UUID)': {\n                'UUID': uuid,\n                'State': 'HardRebooted'\n\
    \            }\n        }\n        return {\n            'ContentsFormat': formats['json'],\n\
    \            'Type': entryTypes['note'],\n            'Contents': ec,\n      \
    \      'ReadableContentsFormat': formats['text'],\n            'HumanReadable':\
    \ 'Virtual Machine was rebooted successfully.',\n            'EntryContext': ec\n\
    \        }\n    elif task.info.state == 'error':\n        raise SystemExit('Error\
    \ occured while trying to reboot Virtual Machine.')\n\ndef wait_for_tasks(si,\
    \ tasks):\n    propertyCollector = si.content.propertyCollector\n    taskList\
    \ = [str(task) for task in tasks]\n    objSpecs = [vmodl.query.PropertyCollector.ObjectSpec(obj=task)\
    \ for task in tasks]\n    propertySpec = vmodl.query.PropertyCollector.PropertySpec(type=vim.Task,\
    \ pathSet=[], all=True)\n    filterSpec = vmodl.query.PropertyCollector.FilterSpec()\n\
    \    filterSpec.objectSet = objSpecs\n    filterSpec.propSet = [propertySpec]\n\
    \    pcfilter = propertyCollector.CreateFilter(filterSpec, True)\n    try:\n \
    \       version, state = None, None\n        while len(taskList):\n          \
    \  update = propertyCollector.WaitForUpdates(version)\n            for filter_set\
    \ in update.filterSet:\n                for obj_set in filter_set.objectSet:\n\
    \                    task = obj_set.obj\n                    for change in obj_set.changeSet:\n\
    \                        if change.name == 'info':\n                         \
    \   state = change.val.state\n                        elif change.name == 'info.state':\n\
    \                            state = change.val\n                        else:\n\
    \                            continue\n                        if not str(task)\
    \ in taskList:\n                            continue\n                       \
    \ if state == vim.TaskInfo.State.success:\n                            taskList.remove(str(task))\n\
    \                        elif state == vim.TaskInfo.State.error:\n           \
    \                 raise task.info.error\n            version = update.version\n\
    \    finally:\n        if pcfilter:\n            pcfilter.Destroy()\n\ndef soft_reboot(uuid):\n\
    \    vm = get_vm(uuid)\n    vm.RebootGuest()\n    return 'A request to reboot\
    \ the guest has been sent.'\n\ndef create_snapshot(args):\n    uuid = args['vm-uuid']\n\
    \    vm = get_vm(uuid)\n    d = str(datetime.now())\n    if args['memory'] ==\
    \ 'True':\n        mem = True\n    else:\n        mem = False\n    if args['quiesce']\
    \ == 'True':\n        qui = True\n    else:\n        qui = False\n    name = args.get('name',\
    \ uuid + ' snapshot ' + d)\n    desc = args.get('description', 'Snapshot of VM\
    \ UUID ' + uuid + ' taken on ' + d)\n    WaitForTask(vm.CreateSnapshot(name=name,\
    \ description=desc, memory=mem, quiesce=qui))\n    return 'Snapshot ' + name +\
    \ ' completed.'\n\ndef revert_snapshot(name, uuid):\n    vm = get_vm(uuid)\n \
    \   snapObj = get_snapshots(vm.snapshot.rootSnapshotList, name)\n    if len(snapObj)\
    \ == 1:\n        snapObj = snapObj[0].snapshot\n        WaitForTask(snapObj.RevertToSnapshot_Task())\n\
    \        ec = {\n            'VMWare(val.UUID && val.UUID === obj.UUID)': {\n\
    \                'UUID': uuid,\n                'Snapshot': 'Reverted to ' + name\n\
    \            }\n        }\n        return {\n            'ContentsFormat': formats['json'],\n\
    \            'Type': entryTypes['note'],\n            'Contents': ec,\n      \
    \      'ReadableContentsFormat': formats['text'],\n            'HumanReadable':\
    \ 'Reverted to snapshot ' + name + ' successfully.',\n            'EntryContext':\
    \ ec\n        }\n    else:\n        return 'No snapshots found with name: ' +\
    \ name + ' on VM: ' + uuid\n\ndef get_snapshots(snapshots, snapname):\n    snapObj\
    \ = []\n    for snapshot in snapshots:\n        if snapshot.name == snapname:\n\
    \            snapObj.append(snapshot)\n        else:\n            snapObj = snapObj\
    \ + get_snapshots(snapshot.childSnapshotList, snapname)\n    return snapObj\n\n\
    def get_events(uuid, event_type):\n    vm = get_vm(uuid)\n    hr = []\n    content\
    \ = si.RetrieveServiceContent()\n    eventManager = content.eventManager\n   \
    \ filter = vim.event.EventFilterSpec.ByEntity(entity=vm, recursion=\"self\")\n\
    \    filterSpec = vim.event.EventFilterSpec()\n    ids = event_type.split(',')\n\
    \    filterSpec.eventTypeId = ids\n    filterSpec.entity = filter\n    eventRes\
    \ = eventManager.QueryEvents(filterSpec)\n    for e in eventRes:\n        hr.append({\n\
    \            'Event': e.fullFormattedMessage,\n            'Created Time': e.createdTime.strftime(\"\
    %Y-%m-%d %H:%M:%S\")\n        })\n    return {\n        'ContentsFormat': formats['json'],\n\
    \        'Type': entryTypes['note'],\n        'Contents': hr,\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': tableToMarkdown('VM ' + vm.summary.config.name\
    \ + ' Events', hr) if hr else 'No result were found'\n    }\n\nfrom cStringIO\
    \ import StringIO\nsout = sys.stdout\nsys.stdout = StringIO()\nres = []\nsi =\
    \ None\ntry:\n    si = login()\n\n    if demisto.command() == 'test-module':\n\
    \        result = 'ok'\n    if demisto.command() == 'vmware-get-vms':\n      \
    \  result = get_vms()\n    if demisto.command() == 'vmware-poweron':\n       \
    \ result = power_on(demisto.args()['vm-uuid'])\n    if demisto.command() == 'vmware-poweroff':\n\
    \        result = power_off(demisto.args()['vm-uuid'])\n    if demisto.command()\
    \ == 'vmware-hard-reboot':\n        result = hard_reboot(demisto.args()['vm-uuid'])\n\
    \    if demisto.command() == 'vmware-suspend':\n        result = suspend(demisto.args()['vm-uuid'])\n\
    \    if demisto.command() == 'vmware-soft-reboot':\n        result = soft_reboot(demisto.args()['vm-uuid'])\n\
    \    if demisto.command() == 'vmware-create-snapshot':\n        result = create_snapshot(demisto.args())\n\
    \    if demisto.command() == 'vmware-revert-snapshot':\n        result = revert_snapshot(demisto.args()['snapshot-name'],\
    \ demisto.args()['vm-uuid'])\n    if demisto.command() == 'vmware-get-events':\n\
    \        result = get_events(demisto.args()['vm-uuid'], demisto.args()['event-type'])\n\
    \    res.append(result)\nexcept Exception as ex:\n    res.append({ \"Type\" :\
    \ entryTypes[\"error\"], \"ContentsFormat\" : formats[\"text\"], \"Contents\"\
    \ : str(ex)})\n\ntry:\n    logout(si)\nexcept Exception as ex:\n    res.append({\
    \ \"Type\" : entryTypes[\"error\"], \"ContentsFormat\" : formats[\"text\"], \"\
    Contents\" : \"Logout failed. \" + str(ex)})\n\nsys.stdout = sout\ndemisto.results(res)\n\
    sys.exit(0)"
  subtype: python2
  type: python
toversion: 4.1.9
