category: Data Enrichment & Threat Intelligence
commonfields:
  id: InfoArmor VigilanteATI
  version: -1
configuration:
- defaultvalue: https://vigilanteati.infoarmor.com/
  display: Server URL
  name: url
  required: true
  type: 0
- defaultvalue: ''
  display: API Key
  name: apikey
  required: true
  type: 4
- defaultvalue: ''
  display: API Secret
  name: apisecret
  required: true
  type: 4
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: VigilanteATI redefines Advanced Threat Intelligence. InfoArmor's VigilanteATI
  platform and cyber threat services act as an extension of your IT security team.
detaileddescription: 'For Risk Intelligence API Account navigate to Risk Intelligence
  -> Compromised Credentials -> My API Account

  For general API Account navigate to Edit Profile -> API Account'
display: InfoArmor VigilanteATI
image: data:image/png;base64,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
name: InfoArmor VigilanteATI
script:
  commands:
  - arguments:
    - description: Specifies how many days ago (in history) we should go back to fetch
        data for. By default, this parameter is set to 1 which means it returns all
        infected host data added to the database within the last 1 day. To return
        data for all infected hosts you can set this value to be equal to 0, or set
        it a high value such as 3650 days (or 10 years). (optional)
      name: days_ago
    - defaultValue: '20'
      description: Specifies the maximum number of entries to return from this request.
        By default this parameter is set to 20 which means it returns up to the first
        20 infected hosts. The valid range for value of limit is from 1 (minimum)
        to 50,000 (maximum). (optional)
      name: limit
    - description: The token required to retrieve the next page of results; if necessary.
        When the result set is larger than the value of limit the API will return
        a token along with the response so the client can request the next page of
        results appropriately with the next API request. (optional)
      name: token
    - description: Query parameter specifying the alphanumeric version of the IPv4
        address that will be used to query the database. (optional)
      name: q_address
    - description: Query parameter specifying the IP address of the infected host
        was seen communicating with. (optional)
      name: cc_ipaddress
    description: Query all infected host data. This is the API call you want to use
      to lookup infected host data using an IP address or a network range.
    name: vigilante-query-infected-host-data
    outputs:
    - contextPath: VigilanteATI.InfectedHosts.ip
      description: Alphanumeric version of the IPv4 address belonging to this infected
        host.
      type: string
    - contextPath: VigilanteATI.InfectedHosts.port
      description: 'Port number used by the infected host. '
      type: number
    - contextPath: VigilanteATI.InfectedHosts.domain
      description: Domain name associated with the infected host. (e.g sample.com)
      type: string
    - contextPath: VigilanteATI.InfectedHosts.country
      description: Country code representing the country the host is located in. (e.g
        US)
      type: string
    - contextPath: VigilanteATI.InfectedHosts.malware
      description: Name of the malware family we believe has infected the host. (e.g
        c_zeroaccess)
      type: string
    - contextPath: VigilanteATI.InfectedHosts.c_and_c
      description: IP address of the C&C the infected host was seen communicating
        with.
      type: string
    - contextPath: VigilanteATI.InfectedHosts.timestamp
      description: Timestamp of when we last saw this infected host and imported it
        into our database. (e.g 2015-10-10 12:01:01)
      type: date
    - contextPath: VigilanteATI.GetInfectedHostsToken
      description: Token required to paginate the next set of results in. This is
        only provided if host number of items in the response exceeds our max pagination
        size. Otherwise it is set to an empty string. If empty, it means there is
        no next page
      type: string
    - contextPath: VigilanteATI.InfectedHosts
      description: Container for infected host objects. This is basically a list of
        dictionaries (hosts).
  - arguments:
    - defaultValue: '20'
      description: Specifies the maximum number of entries to return from this request.
        By default this parameter is set to 20 which means it returns up to the first
        20 cards. The valid range for value of limit is from 1 (minimum) to 1,000
        (maximum). (optional)
      name: limit
    - description: The re_token required to retrieve the next page of results; if
        necessary. When the result set is larger than the value of limit the API will
        return a re_token along with the response so the client can request the next
        page of results appropriately with the next API request. (optional)
      name: re_token
    - description: The q_address is IP address of the vulnerable one wishes to search.
        If not provided, by default this parameter is set to '*', and thus, will not
        have any constrains on q_address. (optional)
      name: q_address
    - description: The q_mask is mask one wishes to apply to the IP while searching.
        If not provided, by default this parameter is set to '32', and thus, will
        not have any constrains on q_address. (optional)
      name: q_mask
    - description: The q_type is type of the vulnerable one wishes to search. If not
        provided, by default this parameter is set to '*', and thus, will not have
        any constrains on q_type. (optional)
      name: q_type
    description: Returns all vulnerable host data from VI feed for the given query.
      This is the API call you want to use to download the entire feed of vulnerable
      hosts that matches the query.
    name: vigilante-get-vulnerable-host-data
    outputs:
    - contextPath: VigilanteATI.Hosts
      description: Container for vulnerable host objects. This is basically a list
        of dictionaries (hosts).
    - contextPath: VigilanteATI.Hosts.ip
      description: Alphanumeric version of the IPv4 address belonging to this vulnerable
        host.
    - contextPath: VigilanteATI.Hosts.hostname
      description: Hostname of the host. Obtained by doing a lookup using the given
        IPv4 address. (e.g "sample.hostname.com")
    - contextPath: VigilanteATI.Hosts.type
      description: Vulnerability type/name. (e.g heartbleed)
    - contextPath: VigilanteATI.Hosts.port
      description: Port numbers that this might affect. (e.g 443)
    - contextPath: VigilanteATI.Hosts.protocols
      description: Protocols that this might affect. (e.g "ssh")
    - contextPath: VigilanteATI.Hosts.url
      description: URL field. Only applicable with certain vulnerability types such
        as web shell.
    - contextPath: VigilanteATI.Hosts.geoip
      description: JSon of all the data we have about the IP and its location.
    - contextPath: VigilanteATI.Hosts.geoip.timezone
      description: Timezone (e.g Asia/Tokyo)
    - contextPath: VigilanteATI.Hosts.geoip.ip
      description: IPv4 addresss
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.continent_code
      description: Contient Code (e.g AS)
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.city_name
      description: City Name (e.g Tokyo)
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.country_code2
      description: Country Code (e.g JP)
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.country_name
      description: Country Name (e.g Japan)
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.country_code3
      description: Country Code  (e.g JP)
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.region_name
      description: Region Name(e.g Tokyo)
    - contextPath: VigilanteATI.Hosts.geoip.latitude
      description: Latitude (e.g 35.6502)
      type: number
    - contextPath: VigilanteATI.Hosts.geoip.longitude
      description: Longitude (e.g 139.6939)
      type: number
    - contextPath: VigilanteATI.Hosts.geoip.postal_code
      description: Postal Code (e.g 153-0042)
      type: string
    - contextPath: VigilanteATI.Hosts.geoip.region_code
      description: Region Code (e.g 13)
      type: string
    - contextPath: VigilanteATI.Hosts.timestamp
      description: Timestamp of when we found this vulnerable host and imported it
        into our database. (e.g 2015-10-10 12:01:01)
      type: date
    - contextPath: VigilanteATI.GetVulnerableHostsToken
      description: The re_token parameter value required to retrieve the next page
        of results. The token is valid for 5 minutes. The value is null if count is
        equal to either 0 or total.
  - arguments:
    - description: Specifies the search query; may be a lucene query.
      name: query
      required: true
    - description: 'Specifies a specific forum to search. '
      name: q_forum
    - description: Specifies the search start date; only posts on or after q_start_date
        are retrieved. e.g 2017-10-01)
      name: q_start_date
    - description: Specifies the search end date; only posts on or before q_end_date
        are retrieved. (e.g 2017-10-03)
      name: q_end_date
    - defaultValue: '10'
      description: Specifies the maximum number of posts to return. By default limit
        is set to 10, which means the result set is limited to the first 10 posts.
        limit must be between 1 and 100, inclusive.
      name: limit
    - description: The re_token required to retrieve the next page of results when
        the result set is larger than limit. If this parameter is specified, all other
        parameters are ignored.
      name: re_token
    description: Query the eCrime intelligence database. This is the API call you
      want to use to do a full text search on eCrime intelligence data, such as hacker
      chatter.
    name: vigilante-query-ecrime-db
    outputs:
    - contextPath: VigilanteATI.ECrimeQueryToken
      description: The re_token parameter value required to retrieve the next page
        of results. The token is valid for 5 minutes. The value is null if count is
        equal to either 0 or total.
      type: string
    - contextPath: VigilanteATI.ECrimePosts.title
      description: base64 encoded, matching search terms highlighted via <mark> tags
      type: string
    - contextPath: VigilanteATI.ECrimePosts.date
      description: Post date (format YYYY-MM-DD)
      type: date
    - contextPath: VigilanteATI.ECrimePosts.forum
      description: Forum (e.g rstforums.com)
      type: string
    - contextPath: VigilanteATI.ECrimePosts.author
      description: Author
      type: string
    - contextPath: VigilanteATI.ECrimePosts.post
      description: base64 encoded, matching search terms highlighted via <mark> tags
      type: string
  - arguments:
    - description: If set this parameter determines which leak the user wants to return
        metadata for. This is used primarily when you want to get information on just
        a single leak instead of a set of leaks.
      name: leak_id
    - description: Specifies how many days ago (in history) we should go back to fetch
        leak data for. By default this parameter is set to 7 which means it returns
        all leaks added to the database within the last 7 days. To return data for
        all leaks you can set this value to be equal to 0.
      name: days_ago
    - description: Allows you to specify a string keyword to search for. The keyword
        specified is used to search metadata associated with a leak and return any
        matching results. You can search by domain names, hacker groups, affected
        companies, etc.
      name: keyword
    - defaultValue: '20'
      description: Specifies the maximum number of leaks to return from this request.
        By default this parameter is set to 20 which means it returns up to the first
        20 leaks. The valid range for value of limit is from 1 (minimum) to 1,000
        (maximum). (optional)
      name: limit
    - description: The token required to retrieve the next page of results; if necessary.
        When the result set is larger than the value of limit the API will return
        a token along with the response so the client can request the next page of
        results appropriately with the next API request. (optional)
      name: token
    description: ' Retrieves the list of leaks from database.'
    name: vigilante-search-leaks
    outputs:
    - contextPath: VigilanteATI.Leaks.leak_id
      description: Unique identifier for the leak. We internally use MD5 sums to identify
        leaks, so this will be a MD5 sum
      type: string
    - contextPath: VigilanteATI.Leaks.title
      description: Title of the leak.
    - contextPath: VigilanteATI.Leaks.description
      description: A short leak description
    - contextPath: VigilanteATI.Leaks.leak_type
      description: 'Type of the leak. Currently we feature the following leak designations:
        "Database dump", "Credentials dump" or "Credit card dump". As our service
        grows we will add new leak types into the system.'
    - contextPath: VigilanteATI.Leaks.source_refs
      description: List of sources (URIs) where this leak was available at the time
        VigilanteATI team harvested it.
      type: string
    - contextPath: VigilanteATI.Leaks.import_date
      description: The date the leak was first imported into the VigilanteATI database.
      type: date
    - contextPath: VigilanteATI.Leaks.attackers
      description: A list of attackers (hackers) who claimed responsibility for the
        breach/leak.
      type: string
    - contextPath: VigilanteATI.Leaks.score
      description: An integer, in a range of 0 to 100, of how confident we are this
        leak is legitimate.
      type: number
    - contextPath: VigilanteATI.Leaks.num_domains_affected
      description: Number of domains affected by the leak.
      type: number
    - contextPath: VigilanteATI.Leaks.target_industries
      description: A list of target industry verticals affected by the leak.
      type: string
    - contextPath: VigilanteATI.Leaks.attack_method
      description: The method of attack on the target; if published. This is usually
        "SQLi", "phishing", "social engineering", etc.
      type: string
    - contextPath: VigilanteATI.Leaks.media_refs
      description: A list of media articles covering the data leak.
    - contextPath: VigilanteATI.Leaks.targets
      description: List of entities targeted by this leak.
      type: string
    - contextPath: VigilanteATI.Leaks.num_entries
      description: Total number of account credentials (email/password pairs) harvested
        from this leak.
      type: number
    - contextPath: VigilanteATI.Leaks.password_hash
      description: Type of password hash; only present if leaked passwords have been
        hashed.
      type: string
    - contextPath: VigilanteATI.LeakInfoToken
      description: Token required to paginate the next set of results in. This is
        only provided if the number of items in the response exceeds our max pagination
        size. Otherwise it is set to an empty string.
      type: string
  - arguments:
    - description: An identifier (MD5 sum) that uniquely represents this leak in our
        database.
      name: leak_id
      required: true
    - defaultValue: '20'
      description: Specifies the maximum number of account credentials to return from
        this request. By default this parameter is set to 20 which means it returns
        up to the first 20 accounts harvested from this leak. The valid range for
        value of limit is from 1 (minimum) to 10,000 (maximum). (optional)
      name: limit
    - description: A comma delimited list of domains to use a filter for returning
        the harvested credentials. This parameter is used to return only a subset
        of the leak that matches a particular email domain, rather than the whole
        leak. By default this parameter is set to empty string which means it returns
        all harvested credentials, regardless of the email domain they belong to.
        (optional)
      name: domains
    - description: The token required to retrieve the next page of results; if necessary.
        When the result set is larger than the value of limit the API will return
        a token along with the response so the client can request the next page of
        results appropriately with the next API request. (optional)
      name: token
    description: ' Retrieves the list of account credentials that belong to a particular
      leak.'
    name: vigilante-get-leak
    outputs:
    - contextPath: VigilanteATI.Leaks.leak_id
      description: Unique identifier for the leak from which the accounts come from.
        (MD5 sum)
      type: string
    - contextPath: VigilanteATI.Leaks.accounts
      description: Container for account objects. This is just a list of dictionaries.
    - contextPath: VigilanteATI.Leaks.accounts.domain
      description: Email domain which the account belongs to.
      type: string
    - contextPath: VigilanteATI.Leaks.accounts.type_id
      description: Type of account. At the moment we only support accounts of type
        1, which are email addresses. As we expand our service we will add support
        for additional types such as usernames.
      type: number
    - contextPath: VigilanteATI.Leaks.accounts.email
      description: A plaintext form of the email address from the account. The email
        address will always be lowercased.
      type: string
    - contextPath: VigilanteATI.Leaks.accounts.password
      description: The encrypted password found in this leaked account credential.
        This field is the BASE64 encoded representation of the encrypted data. You
        will need to decrypt this password using a decryption key provided to you.
      type: string
    - contextPath: VigilanteATI.LeakAccountsToken
      description: Token required to paginate the next set of results in. This is
        only provided if the number of items in the response exceeds our max pagination
        size. Otherwise it is set to an empty string.
      type: string
  - arguments:
    - description: The string (or comma delimited list of strings) that uniquely identifier
        the account we are trying to match on. In the current version of the API the
        only acceptable types of account identifiers are email address and SHA512
        hashes of email addresses. Please note that if you're populating this argument
        with a list of email addresses or SHA512 hashes we do not allow mixing of
        the two types. The list must be either only email addresses, or only hashes.
        Any email address provided in account_identifier must adhere to RFC 2822.
        (required)
      isArray: true
      name: emails
      required: true
    - defaultValue: '20'
      description: Upper bounds for how many results we will return. By default this
        is set to 20. (optional)
      name: limit
    - description: Used to specify a time range on matching against the given account
        identifier. By default we will run the query against our entire database,
        without restricting results to a time range. (optional)
      name: days_ago
    description: Performs a query to match the given account identifier against database
      of leaked credentials.
    name: vigilante-query-accounts
    outputs:
    - contextPath: VigilanteATI.Account.leak_id
      description: Leak ID related to that account
      type: string
    - contextPath: VigilanteATI.Account.type_id
      description: Type of account. At the moment we only support accounts of type
        1, which are email addresses. As we expand our service we will add support
        for additional types such as usernames.
      type: number
    - contextPath: VigilanteATI.Account.source_type
      description: Denotes type of data. Value of 1 indicates compromised credentials.
        Value of 2 means that these are Endangered Credentials, and the password field
        contains a JSON dictionary instead of a password.
      type: number
    - contextPath: VigilanteATI.Account.email
      description: A plaintext form of the email address from the account. The email
        address will always be lowercased.
      type: string
    - contextPath: VigilanteATI.Account.password
      description: The encrypted password found in this leaked account credential.
        This field is the BASE64 encoded representation of the encrypted data. You
        will need to decrypt this password using a decryption key provided to you.
      type: string
    - contextPath: VigilanteATI.AccountQueryToken
      description: Token required to paginate the next set of results in. This is
        only provided if the number of items in the response exceeds our max pagination
        size. Otherwise it is set to an empty string.
      type: string
  - arguments:
    - description: The string that uniquely identifies the domain we are trying to
        match on. Domain names provided as domain_identifier must adhere to RFC 1035.
      name: domain
      required: true
    - description: If this parameter is supplied, the API will only search the previous
        n days for the domains. The maximum value allowed is 365 days if supplied.
        If this parameter is not included, the will not be restricted by time.
      name: days_ago
    - defaultValue: '20'
      description: Upper bounds for how many results we will return. By default this
        is set to 20.
      name: limit
    - description: The token required to retrieve the next page of results; if necessary.
        When the result set is larger than our max page size the API returns a token
        along with the response so the client can request the next page appropriately
        with the next API request. (optional)
      name: token
    description: ' Performs a query to match the given domain name against our database
      of leaked credentials.'
    name: vigilante-query-domains
    outputs:
    - contextPath: VigilanteATI.Domain.domain
      description: The domain name you queried for.
      type: string
    - contextPath: VigilanteATI.Domain.accounts
      description: Container for results. List of dictionaries, each representing
        a single pair of account credentials with associated metadata.
    - contextPath: VigilanteATI.Domain.accounts.source_type
      description: Denotes type of data. Value of 1 indicates compromised credentials.
        Value of 2 means that these are Endangered Credentials, and the password field
        contains a JSON dictionary instead of a password.
      type: number
    - contextPath: VigilanteATI.Domain.accounts.email
      description: A plaintext form of the email address from the account. The email
        address will always be lowercased.
      type: string
    - contextPath: VigilanteATI.Domain.accounts.password
      description: The encrypted password found in this leaked account credential.
        This field is the BASE64 encoded representation of the encrypted data. You
        will need to decrypt this password using a decryption key provided to you.
      type: string
    - contextPath: VigilanteATI.DomainQueryToken
      description: Token required to paginate the next set of results in. This is
        only provided if the number of items in the response exceeds our max pagination
        size. Otherwise it is set to an empty string.
      type: string
    - contextPath: VigilanteATI.Domain.accounts.leak_id
      description: Identifier of the leak where this account came from. You can use
        this ID to correlate account data to the leak.
      type: string
  - arguments:
    - description: Command separated string containing account identifiers to add
        to your watchlist. All identifiers must be of the same type as specified by
        the type parameter. Identifiers cannot be longer than 255 characters. Multiple
        occurrences of an identifier in the array are treated as a single identifier.
        The maximum number of account identifiers allowed per request is 100. Email
        addresses must adhere to RFC 2822.
      name: account_identifiers
      required: true
    - auto: PREDEFINED
      description: The type of each account identifier, either "email" or "domain"
      name: type
      predefined:
      - email
      - domain
      required: true
    - description: A textual note to associate with each account identifier. Tags
        cannot be longer than 255 characters. (optional)
      name: tag
    description: Add account identifiers to your watchlist.
    name: vigilante-watchlist-add-accounts
  - arguments:
    - description: Comma separated string containing account identifiers to remove
        from your watchlist. Multiple occurrences of an identifier in the array are
        treated as a single identifier. The maximum number of account identifiers
        allowed per request is 100. (required)
      name: account_identifiers
      required: true
    description: Remove account identifiers from your watchlist
    name: vigilante-watchlist-remove-accounts
  - arguments:
    - defaultValue: '20'
      description: Specifies the maximum number of identifiers to return. By default
        limit is set to 20, which means the result set is limited to the most recently
        added 20 identifiers. limit must be between 1 and 5000, inclusive. (optional)
      name: limit
    - description: The token required to retrieve the next page of results. If this
        parameter is specified, the limit parameter is ignored. (optional)
      name: token
    description: Retrieve account identifiers on your watchlist.
    name: vigilante-get-watchlist
    outputs:
    - contextPath: VigilanteATI.Watchlist
      description: Watchlist of accounts
    - contextPath: VigilanteATI.Watchlist.identifier
      description: account identifier (e.g "john@domain.com")
    - contextPath: VigilanteATI.Watchlist.type
      description: identifer type ("email" or "domain")
    - contextPath: VigilanteATI.Watchlist.date_added
      description: date identifier added to watchlist (YYYY-MM-DD)
    - contextPath: VigilanteATI.Watchlist.date_notified
      description: latest matching intelligence date (YYYY-MM-DD)
    - contextPath: VigilanteATI.Watchlist.tag
      description: identifier tag
    - contextPath: VigilanteATI.WatchlistQueryToken
      description: The token parameter value required to retrieve the next page of
        results. The value is null if there are no more pages of results to retrieve.
      type: string
  - arguments: []
    description: Returns the usage data for your account.
    name: vigilante-account-usage-info
  runonce: false
  script: "import json\nimport base64\nimport binascii\nimport hashlib\nimport hmac\n\
    import time\nimport requests\nfrom datetime import datetime\n\n# disable insecure\
    \ warnings\nrequests.packages.urllib3.disable_warnings()\n\n\nif not demisto.params()['proxy']:\n\
    \    del os.environ['HTTP_PROXY']\n    del os.environ['HTTPS_PROXY']\n    del\
    \ os.environ['http_proxy']\n    del os.environ['https_proxy']\n\nBASE_URL = demisto.params().get('url')\n\
    API_KEY = demisto.params().get('apikey')\nAPI_SECRET = demisto.params().get('apisecret')\n\
    VERIFY_SSL = not demisto.params().get('unsecure', False)\n\ndef gen_hmac(method,\
    \ timestamp, api_key, api_secret):\n    \"\"\"\n    Generate HMAC string for VigilanteATI\
    \ API service. The string is generated as follows:\n    hmac('sha1', 'API_KEY'\
    \ + 'TIMESTAMP' + 'METHOD_NAME', 'API_SECRET')\n    \"\"\"\n    msg = \"%s%s%s%s\"\
    \ % (api_key, timestamp, method, api_secret)\n    hm = hmac.new(str(api_secret),\
    \ str(msg), hashlib.sha1)\n    return hm.hexdigest()\n\n\ndef http_request(method,\
    \ url, hmac_url, params={}, data=None):\n    if params is None:\n        params\
    \ = {}\n\n    ts = int(time.time())\n    hmacc = gen_hmac(hmac_url, ts, API_KEY,\
    \ API_SECRET)\n\n    fullurl = BASE_URL + url\n    params['ts'] = ts\n    params['key']\
    \ = API_KEY\n    params['hmac'] = hmacc\n\n    res = requests.request(\n     \
    \   method,\n        fullurl,\n        headers={\n            'Content-Type':\
    \ 'application/json',\n            'Accept': 'application/json'\n        },\n\
    \        params=params,\n        verify=VERIFY_SSL,\n        json=data\n    )\n\
    \n    if res.status_code < 200 or res.status_code >= 300:\n        return_error('Request\
    \ failed.\\nURL: {}\\nStatusCode: {}\\nResponse: \\n{}'.format(fullurl, res.status_code,\
    \ res.text))\n\n    try:\n        res.json()\n    except:\n        return_error('Response\
    \ failed, the response body is not json.\\nURL: {}\\nStatusCode: {}\\nResponse:\
    \ \\n{}'.format(fullurl, res.status_code, res.text))\n\n    return res\n\ndef\
    \ query_infected_host_data(days_ago=None, limit=None, token=None, q_address=None,\
    \ cc_ipaddress=None):\n    params = {}\n    if days_ago:\n        params['days_ago']\
    \ = days_ago\n\n    if limit:\n        params['limit'] = limit\n\n    if token:\n\
    \        params['token'] = token\n\n    if q_address:\n        params['q_address']\
    \ = q_address\n\n    if cc_ipaddress:\n        params['cc_ipaddress'] = cc_ipaddress\n\
    \n    res = http_request('get', 'api/2/si/infected/query', 'si.infected.query',\
    \ params)\n    return res.json()\n\n\ndef query_infected_host_data_command():\n\
    \    days_ago = demisto.args().get('days_ago')\n    limit = demisto.args().get('limit')\n\
    \    token = demisto.args().get('token')\n    q_address = demisto.args().get('q_address')\n\
    \    cc_ipaddress = demisto.args().get('cc_ipaddress')\n\n    infected_hosts =\
    \ query_infected_host_data(days_ago, limit, token, q_address, cc_ipaddress)\n\
    \    markdown = tableToMarkdown('Infected hosts', infected_hosts.get('hosts'))\n\
    \    demisto.results({\n        'Type': entryTypes['note'],\n        'ContentsFormat':\
    \ formats['json'],\n        'Contents': infected_hosts,\n        'HumanReadable':\
    \ markdown,\n        'EntryContext': {\n            'VigilanteATI.InfectedHost(val.ip\
    \ == obj.ip)': infected_hosts.get('hosts'),\n            'VigilanteATI.GetInfectedHostsToken(true==true)':\
    \ infected_hosts.get('re_token')\n        }\n    })\n\ndef query_elasticsearch(max_rows,\
    \ query):\n    params = {}\n    if max_rows:\n        params['maxRows'] = max_rows\n\
    \n    if query:\n        params['query'] = query\n\n    res = http_request('get',\
    \ 'api/1/es/fulltext/query', 'es.fulltext.query', params)\n    return res.json()\n\
    \ndef query_elasticsearch_command():\n    max_rows = int(demisto.args().get('max_rows',\
    \ 10))\n    query = demisto.args().get('query')\n\n    results = query_elasticsearch(max_rows,\
    \ query)\n    if len(results.get('results')) == 0:\n        demisto.results('No\
    \ results')\n\n    markdown = tableToMarkdown('Elasticsearch Results', results.get('results'))\n\
    \n    demisto.results({\n        'Type': entryTypes['note'],\n        'ContentsFormat':\
    \ formats['json'],\n        'Contents': results,\n        'HumanReadable': markdown,\n\
    \        'EntryContext': {\n            'VigilanteATI.ElasticsearchResults': results.get('results')\n\
    \        }\n    })\n\ndef search(query, days_ago, exact_match):\n    params =\
    \ {}\n    if days_ago:\n        params['daysAgo'] = days_ago\n\n    if query:\n\
    \        params['query'] = query\n\n    if exact_match:\n        params['exactMatch']\
    \ = exact_match\n\n    res = http_request('get', 'api/1/fullext/query', 'fulltext.query',\
    \ params)\n\n    return res.json()\n\ndef search_command():\n    days_ago = demisto.args().get('days_ago')\n\
    \    query = demisto.args().get('query')\n    exact_match = demisto.args().get('exact_match')\n\
    \n    results = search(query, days_ago, exact_match)\n    if len(results.get('results'))\
    \ == 0:\n        demisto.results('No results')\n\n    markdown = tableToMarkdown('Search\
    \ Results', results.get('results'))\n\n    demisto.results({\n        'Type':\
    \ entryTypes['note'],\n        'ContentsFormat': formats['json'],\n        'Contents':\
    \ results,\n        'HumanReadable': markdown,\n        'EntryContext': {\n  \
    \          'SearchResults': results.get('results')\n        }\n    })\n\ndef get_vulnerable_host_data(limit,\
    \ q_address, q_mask, q_type, re_token=None):\n    params = {}\n    if limit:\n\
    \        params['limit'] = limit\n\n    if q_address:\n        params['q_address']\
    \ = q_address\n\n    if q_mask:\n        params['q_mask'] = q_mask\n\n    if q_type:\n\
    \        params['q_type'] = q_type\n\n    if re_token:\n        params['re_token']\
    \ = re_token\n\n    res = http_request('get', 'api/2/vi/hosts/get', 'vi.hosts.get',\
    \ params)\n    return res.json()\n\ndef get_vulnerable_host_data_command():\n\
    \    limit = int(demisto.args().get('limit', 100))\n    q_address = demisto.args().get('q_address')\n\
    \    q_mask = demisto.args().get('q_mask')\n    q_type = demisto.args().get('q_type')\n\
    \n    raw_host_data = get_vulnerable_host_data(limit, q_address, q_mask, q_type)\n\
    \    if len(raw_host_data.get('hosts')) == 0:\n        demisto.results('No results')\n\
    \        sys.exit(0)\n\n    markdown = tableToMarkdown('Vulnerable host data from\
    \ VI feed', raw_host_data.get('hosts'))\n\n    demisto.results({\n        'Type':\
    \ entryTypes['note'],\n        'ContentsFormat': formats['json'],\n        'Contents':\
    \ raw_host_data,\n        'HumanReadable': markdown,\n        'EntryContext':\
    \ {\n            'Hosts(val.ip === obj.ip)': raw_host_data.get('hosts')\n    \
    \    }\n    })\n\ndef search_leaks(leak_id, days_ago, keyword, limit, token=None):\n\
    \    \"\"\"\n    Retrieves the list of leaks from our database.\n    \"\"\"\n\
    \    params = {}\n    if leak_id:\n        params['leakId'] = leak_id\n\n    if\
    \ days_ago:\n        params['daysAgo'] = days_ago\n\n    if keyword:\n       \
    \ params['keyword'] = keyword\n\n    if limit:\n        params['limit'] = limit\n\
    \n    if token:\n        params['token'] = token\n\n    res = http_request('get',\
    \ 'api/1/leaks/info', 'leaks.info', params)\n    return res.json()\n\ndef search_leaks_command():\n\
    \    leak_id = demisto.args().get('leak_id')\n    days_ago = demisto.args().get('days_ago')\n\
    \    keyword = demisto.args().get('keyword')\n    limit = int(demisto.args().get('limit',\
    \ 20))\n    token = demisto.args().get('token')\n\n    raw_list_leaks = search_leaks(leak_id,\
    \ days_ago, keyword, limit, token)\n    markdown = tableToMarkdown('List of leaks',\
    \ raw_list_leaks.get('leaks'), [\n            'leak_id',\n            'title',\n\
    \            'leak_type',\n            'score',\n            'leak_date',\n  \
    \          'breach_date',\n            'targets',\n            'attackers',\n\
    \            'num_entries',\n            'password_type',\n            'description',\n\
    \            'source_refs',\n            'attack_method',\n            'target_industries',\n\
    \            'media_refs',\n            'password_hash',\n            'num_domains_affected',\n\
    \            'import_date'\n        ])\n\n    demisto.results({\n        'Type':\
    \ entryTypes['note'],\n        'ContentsFormat': formats['json'],\n        'Contents':\
    \ raw_list_leaks,\n        'HumanReadable': markdown,\n        'EntryContext':\
    \ {\n            'VigilanteATI.LeakInfoToken(true==true)': raw_list_leaks.get('token'),\n\
    \            'VigilanteATI.Leaks(val.leak_id === obj.leak_id)': raw_list_leaks.get('leaks')\n\
    \        }\n    })\n\ndef get_leak(leak_id, limit, domains, token):\n    \"\"\"\
    \n    Retrieve all the accounts related to this specific leak\n    \"\"\"\n  \
    \  params = remove_none_params({\n        'leak_id': leak_id,\n        'limit':\
    \ limit,\n        'domains': domains,\n        'token': token\n    })\n\n    res\
    \ = http_request('get', 'api/1/leaks/get', 'leaks.get', params)\n    return res.json()\n\
    \n\ndef get_leak_command():\n    leak_id = demisto.args().get('leak_id')\n   \
    \ domains = demisto.args().get('domains')\n    token = demisto.args().get('token')\n\
    \    limit = int(demisto.args().get('limit', 20))\n\n    leak = get_leak(leak_id,\
    \ limit, domains, token)\n    if not leak and len(leak.get('accounts')) == 0:\n\
    \        demisto.results('Leak has no accounts related to it')\n        sys.exit(0)\n\
    \n    accounts = leak.get('accounts')\n    for i, _ in enumerate(accounts):\n\
    \        account = accounts[i]\n        account['email'] = account['plain']\n\
    \        del account['plain']\n\n    markdown = tableToMarkdown('Accounts related\
    \ to leak {}'.format(leak_id), leak.get('accounts'), ['email', 'domain', 'password',\
    \ 'type_id'])\n    outputs = {\n        'VigilanteATI.Leaks(val.leak_id === obj.leak_id)':\
    \ {\n            'leak_id': leak_id,\n            'accounts': accounts\n     \
    \   }\n    }\n    if leak.get('token'):\n        outputs['VigilanteATI.LeakAccountsToken(true==true)']\
    \ = leak.get('token')\n\n    demisto.results({\n        'Type': entryTypes['note'],\n\
    \        'ContentsFormat': formats['json'],\n        'Contents': leak,\n     \
    \   'HumanReadable': markdown,\n        'EntryContext': outputs\n    })\n\ndef\
    \ remove_none_params(params_dict):\n    \"\"\"\n    filter only the params that\
    \ have values\n    \"\"\"\n    return dict((k,v) for k,v in params_dict.iteritems()\
    \ if v is not None)\n\ndef query_ecrime_intelligence_database(query, q_forum,\
    \ q_start_data, limit, re_token=None):\n    params = remove_none_params({\n  \
    \      'query': query,\n        'q_forum': q_forum,\n        'q_start_data': q_start_data,\n\
    \        'limit': limit,\n        're_token': re_token\n    })\n\n    res = http_request('get',\
    \ 'api/1/ecrime/posts/query', 'ecrime.posts.query', params)\n    return res.json()\n\
    \ndef query_ecrime_intelligence_database_command():\n    query = demisto.args().get('query')\n\
    \    q_forum = demisto.args().get('q_forum')\n    q_start_data = demisto.args().get('q_start_data')\n\
    \    limit = int(demisto.args().get('limit', 10))\n    re_token = demisto.args().get('re_token')\n\
    \n    results = query_ecrime_intelligence_database(query, q_forum, q_start_data,\
    \ limit, re_token)\n    posts = results.get('posts')\n    for post in posts:\n\
    \        post['title'] = base64.b64decode(post['title']).decode('utf8')\n    \
    \    post['post'] = base64.b64decode(post['post']).decode('utf8')\n\n    markdown\
    \ = tableToMarkdown('ECrime Posts', posts)\n    markdown += '\\n**Total Count**:\
    \ {}'.format(results.get('count'))\n    markdown += '\\n**Next Page Token**: \\\
    n{}'.format(results.get('re_token'))\n\n    outputs = {\n        'VigilanteATI.ECrimePosts':\
    \ posts\n    }\n    if results.get('re_token'):\n        outputs['VigilanteATI.ECrimeQueryToken(true==true)']\
    \ = results.get('re_token')\n\n\n    demisto.results({\n        'Type': entryTypes['note'],\n\
    \        'ContentsFormat': formats['json'],\n        'Contents': results,\n  \
    \      'HumanReadable': markdown,\n        'EntryContext': outputs\n    })\n\n\
    def list_account_credentials(leak_id, limit, domains, token=None):\n    params\
    \ = remove_none_params({\n        'leak_id': leak_id,\n        'limit': limit,\n\
    \        'domains': domains,\n        'token': token\n    })\n\n    res = http_request('get',\
    \ 'api/1/leaks/get', 'leaks.get', params)\n    return res.json()\n\ndef query_accounts(account_identifier,\
    \ limit, days_ago):\n    if days_ago is not None:\n        days_ago = int(days_ago)\n\
    \n    body = remove_none_params({\n        'account_identifier': account_identifier,\n\
    \        'limit': limit,\n        'daysAgo': days_ago\n    })\n\n    res = http_request('post',\
    \ 'api/3/accounts/query', 'accounts.query', None, data=body)\n    return res.json()\n\
    \ndef query_accounts_command():\n    emails = argToList(demisto.args().get('emails'))\n\
    \    days_ago = demisto.args().get('days_ago')\n    limit = demisto.args().get('limit')\n\
    \n    results = query_accounts(emails, limit, days_ago)\n    accounts = results.get('results')\n\
    \    for i, _ in enumerate(accounts):\n        account = accounts[i]\n       \
    \ account['email'] = account['plain']\n        del account['plain']\n\n    markdown\
    \ = tableToMarkdown('Leaks related to email accounts \\n{}'.format('\\n'.join(emails)),\
    \ accounts, ['leak_id', 'email', 'password', 'source_type', 'type_id'])\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'ContentsFormat': formats['json'],\n\
    \        'Contents': results,\n        'HumanReadable': markdown,\n        'EntryContext':\
    \ {\n            'VigilanteATI.Account(val.email == obj.email && val.password\
    \ == obj.password && val.leak_id && obj.leak_id)': accounts\n        }\n    })\n\
    \ndef domain_info(domain_identifier, subdomains, days_ago):\n    params = remove_none_params({\n\
    \        'domain_identifier': domain_identifier,\n        'subdomains': subdomains,\n\
    \        'daysAgo': days_ago\n    })\n\n    res = http_request('get', 'api/1/domains/info',\
    \ 'domains.info', params)\n    domain_info = res.json()\n    if not domain_info:\n\
    \        return []\n\n    if isinstance(domain_info) != list:\n        # if it\
    \ single object then return an array\n        return [domain_info]\n\n    return\
    \ domain_info\n\ndef query_domains(domain, days_ago, limit, token=None):\n   \
    \ params = remove_none_params({\n        'domain_identifier': domain,\n      \
    \  'limit': limit,\n        'daysAgo': days_ago,\n        'token': token\n   \
    \ })\n\n    res = http_request('get', 'api/1/domains/query', 'domains.query',\
    \ params)\n    domains = res.json()\n    return domains\n\ndef query_domains_command():\n\
    \    domain = demisto.args().get('domain')\n    limit = int(demisto.args().get('limit',\
    \ 20))\n    days_ago = demisto.args().get('days_ago')\n    token = demisto.args().get('token')\n\
    \n    query_results = query_domains(domain, days_ago, limit, token)\n    accounts\
    \ = query_results.get('accounts')\n    for i, _ in enumerate(accounts):\n    \
    \    account = accounts[i]\n        account['email'] = account['plain']\n    \
    \    del account['plain']\n    markdown = tableToMarkdown('Accounts related to\
    \ domain: {}'.format(domain), accounts, ['leak_id', 'email', 'password', 'source_type',\
    \ 'type_id'])\n\n    outputs = {\n        'VigilanteATI.Domain(val.domain == obj.domain)':\
    \ {\n            'domain': query_results.get('domain_identifier'),\n         \
    \   'accounts': accounts\n        }\n    }\n    if query_results.get('token'):\n\
    \        outputs['DomainQueryToken'] = query_results.get('token')\n\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'ContentsFormat': formats['json'],\n\
    \        'Contents': query_results,\n        'HumanReadable': markdown,\n    \
    \    'EntryContext': outputs\n    })\n\ndef get_report(date, account_identifier,\
    \ limit, token=None):\n    params = remove_none_params({\n        'date': date,\n\
    \        'account_identifier': account_identifier,\n        'limit': limit,\n\
    \        'token': token\n    })\n\n    res = http_request('get', 'api/1/reports/get',\
    \ 'reports.get', params)\n    reports = res.json()\n    return reports\n\ndef\
    \ watchlist_add_accounts(account_identifiers, _type, tag):\n    body = remove_none_params({\n\
    \        'account_identifiers': account_identifiers,\n        'type': _type,\n\
    \        'tag': tag\n    })\n\n    params = {\n        'account_identifiers':\
    \ json.dumps(account_identifiers),\n        'type': _type,\n        'tag': tag\n\
    \    }\n\n    res = http_request('post', 'api/2/watchlist', 'watchlist.add', params,\
    \ body)\n    result = res.json()\n\n    return result\n\ndef watchlist_add_accounts_command():\n\
    \    account_identifiers = demisto.args().get('account_identifiers')\n    if isinstance(account_identifiers,\
    \ basestring):\n        account_identifiers = account_identifiers.split(',')\n\
    \n    _type = demisto.args().get('type')\n    tag = demisto.args().get('tag')\n\
    \n    result = watchlist_add_accounts(account_identifiers, _type, tag)\n    markdown\
    \ = ''\n    added = result.get('added')\n    already_on_watchlist = result.get('already\
    \ on watchlist')\n    invalid = result.get('invalid')\n\n\n    if len(added) >\
    \ 0:\n        markdown += '### Added: {}\\n\\n'.format(','.join(added))\n\n  \
    \  if len(already_on_watchlist) > 0:\n        markdown += '### Already on watchlist:\
    \ {}'.format(','.join(already_on_watchlist))\n\n    if len(invalid) > 0:\n   \
    \     markdown += '### Invalid: {}\\n'.format(','.join(invalid))\n\n\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'ContentsFormat': formats['json'],\n\
    \        'Contents': result,\n        'HumanReadable': markdown\n    })\n\ndef\
    \ watchlist_remove_accounts(account_identifiers):\n    params = remove_none_params({\n\
    \        'account_identifiers': json.dumps(account_identifiers)\n    })\n\n  \
    \  res = http_request('delete', 'api/2/watchlist', 'watchlist.remove', params)\n\
    \    result = res.json()\n\n    return result\n\ndef watchlist_remove_accounts_command():\n\
    \    account_identifiers = demisto.args().get('account_identifiers')\n    if isinstance(account_identifiers,\
    \ basestring):\n        account_identifiers = account_identifiers.split(',')\n\
    \n    result = watchlist_remove_accounts(account_identifiers)\n    removed = result.get('removed')\n\
    \    not_on_watchlist = result.get('not on watchlist')\n\n    markdown = ''\n\
    \    if len(removed) > 0:\n        markdown += '### Removed: {}'.format(','.join(removed))\n\
    \n    if len(not_on_watchlist) > 0:\n        markdown += '### Not on watchlist:\
    \ {}'.format(','.join(not_on_watchlist))\n\n    demisto.results({\n        'Type':\
    \ entryTypes['note'],\n        'ContentsFormat': formats['json'],\n        'Contents':\
    \ result,\n        'HumanReadable': markdown\n    })\n\ndef get_watchlist_accounts(limit,\
    \ token=None):\n    params = remove_none_params({\n        'limit': limit,\n \
    \       'token': token\n    })\n\n    res = http_request('get', 'api/2/watchlist',\
    \ 'watchlist.info', params)\n    reports = res.json()\n    return reports\n\n\
    def get_watchlist_accounts_command():\n    limit = int(demisto.args().get('limit',\
    \ 20))\n    token = demisto.args().get('token')\n\n    watchlist = get_watchlist_accounts(limit,\
    \ token)\n    markdown = tableToMarkdown('Watchlist', watchlist.get('identifiers'))\n\
    \n    demisto.results({\n        'Type': entryTypes['note'],\n        'ContentsFormat':\
    \ formats['json'],\n        'Contents': watchlist,\n        'HumanReadable': markdown,\n\
    \        'EntryContext': {\n            'VigilanteATI.WatchlistQueryToken(true==true)':\
    \ watchlist.get('token'),\n            'VigilanteATI.Watchlist(val.identifier\
    \ == obj.identifier)': watchlist.get('identifiers')\n        }\n    })\n\ndef\
    \ usage_info():\n    res = http_request('get', 'api/1/usage/info', 'usage.info')\n\
    \    usage = res.json()\n    return usage\n\ndef usage_info_command():\n    raw_usage\
    \ = usage_info()\n    usage = [{\n        'Number of queries allowed': raw_usage.get('num_queries_allotted'),\n\
    \        'Number of queries left': raw_usage.get('num_queries_left')\n    }]\n\
    \    markdown = tableToMarkdown('Usage Info', usage)\n\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'ContentsFormat': formats['json'],\n\
    \        'Contents': usage,\n        'HumanReadable': markdown\n    })\n\nif demisto.command()\
    \ == 'test-module':\n    query_infected_host_data(\n        days_ago=0,\n    \
    \    q_address='8.8.8.8',\n        limit=1\n    )\n    usage_info()\n\n    demisto.results('ok')\n\
    \    sys.exit(0)\n\nif demisto.command() == 'vigilante-query-infected-host-data':\n\
    \    query_infected_host_data_command()\n    sys.exit(0)\n\nelif demisto.command()\
    \ == 'vigilante-query-elasticsearch':\n    query_elasticsearch_command()\n   \
    \ sys.exit(0)\n\nelif demisto.command() == 'vigilante-search':\n    search_command()\n\
    \    sys.exit(0)\n\nelif demisto.command() == 'vigilante-get-vulnerable-host-data':\n\
    \    get_vulnerable_host_data_command()\n    sys.exit(0)\n\nelif demisto.command()\
    \ == 'vigilante-search-leaks':\n    search_leaks_command()\n    sys.exit(0)\n\n\
    elif demisto.command() == 'vigilante-get-leak':\n    get_leak_command()\n    sys.exit(0)\n\
    \nelif demisto.command() == 'vigilante-query-ecrime-db':\n    query_ecrime_intelligence_database_command()\n\
    \    sys.exit(0)\n\nelif demisto.command() == 'vigilante-list-account-credentials':\n\
    \    list_account_credentials_command()\n    sys.exit(0)\n\nelif demisto.command()\
    \ == 'vigilante-query-accounts':\n    query_accounts_command()\n    sys.exit(0)\n\
    \nelif demisto.command() == 'vigilante-query-domains':\n    query_domains_command()\n\
    \    sys.exit(0)\n\nelif demisto.command() == 'vigilante-watchlist-add-accounts':\n\
    \    watchlist_add_accounts_command()\n    sys.exit(0)\n\nelif demisto.command()\
    \ == 'vigilante-watchlist-remove-accounts':\n    watchlist_remove_accounts_command()\n\
    \    sys.exit(0)\n\nelif demisto.command() == 'vigilante-get-watchlist':\n   \
    \ get_watchlist_accounts_command()\n    sys.exit(0)\n\nelif demisto.command()\
    \ == 'vigilante-account-usage-info':\n    usage_info_command()\n    sys.exit(0)\n\
    \nelse:\n    demisto.results('Command not implement yet')"
  subtype: python2
  type: python
tests:
- InfoArmorVigilanteATITest
toversion: 4.1.9
