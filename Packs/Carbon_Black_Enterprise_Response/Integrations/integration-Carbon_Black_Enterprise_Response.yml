category: Endpoint
commonfields:
  id: carbonblack-v2
  version: -1
configuration:
- defaultvalue: ''
  display: Server URL
  name: serverurl
  required: true
  type: 0
- defaultvalue: ''
  display: API Token
  name: apitoken
  required: true
  type: 4
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ''
  display: Fetch Alert Severity Threshold Higher Than
  name: fetchAlertsSeverityThreshold
  required: false
  type: 0
- defaultvalue: '10'
  display: Maximum Number Of Incidents To Fetch
  name: rows
  required: false
  type: 0
description: Query and response with Carbon Black endpoint detection and response.
display: Carbon Black Enterprise Response v2
fromversion: 3.6.0
image: data:image/png;base64,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
name: carbonblack-v2
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: Alert status to filter by
      name: status
      predefined:
      - Unresolved
      - In Progress
      - Resolved
      - False Positive
    - description: Alert username to filter by
      name: username
    - description: Alert feedname to filter by
      name: feedname
    - description: Alert hostname to filter by
      name: hostname
    - description: Alert report name (watchlist_id) to filter by
      name: report
    - default: true
      description: Query string. Accepts the same data as the search box on the Binary
        Search page. See https://github.com/carbonblack/cbapi/blob/master/client_apis/docs/query_overview.pdf
      name: query
    - description: Return this many rows, 10 by default.
      name: rows
    - description: Start at this row, 0 by default.
      name: start
    - description: Sort rows by this field and order. server_added_timestamp desc
        by default.
      name: sort
    - description: Return facet results. 'false' by default, set to 'true' for facets.
      name: facet
    description: Retrieve alerts from Carbon Black Response.
    name: cb-alert
    outputs:
    - contextPath: CbResponse.Alerts.CbAlertID
      description: Alert unique id
    - contextPath: CbResponse.Alerts.ProcessPath
      description: Alert Process Path
      type: string
    - contextPath: CbResponse.Alerts.Hostname
      description: Alert Hostname
      type: string
    - contextPath: CbResponse.Alerts.InterfaceIP
      description: Alert interface IP
      type: string
    - contextPath: CbResponse.Alerts.CommsIP
      description: Communications IP
      type: string
    - contextPath: CbResponse.Alerts.MD5
      description: Alert process MD5
      type: string
    - contextPath: CbResponse.Alerts.Description
      description: Alert description
    - contextPath: CbResponse.Alerts.FeedName
      description: Alert feed name
    - contextPath: CbResponse.Alerts.Severity
      description: Alert severity
    - contextPath: CbResponse.Alerts.Time
      description: Alert created time
    - contextPath: CbResponse.Alerts.Status
      description: 'Alert status. One of: Unresolved, Resolved, False Positive'
  - arguments:
    - auto: PREDEFINED
      description: Whether digital signature is signed or not
      name: digital-signature
      predefined:
      - Signed
      - Unsigned
    - description: Filter binary by publisher
      name: publisher
    - description: Filter binary by company name
      name: company-name
    - description: Filter binary by product name
      name: product-name
    - description: Filter binary by file path
      name: filepath
    - description: Filter binary by group
      name: group
    - description: Filter binary by hostname
      name: hostname
    - default: true
      description: Query string. Accepts the same data as the search box on the Binary
        Search page. See https://github.com/carbonblack/cbapi/blob/master/client_apis/docs/query_overview.pdf
      name: query
    - description: Return this many rows, 10 by default.
      name: rows
    - description: Start at this row, 0 by default.
      name: start
    - description: Sort rows by this field and order. server_added_timestamp desc
        by default.
      name: sort
    - description: Return facet results. 'false' by default, set to 'true' for facets.
      name: facet
    description: Query for binaries based on given parameters
    name: cb-binary
    outputs:
    - contextPath: File.DigSig.Publisher
      description: The publisher of the Digital Signature
    - contextPath: File.InternalName
      description: The Internal Name
    - contextPath: File.ServerAddedTimestamp
      description: The server added timestamp
    - contextPath: File.Name
      description: Binary Name
    - contextPath: File.Extension
      description: Binary Extension
    - contextPath: File.Timestamp
      description: Binary Timestamp
    - contextPath: File.Hostname
      description: Binary Hostname
    - contextPath: File.Description
      description: The description
    - contextPath: File.DigSig.Result
      description: Cb's decision after checking this binary's Digital Signature
    - contextPath: File.LastSeen
      description: Last time binary was seen
    - contextPath: File.Path
      description: Binary Path
    - contextPath: File.ProductName
      description: The Product Name
    - contextPath: File.OS
      description: The OS
    - contextPath: File.MD5
      description: Binary MD5
    - contextPath: File.Company
      description: Name of the company that released a binary
      type: string
    - contextPath: File.DigitalSignature.Publisher
      description: Publisher of the digital signature for the file.
      type: string
    - contextPath: File.Name
      description: Full Filename e.g. data.xls.
      type: string
    - contextPath: File.Signature.OriginalName
      description: File's original name.
      type: string
    - contextPath: File.Signature.InternalName
      description: File's internal name.
      type: string
    - contextPath: File.Signature.FileVersion
      description: File version.
      type: string
    - contextPath: File.Signature.Description
      description: Description of the signature.
      type: string
  - arguments:
    - default: true
      description: MD5 File Hash
      name: md5
      required: true
    - auto: PREDEFINED
      description: Whether to include summary
      name: summary
      predefined:
      - 'yes'
      - 'no'
    - auto: PREDEFINED
      defaultValue: 'yes'
      description: Whether to decompress results
      name: decompress
      predefined:
      - 'yes'
      - 'no'
    deprecated: true
    description: Deprecated. Use the cb-binary-download command instead.
    name: cb-binary-get
    outputs:
    - contextPath: File.DigSig.Publisher
      description: The publisher of the Digital Signature
    - contextPath: File.InternalName
      description: The Internal Name
    - contextPath: File.ServerAddedTimestamp
      description: The server added timestamp
    - contextPath: File.Name
      description: Binary Name
    - contextPath: File.Extension
      description: Binary Extension
    - contextPath: File.Timestamp
      description: Binary Timestamp
    - contextPath: File.Hostname
      description: Binary Hostname
    - contextPath: File.Description
      description: The description
    - contextPath: File.DigSig.Result
      description: Cb's decision after checking this binary's Digital Signature
    - contextPath: File.LastSeen
      description: Last time binary was seen
    - contextPath: File.Path
      description: Binary Path
    - contextPath: File.ProductName
      description: The Product Name
    - contextPath: File.OS
      description: The OS
    - contextPath: File.MD5
      description: Binary MD5
    - contextPath: File.Company
      description: Name of the company that released a binary
      type: string
    - contextPath: File.DigitalSignature.Publisher
      description: Publisher of the digital signature for the file.
      type: string
    - contextPath: File.Name
      description: Full Filename e.g. data.xls.
      type: string
    - contextPath: File.Signature.OriginalName
      description: File's original name.
      type: string
    - contextPath: File.Signature.InternalName
      description: File's internal name.
      type: string
    - contextPath: File.Signature.FileVersion
      description: File version.
      type: string
    - contextPath: File.Signature.Description
      description: Description of the signature.
      type: string
  - arguments:
    - description: the blacklisted hash
      name: md5hash
      required: true
    - description: text description of blacklist
      name: text
      required: true
    - description: the last time the hash was blocked or prevented from being executed
      name: lastBanTime
    - description: total number of blocks on this blacklist
      name: banCount
    - description: last hostname to block this hash
      name: lastBanHost
    description: Blocking hash
    important:
    - contextPath: File(val.LastAction)
      description: File Actions
      related: ''
    name: cb-block-hash
    outputs:
    - contextPath: File.LastAction
      description: Last action taken on this file
  - arguments:
    - description: 'OPTIONAL filters blacklist by fields. Example: filter="md5hash
        == put_your_hash_here"'
      name: filter
    description: Returns a list of blacklisted hashes, with each list entry describing
      one blacklisted hash
    name: cb-get-hash-blacklist
    outputs:
    - contextPath: CbResponse.BlockedHashes.MD5
      description: Blocked MD5
    - contextPath: CbResponse.BlockedHashes.Enabled
      description: Is Enabled
    - contextPath: CbResponse.BlockedHashes.Description
      description: Blocked Description
    - contextPath: CbResponse.BlockedHashes.Timestamp
      description: Blocked Timestamp
    - contextPath: CbResponse.BlockedHashes.BlockCount
      description: Blocked Count
    - contextPath: CbResponse.BlockedHashes.Username
      description: Blocked hash username
    - contextPath: CbResponse.BlockedHashes.LastBlock.Time
      description: Last block time
    - contextPath: CbResponse.BlockedHashes.LastBlock.Hostname
      description: Last block hostname
    - contextPath: CbResponse.BlockedHashes.LastBlock.CbSensorID
      description: Last block sensor ID
  - arguments:
    - description: the internal CB process id; this is the id field in search results
      name: pid
      required: true
    - description: the process segment id, the segment_id field in search results.
      name: segid
      required: true
    - auto: PREDEFINED
      defaultValue: 'false'
      description: If set to true, will get process siblings, parent and children.
      name: get_related
      predefined:
      - 'false'
      - 'true'
    description: Gets basic process information for segment (segment_id) of process
      (process_id)
    name: cb-get-process
    outputs:
    - contextPath: Process.Siblings.MD5
      description: The sibling Process MD5
    - contextPath: Process.CbSegmentID
      description: Cb 'segment' where this process instance is stored. Required to
        fetch further info on a process.
    - contextPath: Process.Parent.MD5
      description: The parent Process MD5
    - contextPath: Process.Children.CommandLine
      description: The children Process CommandLine
    - contextPath: Process.Hostname
      description: Process Hostname
    - contextPath: Process.Parent.CbSegmentID
      description: The parent Cb 'segment' where this process instance is stored.
        Required to fetch further info on a process.
    - contextPath: Process.CbID
      description: Cb unique ID for this process instance - required (together with
        CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Siblings.CbSegmentID
      description: The sibling Cb 'segment' where this process instance is stored.
        Required to fetch further info on a process.
    - contextPath: Process.Children.Name
      description: The children Process Name
    - contextPath: Process.Parent.Name
      description: The parent Process Name
    - contextPath: Process.Siblings.Hostname
      description: The sibling Process Hostname
    - contextPath: Process.Parent.Path
      description: The parent Process Path
    - contextPath: Process.Children.Hostname
      description: The children Process Hostname
    - contextPath: Process.PID
      description: Process PID
    - contextPath: Process.Children.CbSegmentID
      description: The children Cb 'segment' where this process instance is stored.
        Required to fetch further info on a process.
    - contextPath: Process.Children.CbID
      description: The children Cb unique ID for this process instance - required
        (together with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Path
      description: Process Path
    - contextPath: Process.Parent.PID
      description: The parent Process PID
    - contextPath: Process.Children.Path
      description: The children Process Path
    - contextPath: Process.Name
      description: Process Name
    - contextPath: Process.Children.PID
      description: The children Process PID
    - contextPath: Process.Parent.CbID
      description: The parent Cb unique ID for this process instance - required (together
        with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.CommandLine
      description: Process CommandLine
    - contextPath: Process.Siblings.CommandLine
      description: The sibling Process CommandLine
    - contextPath: Process.Siblings.Name
      description: The sibling Process Name
    - contextPath: Process.Parent.CommandLine
      description: The parent Process CommandLine
    - contextPath: Process.Parent.Hostname
      description: The parent Process Hostname
    - contextPath: Process.MD5
      description: Process MD5
    - contextPath: Process.Children.MD5
      description: The children Process MD5
    - contextPath: Process.Siblings.CbID
      description: The sibling Cb unique ID for this process instance - required (together
        with CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Siblings.Path
      description: The sibling Process Path
    - contextPath: Process.Siblings.PID
      description: The sibling Process PID
    - contextPath: Process.StartTime
      description: Start time of the process.
      type: date
  - arguments:
    - description: Filter processes by name
      name: name
    - description: Filter processes by group
      name: group
    - description: Filter processes by hostname
      name: hostname
    - description: Filter processes by parent process name
      name: parent-process-name
    - description: 'Filter processes by process path (Example: "c:\windows\resources\spoolsv.exe")'
      name: process-path
    - description: Filter processes by md5 hash
      name: md5
    - default: true
      description: Query string. Accepts the same data as the search box on the Binary
        Search page. See https://github.com/carbonblack/cbapi/blob/master/client_apis/docs/query_overview.pdf
      name: query
    - description: Return this many rows, 10 by default.
      name: rows
    - description: Start at this row, 0 by default.
      name: start
    - description: Sort rows by this field and order. server_added_timestamp desc
        by default.
      name: sort
    - description: Return facet results. 'false' by default, set to 'true' for facets.
      name: facet
    description: Query processes based on given parameters
    name: cb-get-processes
    outputs:
    - contextPath: File.Name
      description: File Name
    - contextPath: File.MD5
      description: File MD5
    - contextPath: File.Path
      description: File Path
    - contextPath: Endpoint.Hostname
      description: Endpoint Hostname
    - contextPath: Process.CommandLine
      description: Process  Commandline
    - contextPath: Process.PID
      description: Process PID
    - contextPath: Process.CbID
      description: Cb unique ID for this process instance - required (together with
        CbSegmentID) to fetch further info on a process.
    - contextPath: Process.CbSegmentId
      description: Cb "segment" where this process instance is stored. Required to
        fetch further info on a process.
    - contextPath: Process.Parent.PID
      description: Process Parent PID
    - contextPath: Process.Parent.Name
      description: Process Parent Name
    - contextPath: Process.StartTime
      description: Start time of the process.
      type: date
  - arguments: []
    description: List the CarbonBlack sensors
    name: cb-list-sensors
    outputs:
    - contextPath: CbResponse.Sensors.Status
      description: Sensor Status
    - contextPath: CbResponse.Sensors.LastUpdate
      description: Sensor Last Updated
    - contextPath: CbResponse.Sensors.Uptime
      description: The Sensor uptime
    - contextPath: CbResponse.Sensors.SupportsCbLive
      description: Sensor Support CB Live
    - contextPath: CbResponse.Sensors.Notes
      description: Sensor Notes
    - contextPath: CbResponse.Sensors.Hostname
      description: Hostname
    - contextPath: CbResponse.Sensors.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sensors.Isolated
      description: Sensor Isolated
    - contextPath: CbResponse.Sensors.IPAddresses
      description: Sensor IP Addresses
    - contextPath: CbResponse.Sensors.OS
      description: Sensor OS
    - contextPath: Endpoint.Hostname
      description: Sensor Hostname
    - contextPath: Endpoint.OS
      description: Sensor OS
    - contextPath: Endpoint.IPAddresses
      description: Sensor IP Addresses
  - arguments:
    - description: the internal CB process id; this is the id field in search results
      name: pid
      required: true
    - description: the process segment id; this is the segment_id field in search
        results.
      name: segid
      required: true
    description: Retrieve all process events for a given process segmented by segment
      ID
    name: cb-process-events
    outputs:
    - contextPath: Process.CrossProc.OtherProcessMD5
      description: Other process MD5
    - contextPath: Process.MD5
      description: Process MD5
    - contextPath: Process.Modules.MD5
      description: Module MD5
    - contextPath: Process.CommandLine
      description: Process CommandLine
    - contextPath: Process.Registry.RegistryPath
      description: Registry path
    - contextPath: Process.Path
      description: Process Path
    - contextPath: Process.CbID
      description: Cb unique ID for this process instance - required (together with
        CbSegmentID) to fetch further info on a process.
    - contextPath: Process.Parent.Name
      description: The parent Process Name
    - contextPath: Process.Hostname
      description: Process Hostname
    - contextPath: Process.Binaries.DigSig.Publisher
      description: The publisher of the Digital Signature
    - contextPath: Process.CrossProc.Action
      description: Cross process action
    - contextPath: Process.CrossProc.OtherProcessCbID
      description: Other process CbID
    - contextPath: Process.CbSegmentID
      description: Cb 'segment' where this process instance is stored. Required to
        fetch further info on a process.
    - contextPath: Process.Name
      description: Process Name
    - contextPath: Process.CrossProc.Time
      description: Time of action
    - contextPath: Process.PID
      description: Process PID
    - contextPath: Process.Modules.Filepath
      description: Module path
    - contextPath: Process.Binaries.DigSig.Result
      description: Cb's decision after checking this binary's Digital Signature
    - contextPath: Process.Parent.PID
      description: The parent Process PID
    - contextPath: Process.Binaries.MD5
      description: Binary MD5
    - contextPath: Process.CrossProc.OtherProcessBinary
      description: Other process binary
    - contextPath: Process.Registry.Time
      description: Registry time
    - contextPath: Process.Modules.Time
      description: Module time
  - arguments:
    - default: true
      description: the sensor ID to quarantine
      name: sensor
      required: true
    description: Isolate the endpoint from the network
    important:
    - contextPath: Endpoint(val.LastAction)
      description: Endpoint Actions
      related: ''
    name: cb-quarantine-device
    outputs:
    - contextPath: Endpoint.LastAction
      description: Endpoint Actions
  - arguments:
    - default: true
      description: the sensor id
      name: sensor
    - description: returns the sensor registration(s) with specified IP address
      name: ip
    - description: returns the sensor registration(s) with matching hostname
      name: hostname
    - description: returns the sensor registration(s) in the specified sensor group
        id
      name: groupid
    description: Display information about the given sensor
    name: cb-sensor-info
    outputs:
    - contextPath: CbResponse.Sensors.Status
      description: Sensor Status
    - contextPath: CbResponse.Sensors.LastUpdate
      description: Sensor Last Updated
    - contextPath: CbResponse.Sensors.Uptime
      description: The Sensor uptime
    - contextPath: CbResponse.Sensors.SupportsCbLive
      description: Sensor Support CB Live
    - contextPath: CbResponse.Sensors.Notes
      description: Sensor Notes
    - contextPath: CbResponse.Sensors.Hostname
      description: Sensor Hostname
    - contextPath: CbResponse.Sensors.CbSensorID
      description: Sensor ID
    - contextPath: CbResponse.Sensors.Isolated
      description: Sensor Isolated
    - contextPath: CbResponse.Sensors.IPAddresses
      description: Sensor IP Addresses
    - contextPath: CbResponse.Sensors.OS
      description: Sensor OS
  - arguments:
    - description: the blacklisted hash
      name: md5hash
      required: true
    - description: text description of blacklist
      name: text
      required: true
    description: Unblocking hash
    important:
    - contextPath: File(val.LastAction)
      description: File Actions
      related: ''
    name: cb-unblock-hash
    outputs:
    - contextPath: File.LastAction
      description: Last action taken on this file
  - arguments:
    - default: true
      description: the sensor ID to quarantine
      name: sensor
      required: true
    description: Unquarantine the endpoint
    important:
    - contextPath: Endpoint(val.LastAction)
      description: Endpoint Actions
      related: ''
    name: cb-unquarantine-device
    outputs:
    - contextPath: Endpoint.LastAction
      description: Endpoint Actions
  - arguments: []
    description: Display the CarbonBlack version
    name: cb-version
  - arguments:
    - description: Watchlist ID
      name: watchlist-id
      required: true
    description: Delete a watchlist in Carbon black Response.
    name: cb-watchlist-del
  - arguments:
    - default: true
      description: Watchlist ID
      name: watchlist-id
    description: Retrieve info for a watchlist in Carbon black Response.
    name: cb-watchlist-get
    outputs:
    - contextPath: CbResponse.Watchlists.LastHit
      description: Watchlist last hit
    - contextPath: CbResponse.Watchlists.TotalHits
      description: Watchlist Total hits
    - contextPath: CbResponse.Watchlists.SearchQuery
      description: Cb search query used for the watchlist.
    - contextPath: CbResponse.Watchlists.Name
      description: Watchlist Name
    - contextPath: CbResponse.Watchlists.Enabled
      description: Watchlist is enabled
    - contextPath: CbResponse.Watchlists.LastHitCount
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.DateAdded
      description: Watchlist Date added
    - contextPath: CbResponse.Watchlists.SearchTimestamp
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.CbWatchlistID
      description: Watchlist ID
  - arguments:
    - description: the raw Carbon Black query that this watchlist matches
      name: search-query
      required: true
    - description: name of this watchlist
      name: name
      required: true
    description: Create a new watchlist in Carbon black Response.
    name: cb-watchlist-new
    outputs:
    - contextPath: CbResponse.Watchlists.LastHit
      description: Watchlist last hit
    - contextPath: CbResponse.Watchlists.TotalHits
      description: Watchlist Total hits
    - contextPath: CbResponse.Watchlists.SearchQuery
      description: Cb search query used for the watchlist.
    - contextPath: CbResponse.Watchlists.Name
      description: Watchlist Name
    - contextPath: CbResponse.Watchlists.Enabled
      description: Watchlist is enabled
    - contextPath: CbResponse.Watchlists.LastHitCount
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.DateAdded
      description: Watchlist Date added
    - contextPath: CbResponse.Watchlists.SearchTimestamp
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.CbWatchlistID
      description: Watchlist ID
  - arguments:
    - description: Watchlist ID
      name: watchlist-id
      required: true
    - description: the raw Carbon Black query that this watchlist matches
      name: search-query
    - description: name of this watchlist
      name: name
    - description: the type of watchlist. Valid values are 'modules' and 'events'
        for binary and process watchlists, respectively
      name: indexType
    description: Modify a watchlist in Carbon black Response.
    name: cb-watchlist-set
  - arguments:
    - description: Alert unique identifier
      name: uniqueId
      required: true
    - auto: PREDEFINED
      description: 'Updated alert''s status: Resolved,Unresolved,In Progress or False
        Positive'
      name: status
      predefined:
      - Resolved
      - Unresolved
      - In Progress
      - False Positive
      required: true
    - auto: PREDEFINED
      description: Whether to stop showing this type of alert
      name: setIgnored
      predefined:
      - 'true'
      - 'false'
    description: Alert update and resolution
    name: cb-alert-update
  - arguments: []
    description: Retrieve watchlist in Carbon black Response.
    name: cb-watchlist
    outputs:
    - contextPath: CbResponse.Watchlists.LastHit
      description: Watchlist last hit
    - contextPath: CbResponse.Watchlists.TotalHits
      description: Watchlist Total hits
    - contextPath: CbResponse.Watchlists.SearchQuery
      description: Cb search query used for the watchlist.
    - contextPath: CbResponse.Watchlists.Name
      description: Watchlist Name
    - contextPath: CbResponse.Watchlists.Enabled
      description: Watchlist is enabled
    - contextPath: CbResponse.Watchlists.LastHitCount
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.DateAdded
      description: Watchlist Date added
    - contextPath: CbResponse.Watchlists.SearchTimestamp
      description: Watchlist last hit count
    - contextPath: CbResponse.Watchlists.CbWatchlistID
      description: Watchlist ID
  - arguments:
    - default: true
      description: MD5 hash of the file.
      name: md5
      required: true
    - auto: PREDEFINED
      description: Whether to include the summary.
      name: summary
      predefined:
      - 'yes'
      - 'no'
    description: Retrieve a binary from CarbonBlack based on hash. Returns a .zip
      file containing the requested file and it's metadata.
    name: cb-binary-download
    outputs:
    - contextPath: File.DigSig.Publisher
      description: The publisher of the digital signature.
    - contextPath: File.InternalName
      description: The internal name.
    - contextPath: File.ServerAddedTimestamp
      description: The timestamp when the server was added.
    - contextPath: File.Name
      description: The binary name.
    - contextPath: File.Extension
      description: The binary extension.
    - contextPath: File.Timestamp
      description: The binary timestamp.
    - contextPath: File.Hostname
      description: The binary hostname.
    - contextPath: File.Description
      description: The binary description.
    - contextPath: File.DigSig.Result
      description: The Carbon Black decision after checking this binary's digital
        signature.
    - contextPath: File.LastSeen
      description: LThe lst time the binary was seen.
    - contextPath: File.Path
      description: The binary path.
    - contextPath: File.ProductName
      description: The product name.
    - contextPath: File.OS
      description: The OS.
    - contextPath: File.MD5
      description: The MD5 hash of the binary.
    - contextPath: File.Company
      description: Name of the company that released a binary.
    - contextPath: File.DigitalSignature.Publisher
      description: Publisher of the digital signature for the file.
    - contextPath: File.Name
      description: Full filename, for example data.xls.
    - contextPath: File.Signature.OriginalName
      description: The file's original name.
    - contextPath: File.Signature.InternalName
      description: The file's internal name.
    - contextPath: File.Signature.FileVersion
      description: The file version.
    - contextPath: File.Signature.Description
      description: The description of the signature.
  dockerimage: demisto/python:2.7.18.8715
  isfetch: true
  runonce: false
  script: "\"use strict\";\n\n/// Base Functions\n\nfunction sendRequest(path, method,\
    \ requestParams, headers, ignoredStatusCodes) {\n    let baseUrl = params.serverurl\
    \ + '/api';\n\n    if (!headers) {\n        headers = {};\n    }\n    if (!headers['X-Auth-Token'])\
    \ {\n        headers['X-Auth-Token'] = [params.apitoken];\n    }\n    if (!headers['Accept'])\
    \ {\n        headers['Accept'] = ['application/json'];\n    }\n    if (!headers['Content-Type'])\
    \ {\n        headers['Content-Type'] = ['application/json'];\n    }\n\n    let\
    \ request = {\n        Method: method,\n        Headers: headers\n    };\n   \
    \ let querystring = '';\n    if (requestParams) {\n        if (typeof requestParams\
    \ === 'string') {\n            querystring = requestParams;\n        } else {\n\
    \            request.Body = JSON.stringify(requestParams);\n        }\n    }\n\
    \n    //logInfo(\"Request:\\n\" + JSON.stringify({path: path + querystring, req:\
    \ request}));\n\n    let result = http(baseUrl + path + querystring, request,\
    \ params.insecure, params.proxy);\n\n    if (!ignoredStatusCodes || ignoredStatusCodes.indexOf(result.StatusCode)\
    \ === -1) {\n        if (result.StatusCode < 200 || result.StatusCode >= 300)\
    \ {\n            if (result.StatusCode === 404) {\n                throw 'Cannot\
    \ find the requested resource (Status Code: 404)';\n            }\n          \
    \  throw `Request Failed.\\nStatus code: ${result.StatusCode}.\\nMessage: ${JSON.stringify(result.Body)}`;\n\
    \        }\n    }\n\n    //logInfo(\"Body:\\n\" + result.Body);\n\n    return\
    \ result;\n}\n\n/// Commands\n\nfunction testModule() {\n    let res = sendRequest('/v1/license',\
    \ 'GET');\n    if (res.StatusCode === 200) {\n        return 'ok';\n    }\n  \
    \  return `Test failed. Status Code: ${res.StatusCode}`\n}\n\nfunction getSensorByIdRequest(sensorId)\
    \ {\n    let response = sendRequest(`/v1/sensor/${sensorId}`, 'GET');\n    try\
    \ {\n        return JSON.parse(response.Body);\n    } catch (err) {\n        throw\
    \ `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction quarantineSensorRequest(sensorId, sensorDetails) {\n   \
    \ return sendRequest(`/v1/sensor/${sensorId}`, 'PUT', sensorDetails);\n}\n\nfunction\
    \ quarantineDevice(doQuarantine) {\n    let result = getSensorByIdRequest(args.sensor);\n\
    \    result.network_isolation_enabled = doQuarantine;\n    result = quarantineSensorRequest(args.sensor,\
    \ result);\n    if (result.StatusCode === 204) {\n        let quarantinedStr =\
    \ (doQuarantine) ? 'quarantined' : 'unquarantined';\n        return {\n      \
    \      Type: entryTypes.note,\n            Contents: {success: true},\n      \
    \      ContentsType: formats.json,\n            ReadableContentsFormat: formats.markdown,\n\
    \            HumanReadable: \"Success: \" + quarantinedStr + \" sensor \" + args.sensor,\n\
    \            EntryContext: {\n                \"Endpoint(val.CbSensorID == obj.CbSensorID)\"\
    : {\n                    \"CbSensorID\": args.sensor,\n                    \"\
    LastAction\": (doQuarantine) ? \"Blocked\" : \"Unblocked\"\n                }\n\
    \            }\n        }\n    } else {\n        throw result.Body;\n    }\n}\n\
    \nfunction getAlertsRequest(query, rows, start, sort, facets) {\n    let queryParams\
    \ = {};\n    if (query) {\n        queryParams.q = query;\n    }\n    if (rows)\
    \ {\n        queryParams.rows = rows;\n    }\n    if (start) {\n        queryParams.start\
    \ = start;\n    }\n    if (sort) {\n        queryParams.sort = sort;\n    }\n\
    \    if (facets) {\n        queryParams.facets = facets;\n    }\n    let response\
    \ = sendRequest('/v2/alert', 'GET', encodeToURLQuery(queryParams));\n    try {\n\
    \        return JSON.parse(response.Body).results;\n    } catch (err) {\n    \
    \    throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction fetchIncidents() {\n    let lastRun = getLastRun();\n\n\
    \    let fetchAlertsSeverityThreshold = (args['fetchAlertsSeverityThreshold'])\
    \ ? args['fetchAlertsSeverityThreshold'] : 0;\n    let defaultRunTime = (new Date().getTime())\
    \ - (24 * 60 * 60 * 1000); // Decrease one day if it's the first run, to get some\
    \ alerts.\n    let defaultRunTimeStr = unixToString(defaultRunTime);\n    let\
    \ lastRunStr = (lastRun.time) ? unixToString(lastRun.time + 1000) : defaultRunTimeStr;\n\
    \    let result = getAlertsRequest(`alert_severity:[${fetchAlertsSeverityThreshold}\
    \ TO *] and created_time:[${lastRunStr} TO *]`, params.rows);\n\n    let latestTime\
    \ = 0;\n    let incidents = result.map(curAlert => {\n        let createdTime\
    \ = stringToUnix(curAlert['created_time']);\n        latestTime = Math.max(latestTime,\
    \ createdTime);  // Save latest time from current fetch to query\n        return\
    \ {\n            name: curAlert['description'] + ' : ' + curAlert['created_time'],\n\
    \            occurred: curAlert['created_time'],\n            rawJSON: JSON.stringify(curAlert),\n\
    \        };\n    });\n\n    if (incidents.length > 0) {\n        logInfo('Ingested\
    \ ' + incidents.length + ' alerts into incidents');\n        setLastRun({'time':\
    \ latestTime});  // Update last run\n    }\n\n    return JSON.stringify(incidents);\n\
    }\n\nfunction version() {\n    let response = sendRequest('/v1/builds', 'GET');\n\
    \    let result;\n    try {\n        result = JSON.parse(response.Body);\n   \
    \ } catch (err) {\n        throw `Could not parse response.\\nError: ${err}.\\\
    nResponse: ${response.Body}`;\n    }\n    return {\n        Type: entryTypes.note,\n\
    \        Contents: result,\n        ContentsType: formats.json\n    };\n}\n\n\
    function showAlerts() {\n    let query = '';\n    if (args.query) {\n        query\
    \ = '(' + args.query + ')';\n    }\n    if (args.status) {\n        query += '\
    \ AND status:' + args.status;\n    }\n    if (args.username) {\n        query\
    \ += ' AND username:' + args.username;\n    }\n    if (args.hostname) {\n    \
    \    query += ' AND hostname:' + args.hostname;\n    }\n    if (args.feedname)\
    \ {\n        query += ' AND feed_name:' + args.feedname;\n    }\n    if (args.report)\
    \ {\n        query += ' AND watchlist_id:' + args.report;\n    }\n    let alerts\
    \ = getAlertsRequest(query, args.rows, args.start, args.sort, args.facets);\n\n\
    \    let title = 'CB Response - Show Alerts';\n    let changeNames = [\n     \
    \   {from: 'unique_id', to: 'CbAlertID'},\n        {from: 'process_path', to:\
    \ 'ProcessPath'},\n        {from: 'hostname', to: 'Hostname'},\n        {from:\
    \ 'interface_ip', to: 'InterfaceIP'},\n        {from: 'comms_ip', to: 'CommsIP'},\n\
    \        {from: 'md5', to: 'MD5'},\n        {from: 'description', to: 'Description'},\n\
    \        {from: 'feed_name', to: 'FeedName'},\n        {from: 'alert_severity',\
    \ to: 'Severity'},\n        {from: 'created_time', to: 'Time'},\n        {from:\
    \ 'status', to: 'Status'}\n    ];\n    let headers = changeNames.map(cn => cn.to);\n\
    \    let translatedData = mapObjFunction(changeNames)(alerts);\n    let humanReadable\
    \ = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);\n\
    \    let context = {\n        'CbResponse.Alerts(val.CbAlertID==obj.CbAlertID)':\
    \ createContext(translatedData)\n    };\n    return {\n        Type: entryTypes.note,\n\
    \        Contents: alerts,\n        ContentsType: formats.json,\n        ReadableContentsFormat:\
    \ formats.markdown,\n        HumanReadable: humanReadable,\n        EntryContext:\
    \ context\n    };\n}\n\nfunction updateAlertRequest(alertUniqueId, status, setIgnored)\
    \ {\n    let queryParams = {};\n    if (alertUniqueId) {\n        queryParams.alert_ids\
    \ = [alertUniqueId];\n    }\n    if (status) {\n        queryParams.requested_status\
    \ = status;\n    }\n    if (setIgnored) {\n        queryParams.set_ignored = setIgnored;\n\
    \    }\n    let response = sendRequest('/v1/alerts', 'POST', queryParams).Body;\n\
    \    try {\n        return JSON.parse(response);\n    } catch (err) {\n      \
    \  throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response}`;\n\
    \    }\n}\n\nfunction updateAlert() {\n    let response = updateAlertRequest(args.uniqueId,\
    \ args.status, args.setIgnored);\n    if (response.result && response.result ===\
    \ 'success') {\n        return {\n            Type: entryTypes.note,\n       \
    \     Contents: response,\n            ContentsType: formats.json,\n         \
    \   ReadableContentsFormat: formats.markdown,\n            HumanReadable: 'Alert\
    \ updated successfully'\n        }\n    } else {\n        throw `Command failed.\\\
    nOutput: ${JSON.stringify(response)}`;\n    }\n}\n\nconst processData = [\n  \
    \  {from: 'process_name', to: 'Name'},\n    {from: 'hostname', to: 'Endpoint'},\n\
    \    {from: 'last_update', to: 'Update'},\n    {from: 'start', to: 'Start Time'},\n\
    \    {from: 'process_pid', to: 'PID'},\n    {from: 'username', to: 'Username'},\n\
    \    {from: 'process_md5', to: 'MD5'},\n    {from: 'cmdline', to: 'CommandLine'},\n\
    \    {from: 'path', to: 'Path'},\n    {from: 'id', to: 'CbID'},\n    {from: 'segment_id',\
    \ to: 'CbSegmentID'},\n    {from: 'group', to: 'Group'},\n    {from: 'start',\
    \ to: 'StartTime'}\n];\n\nconst processDataForFileContext = [\n    {from: 'process_name',\
    \ to: 'Name'},\n    {from: 'process_md5', to: 'MD5'},\n    {from: 'path', to:\
    \ 'Path'}\n];\n\nconst processDataForEndpointContext = [\n  {from: 'hostname',\
    \ to: 'Hostname'}\n];\n\nfunction getProcessesRequest(query, rows, start, sort,\
    \ facets) {\n    let queryParams = {};\n    if (query) {\n        queryParams.q\
    \ = query;\n    }\n    if (rows) {\n        queryParams.rows = rows;\n    }\n\
    \    if (start) {\n        queryParams.start = start;\n    }\n    if (sort) {\n\
    \        queryParams.sort = sort;\n    }\n    if (facets) {\n        queryParams.facets\
    \ = facets;\n    }\n    let response = sendRequest('/v1/process', 'GET', encodeToURLQuery(queryParams));\n\
    \    try {\n        return JSON.parse(response.Body).results;\n    } catch (err)\
    \ {\n        throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction getProcesses() {\n    let query = '';\n    if (args.query)\
    \ {\n        query = '(' + args.query + ')';\n    }\n    if (args.name) {\n  \
    \      query += ' AND process_name:' + args.name\n    }\n    if (args.group) {\n\
    \        query += ' AND group:' + args.group;\n    }\n    if (args.hostname) {\n\
    \        query += ' AND hostname:' + args.hostname;\n    }\n    if (args['parent-process-name'])\
    \ {\n        query += ' AND parent_name:' + args['parent-process-name'];\n   \
    \ }\n    if (args['process-path']) {\n        query += ' AND path:' + args['process-path'];\n\
    \    }\n    if (args.md5) {\n        query += ' AND md5:' + args.md5;\n    }\n\
    \    let processes = getProcessesRequest(query, args.rows, args.start, args.sort,\
    \ args.facets);\n    let title = 'CB Response - Get Processes';\n    let processDataMap\
    \ = processData;\n    let fileDataMap = processDataForFileContext;\n    let endpointDataMap\
    \ = processDataForEndpointContext;\n    let headers = processDataMap.map(cn =>\
    \ cn.to);\n    let processTranslatedData = mapObjFunction(processDataMap)(processes);\n\
    \    let fileTranslatedData = mapObjFunction(fileDataMap)(processes);\n    let\
    \ endpointTranslatedData = mapObjFunction(endpointDataMap)(processes);\n    let\
    \ humanReadable = tableToMarkdown(title, processTranslatedData, headers, undefined,\
    \ dotToSpace);\n    let context = {\n        'Process(val.CbID==obj.CbID)': createContext(processTranslatedData),\n\
    \        'File(val.MD5==obj.MD5)': createContext(fileTranslatedData),\n      \
    \  'Endpoint(val.Hostname==obj.Hostname)': createContext(endpointTranslatedData)\n\
    \    };\n    return {\n        Type: entryTypes.note,\n        Contents: processes,\n\
    \        ContentsType: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        HumanReadable: humanReadable,\n        EntryContext: context,\n    };\n\
    }\n\nfunction getProcessRequest(processId, segmentId) {\n    let response = sendRequest(`/v2/process/${processId}/${segmentId}`,\
    \ 'GET');\n    try {\n        return JSON.parse(response.Body);\n    } catch (err)\
    \ {\n        throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction getFullProcessRequest(processId, segmentId) {\n    let response\
    \ = sendRequest(`/v1/process/${processId}/${segmentId}`, 'GET');\n    try {\n\
    \        return JSON.parse(response.Body);\n    } catch (err) {\n        throw\
    \ `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction getProcess() {\n    let entries = [];\n    let title = 'CB\
    \ Response - Process';\n    let dataMap = processData;\n    let headers = dataMap.map(cn\
    \ => cn.to);\n    let result;\n    let processTranslatedData;\n    let context;\n\
    \n    if (args.get_related === 'true') {\n        result = getFullProcessRequest(args.pid,\
    \ args.segid)\n        processTranslatedData = mapObjFunction(dataMap)(result.process);\n\
    \        let parentProcessTranslatedData = mapObjFunction(dataMap)(result.parent);\n\
    \        let siblingsProcessTranslatedData = [];\n        for (var i = 0; i <\
    \ result.siblings.length; i++) {\n            siblingsProcessTranslatedData.push(mapObjFunction(dataMap)(result.siblings[i]));\n\
    \        }\n        let childrenProcessTranslatedData = []\n        for (var i\
    \ = 0; i < result.children.length; i++) {\n            childrenProcessTranslatedData.push(mapObjFunction(dataMap)(result.children[i]));\n\
    \        }\n        context = processTranslatedData;\n        context.Siblings\
    \ = siblingsProcessTranslatedData\n        context.Parent = parentProcessTranslatedData\n\
    \        context.Children = childrenProcessTranslatedData\n    } else {\n    \
    \    result = getProcessRequest(args.pid, args.segid);\n        processTranslatedData\
    \ = mapObjFunction(dataMap)(result);\n        context = processTranslatedData;\n\
    \    }\n    let humanReadable = tableToMarkdown(title, processTranslatedData,\
    \ headers, undefined, dotToSpace);\n    entries.push({\n        Type: entryTypes.note,\n\
    \        Contents: result.process,\n        ContentsType: formats.json,\n    \
    \    ReadableContentsFormat: formats.markdown,\n        HumanReadable: humanReadable\n\
    \    });\n\n    entries[0].EntryContext = {\n        'Process(val.CbID==obj.CbID)':\
    \ createContext(context)\n    };\n\n    return entries;\n}\n\nfunction getProcessEventsRequest(processId,\
    \ segmentId) {\n    let response = sendRequest(`/v1/process/${processId}/${segmentId}/event`,\
    \ 'GET');\n    try {\n        return JSON.parse(response.Body);\n    } catch (err)\
    \ {\n        throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction getProcessEvents() {\n    let result = getProcessEventsRequest(args.pid,\
    \ args.segid);\n\n    let entries = [];\n\n    let title = 'CB Response - Process\
    \ Event';\n    let dataMap = processData;\n    let headers = dataMap.map(cn =>\
    \ cn.to);\n    let translatedData = mapObjFunction(dataMap)(result.process);\n\
    \    let humanReadable = tableToMarkdown(title, translatedData, headers, undefined,\
    \ dotToSpace);\n    let contextData = translatedData;\n    entries.push({\n  \
    \      Type: entryTypes.note,\n        Contents: result.process,\n        ContentsType:\
    \ formats.json,\n        ReadableContentsFormat: formats.markdown,\n        HumanReadable:\
    \ humanReadable\n    });\n\n    title = 'Cross Process';\n    let crossProcDataMap\
    \ = [\n        {to: 'Action', from: \".=(val.split('|')[0])\"},\n        {to:\
    \ 'Time', from: \".=(val.split('|')[1])\"},\n        {to: 'OtherProcessCbID',\
    \ from: \".=(val.split('|')[2])\"},\n        {to: 'OtherProcessMD5', from: \"\
    .=(val.split('|')[3])\"},\n        {to: 'OtherProcessBinary', from: \".=(val.split('|')[4])\"\
    }\n    ];\n    headers = crossProcDataMap.map(cn => cn.to);\n    translatedData\
    \ = [];\n    if ('process' in result) {\n      if (result.process.crossproc_complete)\
    \ {\n        translatedData = mapObjFunction(crossProcDataMap)(result.process.crossproc_complete);\n\
    \      }\n    }\n    humanReadable = tableToMarkdown(title, translatedData, headers,\
    \ undefined, dotToSpace);\n    contextData['CrossProc'] = translatedData;\n  \
    \  entries.push({\n        Type: entryTypes.note,\n        Contents: result.process.crossproc_complete,\n\
    \        ContentsType: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        HumanReadable: humanReadable\n    });\n\n    title = 'Modules';\n   \
    \ let modulesDataMap = [\n        {to: 'Time', from: \".=(val.split('|')[0])\"\
    },\n        {to: 'MD5', from: \".=(val.split('|')[1])\"},\n        {to: 'Filepath',\
    \ from: \".=(val.split('|')[2])\"}\n    ];\n    headers = modulesDataMap.map(cn\
    \ => cn.to);\n    let modulesResult = dq(result, 'process.modload_complete(val.MD5==obj.MD5)');\n\
    \    translatedData = mapObjFunction(modulesDataMap)(modulesResult);\n    humanReadable\
    \ = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);\n\
    \    contextData['Modules'] = translatedData;\n    entries.push({\n        Type:\
    \ entryTypes.note,\n        Contents: modulesResult,\n        ContentsType: formats.json,\n\
    \        ReadableContentsFormat: formats.markdown,\n        HumanReadable: humanReadable\n\
    \    });\n\n    title = 'Registry';\n    let registryDataMap = [\n        {to:\
    \ 'Time', from: \".=(val.split('|')[1])\"},\n        {to: 'RegistryPath', from:\
    \ \".=(val.split('|')[2])\"}\n    ];\n    headers = registryDataMap.map(cn =>\
    \ cn.to);\n    translatedData = [];\n    if ('process' in result) {\n      if\
    \ (result.process.regmod_complete) {\n        translatedData = mapObjFunction(registryDataMap)(result.process.regmod_complete);\n\
    \      }\n    }\n    humanReadable = tableToMarkdown(title, translatedData, headers,\
    \ undefined, dotToSpace);\n    contextData['Registry'] = translatedData;\n   \
    \ entries.push({\n        Type: entryTypes.note,\n        Contents: result.process.regmod_complete,\n\
    \        ContentsType: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        HumanReadable: humanReadable\n    });\n\n    title = 'Binaries';\n  \
    \  headers = ['MD5', 'Publisher', 'Result'];\n    translatedData = [];\n    if\
    \ ('process' in result) {\n      if (result.process.binaries) {\n        let keys\
    \ = Object.keys(result.process.binaries);\n        translatedData = keys.map(md5\
    \ => ({\n            'MD5': md5,\n            'Publisher': result.process.binaries[md5]['digsig_publisher'],\n\
    \            'Result': result.process.binaries[md5]['digsig_result']\n       \
    \ }));\n      }\n    }\n    humanReadable = tableToMarkdown(title, translatedData,\
    \ headers, undefined, dotToSpace);\n    contextData['Binaries'] = translatedData.map(binary\
    \ => ({\n        'MD5': binary.MD5,\n        'DigSig.Publisher': binary['Publisher'],\n\
    \        'DigSig.Result': binary['Result']\n    }));\n    entries.push({\n   \
    \     Type: entryTypes.note,\n        Contents: result.process.binaries,\n   \
    \     ContentsType: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        HumanReadable: humanReadable\n    });\n\n    entries[0].EntryContext\
    \ = {\n        'Process(val.CbID==obj.CbID)': createContext(contextData)\n   \
    \ };\n\n    return entries;\n}\n\nconst binaryData = [\n    {to: 'Name', from:\
    \ 'original_filename'},\n    {to: 'MD5', from: 'md5'},\n    {to: 'Timestamp',\
    \ from: 'timestamp'},\n    {\n        to: 'Extension',\n        from: '.=(val.original_filename.indexOf(\"\
    .\")>=0 ? val.original_filename.split(\".\")[1] : \"\")'\n    },\n    {to: 'Hostname',\
    \ from: \"endpoint\"},\n    {to: 'Path', from: 'observed_filename'},\n    {to:\
    \ 'LastSeen', from: 'last_seen'},\n    {to: 'ServerAddedTimestamp', from: 'server_added_timestamp'},\n\
    \    {to: 'Description', from: 'file_desc'},\n    {to: 'InternalName', from: 'internal_name'},\n\
    \    {to: 'ProductName', from: 'product_name'},\n    {to: 'OS', from: 'os_type'},\n\
    \    {to: 'DigSig.Result', from: 'digsig_result'},\n    {to: 'DigSig.Publisher',\
    \ from: 'digsig_publisher'},\n    {to: 'Company', from: 'company_name'},\n   \
    \ {to: 'DigitalSignature.Publisher', from: 'digsig_publisher'},\n    {to: 'Name',\
    \ from: 'original_filename'},\n    {to: 'Signature.OriginalName', from: 'original_filename'},\n\
    \    {to: 'Signature.InternalName', from: 'internal_name'},\n    {to: 'Signature.FileVersion',\
    \ from: 'file_version'},\n    {to: 'Signature.Description', from: 'file_desc'}\n\
    ];\n\nfunction getBinariesRequest(query, rows, start, sort, facets) {\n    let\
    \ queryParams = {};\n    if (query) {\n        queryParams.q = query;\n    }\n\
    \    if (rows) {\n        queryParams.rows = rows;\n    }\n    if (start) {\n\
    \        queryParams.start = start;\n    }\n    if (sort) {\n        queryParams.sort\
    \ = sort;\n    }\n    if (facets) {\n        queryParams.facets = facets;\n  \
    \  }\n    let response = sendRequest('/v1/binary', 'GET', encodeToURLQuery(queryParams));\n\
    \    try {\n        return JSON.parse(response.Body).results;\n    } catch (err)\
    \ {\n        throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction getBinaries() {\n    let query = '';\n    if (args.query)\
    \ {\n        query = '(' + args.query + ')';\n    }\n    if (args['digital-signature'])\
    \ {\n        query += ' AND digsig_result:' + args['digital-signature'];\n   \
    \ }\n    if (args['publisher']) {\n        query += ' AND digsig_publisher:' +\
    \ args['publisher'];\n    }\n    if (args['company-name']) {\n        query +=\
    \ ' AND company_name:' + args['company-name'];\n    }\n    if (args['product-name'])\
    \ {\n        query += ` AND product_name: \"${args['product-name']}\"`;\n    }\n\
    \    if (args['filepath']) {\n        query += ` AND observed_filename:\"${args['filepath']}\"\
    `;\n    }\n    if (args['group']) {\n        query += ` AND group:\"${args['group']}\"\
    `\n    }\n    if (args['hostname']) {\n        query += ` AND hostname:\"${args['hostname']}\"\
    `\n    }\n    let result = getBinariesRequest(query, args.rows, args.start, args.sort,\
    \ args.facets);\n\n    let title = 'CB Response - Get Binaries';\n    let dataMap\
    \ = binaryData;\n    let headers = dataMap.map(cn => cn.to);\n    let translatedData\
    \ = mapObjFunction(dataMap)(result);\n    // format results - \"|\" char disturbing\
    \ markdown representation\n    for (let i = 0; i < translatedData.length; i++)\
    \ {\n        let data = translatedData[i];\n        if (data['Hostname']) {\n\
    \            translatedData[i]['Hostname'] = data['Hostname'].join().replace(/\\\
    |/gi,\" \");\n        }\n    }\n    let humanReadable = tableToMarkdown(title,\
    \ translatedData, headers, undefined, dotToSpace);\n    let context = {\n    \
    \    'File(val.MD5==obj.MD5)': createContext(translatedData)\n    };\n\n    return\
    \ {\n        Type: entryTypes.note,\n        Contents: result,\n        ContentsType:\
    \ formats.json,\n        ReadableContentsFormat: formats.markdown,\n        HumanReadable:\
    \ humanReadable,\n        EntryContext: context,\n    };\n}\n\nfunction getBinarySummaryRequest(md5)\
    \ {\n    let response = sendRequest('/v1/binary/' + md5 + '/summary', 'GET');\n\
    \    try {\n        return JSON.parse(response.Body);\n    } catch (err) {\n \
    \       throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response.Body}`;\n\
    \    }\n}\n\nfunction getBinaryRequest(md5) {\n    return sendRequest('/v1/binary/'\
    \ + md5, 'GET');\n}\n\nfunction getBinary() {\n    let entries = [];\n\n    if\
    \ (args.summary && args.summary === 'yes') {\n        let result = getBinarySummaryRequest(args.md5);\n\
    \        let title = 'CB Response - Binary Summary';\n        let dataMap = binaryData;\n\
    \        let headers = dataMap.map(cn => cn.to);\n        let translatedData =\
    \ mapObjFunction(dataMap)(result);\n        let humanReadable = tableToMarkdown(title,\
    \ translatedData, headers, undefined, dotToSpace);\n        let context = {\n\
    \            'File(val.MD5==obj.MD5)': createContext(translatedData)\n       \
    \ };\n        entries.push({\n            Type: entryTypes.note,\n           \
    \ Contents: result,\n            ContentsType: formats.json,\n            ReadableContentsFormat:\
    \ formats.markdown,\n            HumanReadable: humanReadable,\n            EntryContext:\
    \ context,\n        });\n    }\n\n    let res = getBinaryRequest(args.md5);\n\
    \    let fileEntryId = saveFile(res.Bytes);\n\n    if (args.decompress && args.decompress\
    \ === 'no') {\n        return {\n            Type: entryTypes.file,\n        \
    \    FileID: fileEntryId,\n            File: 'results.zip',\n            Contents:\
    \ \"\"\n        };\n    }\n\n    else {\n        let fileEntries = decompressFile(fileEntryId);\n\
    \n        fileEntries.forEach(fileEntry => {\n            entries.push({\n   \
    \             Type: fileEntry.Type,\n                FileID: fileEntry.FileID,\n\
    \                File: fileEntry.File,\n                Contents: ''\n       \
    \     });\n        });\n    }\n\n    return entries;\n}\n\nfunction getBinaryZip()\
    \ {\n    let entries = [];\n\n    if (args.summary && args.summary === 'yes')\
    \ {\n        let result = getBinarySummaryRequest(args.md5);\n        let title\
    \ = 'CB Response - Binary Summary';\n        let dataMap = binaryData;\n     \
    \   let headers = dataMap.map(cn => cn.to);\n        let translatedData = mapObjFunction(dataMap)(result);\n\
    \        let humanReadable = tableToMarkdown(title, translatedData, headers, undefined,\
    \ dotToSpace);\n        let context = {\n            'File(val.MD5==obj.MD5)':\
    \ createContext(translatedData)\n        };\n        entries.push({\n        \
    \    Type: entryTypes.note,\n            Contents: result,\n            ContentsType:\
    \ formats.json,\n            ReadableContentsFormat: formats.markdown,\n     \
    \       HumanReadable: humanReadable,\n            EntryContext: context,\n  \
    \      });\n    }\n\n    let res = getBinaryRequest(args.md5);\n    let fileEntryId\
    \ = saveFile(res.Bytes);\n\n    return {\n        Type: entryTypes.file,\n   \
    \     FileID: fileEntryId,\n        File: 'results.zip',\n        Contents: \"\
    \"\n    };\n}\n\nfunction getSensorsRequest(sensorId, hostname, ip, groupId) {\n\
    \    let queryParams = {};\n    if (hostname) {\n        queryParams.hostname\
    \ = hostname;\n    }\n    if (ip) {\n        queryParams.ip = ip;\n    }\n   \
    \ if (groupId) {\n        queryParams.groupid = groupId;\n    }\n    let path\
    \ = '/v1/sensor';\n    if (sensorId) {\n        path += '/' + sensorId;\n    }\n\
    \    let response = sendRequest(path, 'GET', encodeToURLQuery(queryParams)).Body;\n\
    \    try {\n        return JSON.parse(response);\n    } catch (err) {\n      \
    \  throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response}`;\n\
    \    }\n}\n\nfunction getSensors() {\n    let ipAddressDQ = '.=(val.network_adapters.split(\"\
    |\").slice(0, val.network_adapters.split(\"|\").length-1))';\n    let result =\
    \ getSensorsRequest(args.sensor, args.hostname, args.ip, args.groupid);\n\n  \
    \  let entries = [];\n    let title = 'CB Response - Get Sensors';\n    let dataMap\
    \ = [\n        {to: 'CbSensorID', from: 'id'},\n        {to: 'Hostname', from:\
    \ 'computer_name'},\n        {to: 'Status', from: 'status'},\n        {to: 'IPAddresses',\
    \ from: ipAddressDQ},\n        {to: 'IPAddress', from: 'network_adapters'},\n\
    \        {to: 'Notes', from: 'notes'},\n        {to: 'Isolated', from: 'network_isolation_enabled'},\n\
    \        {to: 'OS', from: 'os_environment_display_string'},\n        {to: 'Uptime',\
    \ from: 'sensor_uptime'},\n        {to: 'LastUpdate', from: 'last_update'},\n\
    \        {to: 'SupportsCbLive', from: 'supports_cblr'}\n    ];\n    let headers\
    \ = dataMap.map(cn => cn.to);\n    let translatedData = mapObjFunction(dataMap)(result);\n\
    \    let humanReadable = tableToMarkdown(title, translatedData, headers, undefined,\
    \ dotToSpace);\n    let context = {\n        'CbResponse.Sensors(val.CbSensorID==obj.CbSensorID)':\
    \ createContext(translatedData)\n    };\n\n    entries.push({\n        Type: entryTypes.note,\n\
    \        Contents: result,\n        ContentsType: formats.json,\n        ReadableContentsFormat:\
    \ formats.markdown,\n        HumanReadable: humanReadable,\n        EntryContext:\
    \ context,\n    });\n\n    title = 'Endpoints';\n    dataMap = [\n        {to:\
    \ 'Hostname', from: 'computer_name'},\n        {to: 'OS', from: 'os_environment_display_string'},\n\
    \        {to: 'IPAddresses', from: ipAddressDQ},\n        {to: 'CbSensorID', from:\
    \ 'id'},\n    ];\n    headers = dataMap.map(cn => cn.to);\n    translatedData\
    \ = mapObjFunction(dataMap)(result);\n    humanReadable = tableToMarkdown(title,\
    \ translatedData, headers, undefined, dotToSpace);\n    context = {\n        'Endpoint':\
    \ createContext(translatedData)\n    };\n\n    entries.push({\n        Type: entryTypes.note,\n\
    \        Contents: result,\n        ContentsType: formats.json,\n        ReadableContentsFormat:\
    \ formats.markdown,\n        HumanReadable: humanReadable,\n        EntryContext:\
    \ context,\n    });\n\n    return entries;\n}\n\nfunction getHashBlacklistRequest(filter)\
    \ {\n    let queryParams = {};\n    if (filter) {\n        queryParams.filter\
    \ = filter;\n    }\n    let response = sendRequest('/v1/banning/blacklist', 'GET',\
    \ encodeToURLQuery(queryParams)).Body;\n    try {\n        if (response === '')\
    \ {\n            return [];\n        } else {\n            return JSON.parse(response);\n\
    \        }\n    } catch (err) {\n        throw `Could not parse response.\\nError:\
    \ ${err}.\\nResponse: ${response}`;\n    }\n}\n\nfunction getHashBlacklist() {\n\
    \    let result = getHashBlacklistRequest(args.filter);\n\n    let title = 'CB\
    \ Response - Hash Blacklist';\n    let dataMap = [\n        {to: 'MD5', from:\
    \ 'md5hash'},\n        {to: 'Enabled', from: 'enabled'},\n        {to: 'Description',\
    \ from: 'text'},\n        {to: 'Timestamp', from: 'timestamp'},\n        {to:\
    \ 'BlockCount', from: 'block_count'},\n        {to: 'Username', from: 'username'},\n\
    \        {to: 'LastBlock.Time', from: 'last_block_time'},\n        {to: 'LastBlock.Hostname',\
    \ from: 'last_block_hostname'},\n        {to: 'LastBlock.CbSensorID', from: 'last_block_sensor_id'}\n\
    \    ];\n    let headers = dataMap.map(cn => cn.to);\n    let translatedData =\
    \ mapObjFunction(dataMap)(result);\n    let humanReadable = tableToMarkdown(title,\
    \ translatedData, headers, undefined, dotToSpace);\n    let context = {\n    \
    \    'CbResponse.BlockedHashes(val.MD5==obj.MD5)': createContext(translatedData)\n\
    \    };\n\n    return {\n        Type: entryTypes.note,\n        Contents: result,\n\
    \        ContentsType: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        HumanReadable: humanReadable,\n        EntryContext: context,\n    };\n\
    }\n\nfunction blockHashRequest(md5, text, enabled, lastBanTime, banCount, lastBanHost)\
    \ {\n    let queryParams = {};\n    if (md5) {\n        queryParams.md5hash =\
    \ md5;\n    }\n    if (text) {\n        queryParams.text = text;\n    }\n    if\
    \ (enabled) {\n        queryParams.enabled = enabled;\n    }\n    if (lastBanTime)\
    \ {\n        queryParams.last_ban_time = lastBanTime;\n    }\n    if (banCount)\
    \ {\n        queryParams.ban_count = banCount;\n    }\n    if (lastBanHost) {\n\
    \        queryParams.last_ban_host = lastBanHost;\n    }\n    let response = sendRequest('/v1/banning/blacklist',\
    \ 'POST', queryParams);\n    try {\n        return JSON.parse(response.Body);\n\
    \    } catch (err) {\n        throw `Could not parse response.\\nError: ${err}.\\\
    nResponse: ${response.Body}`;\n    }\n}\n\nfunction unblockHashRequest(md5, text)\
    \ {\n    let queryParams = {};\n    if (text) {\n        queryParams.text = text;\n\
    \    }\n    let response = sendRequest(`/v1/banning/blacklist/${md5}`, 'DELETE',\
    \ queryParams);\n    try {\n        return JSON.parse(response.Body);\n    } catch\
    \ (err) {\n        throw `Could not parse response.\\nError: ${err}.\\nResponse:\
    \ ${response.Body}`;\n    }\n}\n\nfunction blockHash(doBlock) {\n    let result;\n\
    \n    if (doBlock) {\n        // Get banning list\n        result = getHashBlacklistRequest(`md5hash==${args.md5hash}\
    \ && enabled==true`);\n        if (result.length === 0 || isEmpty(result)) {\n\
    \            // New hash so create a block\n            result = blockHashRequest(args.md5hash,\
    \ args.text, true,\n                args.lastBanTime, args.banCount, args.lastBanHost);\n\
    \        } else {\n            // Existing hash so just update\n            result\
    \ = blockHashRequest(result[0].md5hash, result[0].text, true,\n              \
    \  result[0].lastBanTime, result[0].banCount, result[0].lastBanHost);\n      \
    \  }\n    } else {\n        result = unblockHashRequest(args.md5hash, args.text);\n\
    \    }\n\n    let blockedStr = (doBlock) ? 'blocked' : 'unblocked';\n\n    let\
    \ entry = {\n        Type: entryTypes.note,\n        Contents: result,\n     \
    \   ContentsType: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        HumanReadable: \"Failed to \" + blockedStr + \" \" + args.sensor,\n \
    \       EntryContext: {\n            \"Endpoint(val.CbSensorID == obj.CbSensorID)\"\
    : {\n                \"CbSensorID\": args.sensor,\n                \"LastAction\"\
    : (doBlock) ? \"Blocked\" : \"Unblocked\"\n            }\n        }\n    };\n\n\
    \    if (result.result === 'success') {\n        entry.HumanReadable = \"Success:\
    \ \" + blockedStr + \" \" + args['md5hash'];\n        entry.EntryContext = {\n\
    \            \"File(val.MD5 && val.MD5==obj.MD5)\": {\n                \"MD5\"\
    : args['md5hash'],\n                \"LastAction\": (doBlock) ? \"Blocked\" :\
    \ \"Unblocked\"\n            }\n        };\n    }\n\n    return entry;\n}\n\n\
    const watchlistData = [\n    {to: 'CbWatchlistID', from: 'id'},\n    {to: 'Name',\
    \ from: 'name'},\n    {to: 'SearchQuery', from: 'search_query'},\n    {to: 'Enabled',\
    \ from: 'enabled'},\n    {to: 'LastHit', from: 'last_hit'},\n    {to: 'LastHitCount',\
    \ from: 'last_hit_count'},\n    {to: 'SearchTimestamp', from: 'search_timestamp'},\n\
    \    {to: 'TotalHits', from: 'total_hits'},\n    {to: 'DateAdded', from: 'date_added'}\n\
    ];\n\nfunction getWatchlistRequest(watchlistId) {\n    let path = '/v1/watchlist';\n\
    \    if (watchlistId) {\n        path += '/' + watchlistId;\n    }\n\n    let\
    \ response = sendRequest(path, 'GET').Body;\n    try {\n        return JSON.parse(response);\n\
    \    } catch (err) {\n        throw `Could not parse response.\\nError: ${err}.\\\
    nResponse: ${response}`;\n    }\n}\n\nfunction getWatchlist() {\n    let result\
    \ = getWatchlistRequest(args['watchlist-id']);\n\n    let title = 'CB Response\
    \ - List Watchlists';\n    let dataMap = watchlistData;\n    let headers = dataMap.map(cn\
    \ => cn.to);\n    let translatedData = mapObjFunction(dataMap)(result);\n    let\
    \ humanReadable = tableToMarkdown(title, translatedData, headers, undefined, dotToSpace);\n\
    \    let context = {\n        'CbResponse.Watchlists(val.CbWatchlistID==obj.CbWatchlistID)':\
    \ createContext(translatedData)\n    };\n\n    return {\n        Type: entryTypes.note,\n\
    \        Contents: result,\n        ContentsType: formats.json,\n        ReadableContentsFormat:\
    \ formats.markdown,\n        HumanReadable: humanReadable,\n        EntryContext:\
    \ context,\n    };\n}\n\nfunction createWatchlistRequest(name, searchQuery, indexType)\
    \ {\n    let queryParams = {};\n    if (name) {\n        queryParams.name = name;\n\
    \    }\n    if (searchQuery) {\n        queryParams.search_query = searchQuery;\n\
    \    }\n    if (indexType) {\n        queryParams.index_type = indexType;\n  \
    \  }\n\n    let response = sendRequest(`/v1/watchlist`, 'POST', queryParams).Body;\n\
    \    try {\n        return JSON.parse(response);\n    } catch (err) {\n      \
    \  throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response}`;\n\
    \    }\n}\n\nfunction createWatchlist() {\n    let result = createWatchlistRequest(args.name,\
    \ args['search-query'], args.indexType);\n\n    let title = `CB Response - New\
    \ Watchlist`;\n    let dataMap = [{to: 'CbWatchlistID', from: 'id'}];\n    let\
    \ headers = dataMap.map(cn => cn.to);\n    let translatedData = mapObjFunction(dataMap)(result);\n\
    \    let humanReadable = tableToMarkdown(title, translatedData, headers, undefined,\
    \ dotToSpace);\n    let context = {\n        'CbResponse.Watchlists(val.CbWatchlistID==obj.CbWatchlistID)':\
    \ createContext(translatedData)\n    };\n\n    return {\n        Type: entryTypes.note,\n\
    \        Contents: result,\n        ContentsType: formats.json,\n        ReadableContentsFormat:\
    \ formats.markdown,\n        HumanReadable: humanReadable,\n        EntryContext:\
    \ context,\n    };\n}\n\nfunction updateWatchlistRequest(watchlistId, watchlistObject)\
    \ {\n    let response = sendRequest(`/v1/watchlist/${watchlistId}`, 'PUT', watchlistObject).Body;\n\
    \    try {\n        return JSON.parse(response);\n    } catch (err) {\n      \
    \  throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response}`;\n\
    \    }\n}\n\nfunction setWatchlist() {\n    let watchlistObject = getWatchlistRequest(args['watchlist-id']);\n\
    \n    if (args['search-query']) {\n        watchlistObject.search_query = args['search-query'];\n\
    \    }\n    if (args.name) {\n        watchlistObject.name = args.name;\n    }\n\
    \    if (args.indexType) {\n        watchlistObject.index_type = args.indexType;\n\
    \    }\n\n    let result = updateWatchlistRequest(args['watchlist-id'], watchlistObject);\n\
    \n    if (!result.result || result.result !== 'success') {\n        throw `Failed\
    \ updating watchlist.\\nResponse: ${response}`;\n    }\n\n    let title = `CB\
    \ Response - Set Watchlist`;\n    let dataMap = watchlistData;\n    let headers\
    \ = dataMap.map(cn => cn.to);\n    let translatedData = mapObjFunction(dataMap)(watchlistObject);\n\
    \    let humanReadable = tableToMarkdown(title, translatedData, headers, undefined,\
    \ dotToSpace);\n    let context = {\n        'CbResponse.Watchlists(val.CbWatchlistID==obj.CbWatchlistID)':\
    \ createContext(translatedData)\n    };\n\n    return {\n        Type: entryTypes.note,\n\
    \        Contents: watchlistObject,\n        ContentsType: formats.json,\n   \
    \     ReadableContentsFormat: formats.markdown,\n        HumanReadable: humanReadable,\n\
    \        EntryContext: context,\n    };\n}\n\nfunction deleteWatchlistRequest(watchlistId)\
    \ {\n    let response = sendRequest(`/v1/watchlist/${watchlistId}`, 'DELETE').Body;\n\
    \    try {\n        return JSON.parse(response);\n    } catch (err) {\n      \
    \  throw `Could not parse response.\\nError: ${err}.\\nResponse: ${response}`;\n\
    \    }\n}\n\nfunction deleteWatch() {\n    let result = deleteWatchlistRequest(args['watchlist-id']);\n\
    \n    return {\n        Type: entryTypes.note,\n        Contents: result,\n  \
    \      ContentsType: formats.json,\n        ReadableContentsFormat: formats.text,\n\
    \        HumanReadable: \"Success - deleted watchlist \" + args[\"watchlist-id\"\
    ]\n    };\n}\n\ntry {\n    switch (command) {\n        case 'test-module':\n \
    \           return testModule();\n        case 'cb-version':\n            return\
    \ version();\n        case 'fetch-incidents':\n            return fetchIncidents();\n\
    \        case 'cb-alert':\n            return showAlerts(); // Tested\n      \
    \  case 'cb-alert-update':\n            return updateAlert(); // Tested\n    \
    \    case 'cb-quarantine-device':\n            return quarantineDevice(true);\
    \ // Tested\n        case 'cb-unquarantine-device':\n            return quarantineDevice(false);\
    \ // Tested\n        case 'cb-get-processes':\n            return getProcesses();\
    \ // Tested\n        case 'cb-get-process':\n            return getProcess();\
    \ // Tested\n        case 'cb-process-events':\n            return getProcessEvents();\
    \ // Tested\n        case 'cb-binary':\n            return getBinaries(); // Tested\n\
    \        case 'cb-binary-get':\n            return getBinary(); // Tested\n  \
    \      case 'cb-list-sensors':\n        case 'cb-sensor-info':\n            return\
    \ getSensors(); // Tested\n        case 'cb-block-hash':\n            return blockHash(true);\
    \ // Tested\n        case 'cb-unblock-hash':\n            return blockHash(false);\
    \ // Tested\n        case 'cb-get-hash-blacklist':\n            return getHashBlacklist();\
    \ // Tested\n        case 'cb-watchlist':\n        case 'cb-watchlist-get':\n\
    \            return getWatchlist(); // Tested\n        case 'cb-watchlist-new':\n\
    \            return createWatchlist(); // Tested\n        case 'cb-watchlist-set':\n\
    \            return setWatchlist(); // Tested\n        case 'cb-watchlist-del':\n\
    \            return deleteWatch(); // Tested\n        case 'cb-binary-download':\n\
    \            return getBinaryZip();\n        default:\n            throw `Unknown\
    \ Command: ${command}`;\n    }\n} catch (err) {\n    return {\n        Type: entryTypes.error,\n\
    \        Contents: err,\n        ContentsType: formats.json,\n        ReadableContentsFormat:\
    \ formats.text,\n        HumanReadable: err\n    }\n}\n\n/// Global Utils\n\n\
    /**\n * Returns whether a given object 'obj' is empty (has no properties)\n */\n\
    function isEmpty(obj) {\n    return Object.keys(obj).length === 0 && obj.constructor\
    \ === Object\n}\n\n/**\n * Converts UNIX timestamp to format: YYYY-MM-DD HH:MM:SS\n\
    \ */\nfunction unixToString(unixTime) {\n    let timeStr = convertTimestampToString(unixTime);\n\
    \    return timeStr.substring(0, timeStr.length - 5);\n}\n\n/**\n * Converts a\
    \ string timestamp (ISO String tested) to UNIX.\n */\nfunction stringToUnix(dateString)\
    \ {\n    return new Date(dateString).getTime();\n}"
  type: javascript
tests:
- Carbon Black Response Test
toversion: 4.1.9
