category: Authentication
commonfields:
  id: HashiCorp Vault
  version: -1
configuration:
- defaultvalue: ''
  display: HashiCorp server URL (e.g., https://192.168.0.1:8200)
  name: server
  required: true
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  required: false
  type: 9
- defaultvalue: ''
  display: Authentication token
  name: token
  required: false
  type: 4
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: 'true'
  display: Fetches credentials
  name: isFetchCredentials
  required: false
  type: 8
- defaultvalue: KV,Cubbyhole
  display: CSV list of secrets engine types to fetch secrets from
  name: engines
  required: false
  type: 0
description: Manage Secrets and Protect Sensitive Data through HashiCorp Vault
display: HashiCorp Vault
image: data:image/png;base64,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
name: HashiCorp Vault
script:
  commands:
  - arguments: []
    description: List all secrets engines that exist in HashiCorp Vault
    name: hashicorp-list-secrets-engines
    outputs:
    - contextPath: HashiCorp.Engine.Type
      description: Secrets engine type
      type: string
    - contextPath: HashiCorp.Engine.Path
      description: Secrets engine path in HashiCorp
      type: string
    - contextPath: HashiCorp.Engine.Description
      description: Secrets engine description
      type: string
    - contextPath: HashiCorp.Engine.Accessor
      description: Secrets engine accessor
      type: string
  - arguments:
    - default: true
      description: Engine path, e.g.,"secret/". Use the list-secrets-engines command
        to retrieve the engine path. command.
      name: engine
      required: true
    - auto: PREDEFINED
      defaultValue: '1'
      description: The version of the KV engine
      name: version
      predefined:
      - '1'
      - '2'
    description: List secrets (names) for a specified KV engine
    name: hashicorp-list-secrets
    outputs:
    - contextPath: HashiCorp.Secret.Path
      description: Secret path
      type: string
  - arguments:
    - description: KV Engine path, e.g., "kv/"
      name: engine_path
      required: true
    - description: Secret path, e.g., "secret"
      name: secret_path
      required: true
    description: 'Returns information about a specified secret in a specified KV V2
      engine '
    name: hashicorp-get-secret-metadata
    outputs:
    - contextPath: HashiCorp.Secret.Created
      description: Secret created time
      type: date
    - contextPath: HashiCorp.Secret.Version.Destroyed
      description: Is the version destroyed
      type: boolean
    - contextPath: HashiCorp.Secret.Version.Created
      description: Version creation time
      type: number
    - contextPath: HashiCorp.Secret.Version.Deleted
      description: Version deletion time
      type: date
    - contextPath: HashiCorp.Secret.Updated
      description: Secret last updated time
      type: date
    - contextPath: HashiCorp.Secret.Engine
      description: Secret engine type
      type: string
    - contextPath: HashiCorp.Secret.CurrentVersion
      description: Secret current version
      type: number
    - contextPath: HashiCorp.Secret.Path
      description: Secret path
      type: string
  - arguments:
    - description: Secret path, e.g., "secret"
      name: secret_path
      required: true
    - description: Engine path, e.g.,"secret/"
      name: engine_path
      required: true
    - description: CSV list of secret versions to delete
      isArray: true
      name: versions
      required: true
    description: Deletes the data under a specified secret given the secret path.
      Performs a soft delete that allows you to run the hashicorp-undelete-secret
      command if necessary (for KV V2 engine)
    name: hashicorp-delete-secret
  - arguments:
    - description: Secret path, e.g., "secret"
      name: secret_path
      required: true
    - description: Engine path, e.g.,"secret/"
      name: engine_path
      required: true
    - description: CSV list of secret versions to undelete (restore)
      isArray: true
      name: versions
      required: true
    description: Undeletes (restores) a secret on HashiCorp (for KV V2 engine)
    name: hashicorp-undelete-secret
  - arguments:
    - description: Secret path, .e.g., "secret"
      name: secret_path
      required: true
    - description: Engine path, e.g.,"secret/"
      name: engine_path
      required: true
    - description: CSV list of secret versions to permanently delete
      isArray: true
      name: versions
      required: true
    description: Permanently deletes a secret (for KV V2 engine)
    name: hashicorp-destroy-secret
  - arguments:
    - default: true
      description: Path of the secrets engine to disable
      name: path
      required: true
    description: When a secrets engine is no longer needed, it can be disabled. All
      secrets under the engine are revoked and the corresponding vault data and configurations
      are removed.
    name: hashicorp-disable-engine
  - arguments:
    - description: The path where the secrets engine will be mounted
      name: path
      required: true
    - description: Type of backend, e.g., "aws"
      name: type
      required: true
    - description: Human-friendly description of the mount
      name: description
    - description: The default lease duration, specified as a string duration, e.g.,
        "5s" or "30m"
      name: default_lease_ttl
    - description: The maximum lease duration, specified as a string duration, e.g.,
        "5s" or "30m"
      name: max_lease_ttl
    - description: Disable caching
      name: force_no_cache
    - description: CSV list of keys that will not be HMAC'd by audit devices in the
        request data object
      isArray: true
      name: audit_non_hmac_request_keys
    - description: CSV list of keys that will not be HMAC'd by audit devices in the
        response data object
      isArray: true
      name: audit_non_hmac_response_keys
    - auto: PREDEFINED
      description: Whether to show this mount in the UI-specific listing endpoint;
        "unauth" or "hidden", default is "hidden" Default is hidden.
      name: listing_visibility
      predefined:
      - unauth
      - hidden
    - description: CSV list of headers to whitelist and pass from the request to the
        backend
      isArray: true
      name: passthrough_request_headers
    - auto: PREDEFINED
      description: KV version to mount. Set to "2" for mount KV V2.
      name: kv_version
      predefined:
      - '1'
      - '2'
    - description: Specifies if the secrets engine is a local mount only. Local mounts
        are not replicated, nor (if a secondary) removed by replication. Supported
        only in Vault Enterprise.
      name: local
    - description: Enable seal wrapping for the mount. Supported only in Vault Enterprise.
      name: seal_wrap
    description: Enables a new secrets engine at the specified path
    name: hashicorp-enable-engine
  - arguments: []
    description: Lists all configured policies
    name: hashicorp-list-policies
    outputs:
    - contextPath: HashiCorp.Policy.Name
      description: Policy name
      type: string
  - arguments:
    - description: Policy name
      name: name
      required: true
    description: Get information for a policy
    name: hashicorp-get-policy
    outputs:
    - contextPath: HashiCorp.Policy.Name
      description: Policy name
      type: string
    - contextPath: 'HashiCorp.Policy.Rule.Path '
      description: Policy rule path
      type: string
    - contextPath: HashiCorp.Policy.Rule.Capabilities
      description: Policy rule capabilities
  - arguments: []
    description: If you suspect your data has been compromised, you can seal your
      vault to prevent access to your secrets
    execution: true
    name: hashicorp-seal-vault
  - arguments:
    - description: 'Single master key '
      name: key
    - auto: PREDEFINED
      description: Reset the unseal project
      name: reset
      predefined:
      - 'true'
    description: Use a single master key share to unseal the vault. If the master
      key shares threshold is met, vault will attempt to unseal the vault. Otherwise,
      this API must be called until the threshold is met.
    name: hashicorp-unseal-vault
  - arguments:
    - description: The engine path, e.g., "secret/"
      name: path
      required: true
    - description: The engine type, e.g., "KV"
      name: type
      required: true
    - auto: PREDEFINED
      description: The engine version (for KV engines); "1" or "2"
      name: version
      predefined:
      - '1'
      - '2'
    description: Configure a secrets engine to fetch secrets from
    name: hashicorp-configure-engine
  - arguments: []
    description: Reset the engines configuration
    name: hashicorp-reset-configuration
  - arguments:
    - description: The name of the token role
      name: role_name
    - description: CSV list of policies for the token. This must be a subset of the
        policies belonging to the token making the request, unless root. If policies
        are not specified, all policies of the calling token are applied to the new
        token.
      isArray: true
      name: policies
    - description: A map of string-to-string valued metadata. This is passed through
        to the audit devices.
      name: meta
    - auto: PREDEFINED
      description: If true and set by a root caller, the token will not have the parent
        token of the caller. This creates a token with no parent.
      name: no_parent
      predefined:
      - 'true'
      - 'false'
    - auto: PREDEFINED
      description: If true the default policy will not be included in this token's
        policy set; "true" or "false"
      name: no_default_policy
      predefined:
      - 'true'
      - 'false'
    - auto: PREDEFINED
      description: If set to false, the token cannot be renewed past its initial TTL.
        If set to true, the token can be renewed up to the system/mount maximum TTL.
        "true" or "false"
      name: renewable
      predefined:
      - 'true'
      - 'false'
    - description: The TTL(lease duration) period of the token, provided as "10m"
        or "1h", where hour is the largest suffix. If not provided, the token is valid
        for the default lease TTL, or indefinitely if the root policy is used.
      name: ttl
    - description: ' If set, the token will have an explicit max TTL applied to it.
        The maximum token TTL cannot be changed later, and unlike with normal tokens,
        updates to the system/mount max TTL value will have no effect at renewal time.
        The token can never be renewed or used past the value set at issue time.'
      name: explicit_max_ttl
    - description: The display name of the token
      name: display_name
    - description: The maximum number of times the token can be used. Supply this
        argument to create a one-time-token, or limited use token. The value of 0
        has no limit to the number of uses.
      name: num_uses
    - description: If specified, the token will be periodic; it will not have a maximum
        TTL (unless an "explicit-max-ttl" is also set), but every renewal will use
        the given period. Requires a root/sudo token to use.
      name: period
    description: Creates a new authentication token
    name: hashicorp-create-token
    outputs:
    - contextPath: HashiCorp.Auth.Token
      description: Authentication token
      type: string
    - contextPath: HashiCorp.Auth.Policy
      description: Authentication policies
    - contextPath: HashiCorp.Auth.LeaseDuration
      description: 'Authentication lease duration in seconds, 0 if indefinitely '
      type: number
  dockerimage: demisto/hashicorp:1.0.0.39
  runonce: false
  script: "import requests\nimport json\nimport hcl\n\n# disable insecure warnings\n\
    requests.packages.urllib3.disable_warnings()\n\nif not demisto.params().get('proxy',\
    \ False):\n    del os.environ['HTTP_PROXY']\n    del os.environ['HTTPS_PROXY']\n\
    \    del os.environ['http_proxy']\n    del os.environ['https_proxy']\n\n\n'''\
    \ GLOBAL VARIABLES '''\n\nCREDENTIALS = demisto.params().get('credentials', {})\n\
    USERNAME = None\nPASSWORD = None\nif CREDENTIALS:\n    USERNAME = CREDENTIALS.get('identifier')\n\
    \    PASSWORD = CREDENTIALS.get('password')\nVERIFY_SSL = not demisto.params().get('unsecure',\
    \ False)\nTOKEN = demisto.params().get('token')\n\ndef get_server_url():\n   \
    \ url = demisto.params()['server']\n    url = re.sub('/[\\/]+$/', '', url)\n \
    \   url = re.sub('\\/$', '', url)\n    return url\n\n\nBASE_URL = get_server_url()\n\
    SERVER_URL = BASE_URL + '/v1'\n\nDEFAULT_STATUS_CODES = {\n    429,\n    472,\n\
    \    473\n}\n\n''' HELPER FUNCTIONS '''\n\ndef get_headers():\n    headers = \
    \ {\n        'Content-Type': 'application/json',\n    }\n\n    if TOKEN:\n   \
    \     headers['X-Vault-Token'] = TOKEN\n\n    return headers\n\ndef login():\n\
    \    path = 'auth/userpass/login/' + USERNAME\n    body = {\n        'password':\
    \ PASSWORD\n    }\n\n    url = '{}/{}'.format(SERVER_URL, path)\n    res = requests.request('POST',\
    \ url, headers=get_headers(), data=json.dumps(body), verify=VERIFY_SSL)\n    if\
    \ (res.status_code < 200 or res.status_code >= 300) and res.status_code not in\
    \ DEFAULT_STATUS_CODES:\n        try:\n            error_body = res.json()\n \
    \           if 'errors' in error_body and isinstance(error_body['errors'], list):\n\
    \                error_body = ';'.join(error_body['errors']) if len(error_body['errors'])\
    \ > 0 else 'None'\n        except:\n            error_body = res.content\n   \
    \     return_error('Login failed. Status code: {}, details: {}'.format(str(res.status_code),\
    \ error_body))\n\n    auth_res = res.json()\n    if not auth_res or 'auth' not\
    \ in auth_res or 'client_token' not in auth_res['auth']:\n        return_error('Could\
    \ not authenticate user')\n\n    return auth_res['auth']['client_token']\n\ndef\
    \ send_request(path, method='get', body=None, params=None, headers=None):\n  \
    \  body = body if body is not None else {}\n    params = params if params is not\
    \ None else {}\n\n    url = '{}/{}'.format(SERVER_URL, path)\n\n    headers =\
    \ headers if headers is not None else get_headers()\n    res = requests.request(method,\
    \ url, headers=headers, data=json.dumps(body), params=params, verify=VERIFY_SSL)\n\
    \    if res.status_code < 200 or res.status_code >= 300:\n        try:\n     \
    \       error_body = res.json()\n            if 'errors' in error_body and isinstance(error_body['errors'],\
    \ list):\n                error_body = ';'.join(error_body['errors']) if len(error_body['errors'])\
    \ > 0 else 'None'\n        except:\n            error_body = res.content\n   \
    \     return_error('Request failed. Status code: {}, details: {}'.format(str(res.status_code),\
    \ error_body))\n    if res.content:\n        return res.json()\n    return ''\n\
    \n''' FUNCTIONS '''\n\ndef list_secrets_engines_command():\n    res = list_secrets_engines()\n\
    \n    if not res:\n        return_error('No engines found')\n\n    mapped_engines\
    \ = [{\n        'Path': k,\n        'Type': v.get('type'),\n        'Description':\
    \ v.get('description'),\n        'Accessor': v.get('accessor')\n    } for k,v\
    \ in res.get('data', {}).iteritems()]\n\n    headers = ['Path', 'Type', 'Description',\
    \ 'Accessor']\n\n    demisto.results({\n        'Type': entryTypes['note'],\n\
    \        'Contents': res,\n        'ContentsFormat': formats['json'],\n      \
    \  'ReadableContentsFormat': formats['markdown'],\n        'HumanReadable': tableToMarkdown('HashiCorp\
    \ Vault Secrets Engines', mapped_engines, headers=headers, removeNull=True),\n\
    \        'EntryContext': {\n              'HashiCorp.Engine(val.Path===obj.Path)':\
    \ createContext(mapped_engines, removeNull=True)\n        }\n    })\n\ndef list_secrets_engines():\n\
    \    path = 'sys/mounts'\n\n    return send_request(path)\n\n\ndef list_secrets_command():\n\
    \    engine = demisto.args()['engine']\n    version = demisto.args().get('version')\n\
    \n    res = list_secrets(engine, version)\n\n    if not res or 'data' not in res:\n\
    \        return_error('Secrets not found')\n\n    mapped_secrets = [{\n      \
    \  'Path': k\n    } for k in res['data'].get('keys', [])]\n\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'Contents': res,\n        'ContentsFormat':\
    \ formats['json'],\n        'ReadableContentsFormat': formats['markdown'],\n \
    \       'HumanReadable': tableToMarkdown('HashiCorp Vault Secrets in engine path:\
    \ ' + engine, mapped_secrets, removeNull=True),\n        'EntryContext': {\n \
    \             'HashiCorp.Secret(val.Path===obj.Path)': createContext(mapped_secrets)\n\
    \        }\n    })\n\n\ndef list_secrets(engine_path, version):\n    path = engine_path\n\
    \n    if version == '2':\n        path += '/metadata'\n\n    params = {\n    \
    \    'list': 'true'\n    }\n\n    return send_request(path, 'get', params=params)\n\
    \n\ndef get_secret_metadata_command():\n    engine_path = demisto.args()['engine_path']\n\
    \    secret_path = demisto.args()['secret_path']\n\n    res = get_secret_metadata(engine_path,\
    \ secret_path)\n\n    if not res or 'data' not in res:\n        return_error('Secret\
    \ not found')\n\n    data = res['data']\n\n    secret_headers = ['Engine','Created','Updated','CurrentVersion']\n\
    \    version_headers = ['Number','Created','Deleted','Destroyed']\n\n    mapped_secret\
    \ = {\n        'Path': secret_path,\n        'Engine': engine_path,\n        'Created':\
    \ data.get('created_time'),\n        'Updated': data.get('updated_time'),\n  \
    \      'CurrentVersion': data.get('current_version')\n    }\n\n    mapped_versions\
    \ = [{\n        'Number': k,\n        'Created': v['created_time'],\n        'Deleted':\
    \ v['deletion_time'],\n        'Destroyed': v['destroyed']\n    } for k, v in\
    \ data.get('versions', {}).iteritems()]\n\n    hr = tableToMarkdown('Secret metadata',\
    \ mapped_secret, headers=secret_headers, removeNull=True)\n    if mapped_versions:\n\
    \        hr += tableToMarkdown('Versions', mapped_versions, headers=version_headers,\
    \ removeNull=True)\n        mapped_secret['Version'] = mapped_versions\n\n   \
    \ demisto.results({\n        'Type': entryTypes['note'],\n        'Contents':\
    \ res,\n        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': hr,\n        'EntryContext':\
    \ {\n              'HashiCorp.Secret(val.Path===obj.Path)': createContext(mapped_secret,\
    \ removeNull=True)\n        }\n    })\n\ndef get_secret_metadata(engine_path,\
    \ secret_path):\n    path = engine_path + '/metadata/' + secret_path\n\n    return\
    \ send_request(path, 'get')\n\n\ndef delete_secret_command():\n    engine_path\
    \ = demisto.args()['engine_path']\n    secret_path = demisto.args()['secret_path']\n\
    \    versions = argToList(demisto.args()['versions'])\n\n    res = delete_secret(engine_path,\
    \ secret_path, versions)\n\n    demisto.results('Secret versions deleted successfully')\n\
    \n\ndef delete_secret(engine_path, secret_path, versions):\n    path = engine_path\
    \ + 'delete/' + secret_path\n\n    body = {\n        'versions': versions\n  \
    \  }\n\n    return send_request(path, 'post', body=body)\n\ndef undelete_secret_command():\n\
    \    engine_path = demisto.args()['engine_path']\n    secret_path = demisto.args()['secret_path']\n\
    \    versions = argToList(demisto.args()['versions'])\n\n    res = undelete_secret(engine_path,\
    \ secret_path, versions)\n\n    demisto.results('Secret versions undeleted successfully')\n\
    \ndef undelete_secret(engine_path, secret_path, versions):\n    path = engine_path\
    \ + 'undelete/' + secret_path\n\n    body = {\n        'versions': versions\n\
    \    }\n\n    return send_request(path, 'post', body=body)\n\ndef destroy_secret_command():\n\
    \    engine_path = demisto.args()['engine_path']\n    secret_path = demisto.args()['secret_path']\n\
    \    versions = argToList(demisto.args()['versions'])\n\n    res = destroy_secret(engine_path,\
    \ secret_path, versions)\n\n    demisto.results('Secret versions destroyed successfully')\n\
    \ndef destroy_secret(engine_path, secret_path, versions):\n    path = engine_path\
    \ + 'destroy/' + secret_path\n\n    body = {\n        'versions': versions\n \
    \   }\n\n    return send_request(path, 'post', body=body)\n\n\ndef list_policies_command():\n\
    \    res = list_policies()\n\n    if not res or 'policies' not in res:\n     \
    \   return_error('No policies found')\n\n    mapped_policies = [{\n        'Name':\
    \ i\n    } for i in res['policies']]\n\n    demisto.results({\n        'Type':\
    \ entryTypes['note'],\n        'Contents': res,\n        'ContentsFormat': formats['json'],\n\
    \        'ReadableContentsFormat': formats['markdown'],\n        'HumanReadable':\
    \ tableToMarkdown('HashiCorp Vault Policies', mapped_policies, removeNull=True),\n\
    \        'EntryContext': {\n              'HashiCorp.Policy(val.Name===obj.Name)':\
    \ createContext(mapped_policies, removeNull=True)\n        }\n    })\n\ndef list_policies():\n\
    \    path = '/sys/policy'\n\n    return send_request(path, 'get')\n\ndef get_policy_command():\n\
    \    name = demisto.args()['name']\n\n    res = get_policy(name)\n\n    if not\
    \ res or 'rules' not in res:\n        return_error('Policy not found')\n\n   \
    \ rules = hcl.loads(res['rules'])\n\n    mapped_rules = [{'Path': k, 'Capabilities':\
    \ v['capabilities']} for k,v in rules.get('path', {}).iteritems()]\n\n    mapped_policy\
    \ = {\n        'Name': res['name'],\n        'Rule': mapped_rules\n    }\n\n \
    \   demisto.results({\n        'Type': entryTypes['note'],\n        'Contents':\
    \ res,\n        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': tableToMarkdown('HashiCorp Vault\
    \ Policy - ' + name, mapped_rules, removeNull=True),\n        'EntryContext':\
    \ {\n              'HashiCorp.Policy(val.Name===obj.Name)': createContext(mapped_policy,\
    \ removeNull=True)\n        }\n    })\n\n\ndef get_policy(policy_name):\n    path\
    \ = 'sys/policy/' + policy_name\n\n    return send_request(path, 'get')\n\ndef\
    \ disable_engine_command():\n    path = demisto.args()['path']\n\n    res = disable_engine(path)\n\
    \n    demisto.results('Engine disabled successfully')\n\ndef disable_engine(engine_path):\n\
    \    path = 'sys/mounts/' + engine_path\n\n    return send_request(path, 'delete')\n\
    \n\ndef enable_engine_command():\n    path = demisto.args()['path']\n    engine_type\
    \ = demisto.args()['type']\n    description = demisto.args().get('description')\n\
    \    default_lease_ttl = demisto.args().get('default_lease_ttl')\n    max_lease_ttl\
    \ = demisto.args().get('max_lease_ttl')\n    force_no_cache = demisto.args().get('force_no_cache')\n\
    \    audit_non_hmac_request_keys = argToList(demisto.args().get('audit_non_hmac_request_keys',\
    \ []))\n    audit_non_hmac_response_keys = argToList(demisto.args().get('audit_non_hmac_response_keys',\
    \ []))\n    listing_visibility = demisto.args().get('listing_visibility')\n  \
    \  passthrough_request_headers = argToList(demisto.args().get('passthrough_request_headers',\
    \ []))\n    kv_version = demisto.args().get('kv_version')\n    local = demisto.args().get('local')\n\
    \    seal_wrap = demisto.args().get('seal_wrap')\n\n    res = enable_engine(path,\
    \ engine_type, description, default_lease_ttl, max_lease_ttl, force_no_cache,\
    \ audit_non_hmac_request_keys,\n                  audit_non_hmac_response_keys,\
    \ listing_visibility, passthrough_request_headers, kv_version, local, seal_wrap)\n\
    \n    demisto.results('Engine enabled successfully')\n\ndef enable_engine(path,\
    \ engine_type, description, default_lease_ttl, max_lease_ttl, force_no_cache,\
    \ audit_non_hmac_request_keys,\n                  audit_non_hmac_response_keys,\
    \ listing_visibility, passthrough_request_headers, kv_version, local, seal_wrap):\n\
    \        path = 'sys/mounts/' + path\n\n        body = {\n            'type':\
    \ engine_type,\n            'config': {}\n        }\n        if description:\n\
    \            body['description'] = description\n\n        if default_lease_ttl:\n\
    \            body['config']['default_lease_ttl'] = default_lease_ttl\n       \
    \ if max_lease_ttl:\n            body['config']['max_lease_ttl'] = max_lease_ttl\n\
    \        if force_no_cache:\n            body['config']['force_no_cache'] = force_no_cache\n\
    \        if audit_non_hmac_request_keys:\n            body['config']['audit_non_hmac_request_keys']\
    \ = audit_non_hmac_request_keys\n        if audit_non_hmac_response_keys:\n  \
    \          body['config']['audit_non_hmac_response_keys'] = audit_non_hmac_response_keys\n\
    \        if listing_visibility:\n            body['config']['listing_visibility']\
    \ = listing_visibility\n        if passthrough_request_headers:\n            body['config']['passthrough_request_headers']\
    \ = passthrough_request_headers\n        if kv_version:\n            body['options']\
    \ = {\n                'version': kv_version\n            }\n        if local:\n\
    \            body['local'] = local\n        if seal_wrap:\n            body['seal_wrap']\
    \ = seal_wrap\n\n        if not body['config']:\n            del body['config']\n\
    \n        return send_request(path, 'post', body=body)\n\n\ndef seal_vault_command():\n\
    \    res = seal_vault()\n\n    demisto.results('Vault sealed successfully')\n\n\
    \ndef seal_vault():\n    path = 'sys/seal'\n\n    return send_request(path, 'put')\n\
    \n\ndef unseal_vault_command():\n    reset = demisto.args().get('reset')\n   \
    \ key = demisto.args().get('key')\n\n    if not key and not reset:\n        return_error('Either\
    \ key or reset must be provided')\n\n    res = unseal_vault(key, reset)\n\n  \
    \  if not res:\n        return_error('Could not retrieve unseal state')\n\n  \
    \  headers = ['Sealed', 'Threshold', 'Shares', 'Progress']\n\n    mapped_unseal\
    \ = {\n        'Sealed': res.get('sealed'),\n        'Threshold': res.get('t'),\n\
    \        'Shares': res.get('n'),\n        'Progress': res.get('progress')\n  \
    \  }\n\n    demisto.results({\n        'Type': entryTypes['note'],\n        'Contents':\
    \ res,\n        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': tableToMarkdown('HashiCorp Vault\
    \ Unseal', mapped_unseal, removeNull=True),\n    })\n\n\ndef unseal_vault(key,\
    \ reset):\n    path = 'sys/unseal'\n    body = {}\n    if reset:\n        body['reset']\
    \ = reset\n    elif key:\n        body['key'] = key\n\n    return send_request(path,\
    \ 'put', body=body)\n\n\ndef create_token_command():\n    role_name = demisto.args().get('role_name')\n\
    \    policies = argToList(demisto.args().get('policies', []))\n    meta = demisto.args().get('meta')\n\
    \    no_parent = demisto.args().get('no_parent')\n    no_default_policy = demisto.args().get('no_default_policy')\n\
    \    renewable = demisto.args().get('renewable')\n    ttl = demisto.args().get('ttl')\n\
    \    explicit_max_ttl = demisto.args().get('explicit_max_ttl')\n    display_name\
    \ = demisto.args().get('display_name')\n    num_uses = demisto.args().get('num_uses')\n\
    \    period = demisto.args().get('period')\n\n    res = create_token(role_name,\
    \ policies, meta, no_parent, no_default_policy, renewable, ttl, explicit_max_ttl,\n\
    \                display_name, num_uses, period)\n\n    if not res or 'auth' not\
    \ in res:\n        return_error('Could not get authentication token')\n\n    auth\
    \ = res['auth']\n\n    headers = ['Token', 'Policy', 'LeaseDuration']\n\n    mapped_auth\
    \ = {\n        'Token': auth.get('client_token'),\n        'Policy': auth.get('policies'),\n\
    \        'LeaseDuration': auth.get('lease_duration')\n    }\n\n    demisto.results({\n\
    \        'Type': entryTypes['note'],\n        'Contents': res,\n        'ContentsFormat':\
    \ formats['json'],\n        'ReadableContentsFormat': formats['markdown'],\n \
    \       'HumanReadable': tableToMarkdown('Token successfully created', mapped_auth,\
    \ removeNull=True),\n        'EntryContext': {\n              'HashiCorp.Auth(val.Token===obj.Token)':\
    \ createContext(mapped_auth, removeNull=True)\n        }\n    })\n\n\ndef create_token(role_name,\
    \ policies, meta, no_parent, no_default_policy, renewable, ttl, explicit_max_ttl,\n\
    \                display_name, num_uses, period):\n    path = 'auth/token/create'\n\
    \    body = {}\n    if role_name:\n        body['role_name'] = role_name\n   \
    \ if policies:\n        body['policies'] = policies\n    if meta:\n        body['meta']\
    \ = meta\n    if no_parent:\n        body['no_parent'] = no_parent\n    if no_default_policy:\n\
    \        body['no_default_policy'] = no_default_policy\n    if renewable:\n  \
    \      body['renewable'] = renewable\n    if ttl:\n        body['ttl'] = ttl\n\
    \    if explicit_max_ttl:\n        body['explicit_max_ttl'] = explicit_max_ttl\n\
    \    if display_name:\n        body['display_name'] = display_name\n    if num_uses:\n\
    \        body['num_uses'] = num_uses\n    if period:\n        body['period'] =\
    \ period\n\n    return send_request(path, 'post', body=body)\n\ndef configure_engine_command():\n\
    \    engine_path = demisto.args()['path']\n    engine_type = demisto.args()['type']\n\
    \    version = demisto.args().get('version')\n\n    configure_engine(engine_path,\
    \ engine_type, version)\n\n    demisto.results('Engine configured successfully')\n\
    \ndef reset_config_command():\n    demisto.setIntegrationContext({'configs': []})\n\
    \n    demisto.results('Successfully reset the engines configuration')\n\ndef configure_engine(engine_path,\
    \ engine_type, version):\n    engine_conf = {\n        'type': engine_type,\n\
    \        'path': engine_path\n    }\n    if version:\n        engine_conf['version']\
    \ = str(version)\n\n    ENGINE_CONFIGS.append(engine_conf)\n\n    demisto.setIntegrationContext({'configs':\
    \ ENGINE_CONFIGS})\n\n\ndef fetch_credentials():\n    credentials = []\n    engines_to_fetch_from\
    \ = []\n    ENGINES = argToList(demisto.params().get('engines', []))\n    identifier\
    \ = demisto.args().get('identifier')\n\n    if len(ENGINES) == 0:\n        return_error('No\
    \ secrets engines specified')\n\n    for engine_type in ENGINES:\n        engines_to_fetch\
    \ = list(filter(lambda e: e['type'] == engine_type, ENGINE_CONFIGS))\n       \
    \ engines_to_fetch_from += engines_to_fetch\n\n    if len(engines_to_fetch_from)\
    \ == 0:\n            return_error('Engine type not configured, Use the configure-engine\
    \ command to configure a secrets engine.')\n\n    for engine in engines_to_fetch_from:\n\
    \        if engine['type'] == 'KV':\n            if 'version' not in engine:\n\
    \                return_error('Version not configured for KV engine, re-configure\
    \ the engine')\n            if engine['version'] == '1':\n                credentials\
    \ += get_kv1_secrets(engine['path'])\n            elif engine['version'] == '2':\n\
    \                credentials += get_kv2_secrets(engine['path'])\n        elif\
    \ engine['type'] == 'Cubbyhole':\n            credentials += get_ch_secrets(engine['path'])\n\
    \n    if identifier:\n        credentials = list(filter(lambda c: c.get('name',\
    \ '') == identifier, credentials))\n\n    demisto.credentials(credentials)\n\n\
    \ndef get_kv1_secrets(engine_path):\n    path = engine_path\n    params = {\n\
    \        'list': 'true'\n    }\n\n    res = send_request(path, 'get', params=params)\n\
    \n    secrets = []\n\n    if not res or 'data' not in res:\n        return []\n\
    \n    for secret in res['data'].get('keys', []):\n        secret_data = get_kv1_secret(engine_path,\
    \ secret)\n        for k,v in secret_data.get('data', {}).iteritems():\n     \
    \       secrets.append({\n                    'user': k,\n                   \
    \ 'password': v,\n                    'name': secret\n                })\n\n \
    \   return secrets\n\ndef get_kv1_secret(engine_path, secret):\n    path = engine_path\
    \ + secret\n\n    return send_request(path, 'get')\n\ndef get_kv2_secrets(engine_path):\n\
    \    secrets = []\n    res = list_secrets(engine_path, '2')\n    if not res or\
    \ 'data' not in res:\n        return []\n\n    for secret in res['data'].get('keys',\
    \ []):\n        secret_data = get_kv2_secret(engine_path, secret)\n        for\
    \ k,v in secret_data.get('data', {}).get('data', {}).iteritems():\n          \
    \  secrets.append({\n                    'user': k,\n                    'password':\
    \ v,\n                    'name': secret\n                })\n\n    return secrets\n\
    \ndef get_kv2_secret(engine_path, secret):\n    path = engine_path + 'data/' +\
    \ secret\n\n    return send_request(path, 'get')\n\n\ndef get_ch_secrets(engine_path):\n\
    \    path = engine_path\n\n    params = {\n        'list': 'true'\n    }\n\n \
    \   res = send_request(path, 'get', params=params)\n\n    secrets = []\n\n   \
    \ if not res or 'data' not in res:\n        return []\n\n    for secret in res['data'].get('keys',\
    \ []):\n        secret_data = get_ch_secret(engine_path, secret)\n        for\
    \ k,v in secret_data.get('data', {}).iteritems():\n            secrets.append({\n\
    \                    'user': k,\n                    'password': v,\n        \
    \            'name': secret\n                })\n\n    return secrets\n\ndef get_ch_secret(engine_path,\
    \ secret):\n    path = engine_path + secret\n\n    return send_request(path, 'get')\n\
    \n''' EXECUTION CODE '''\n\nLOG('Executing command: ' + demisto.command())\n\n\
    if USERNAME and PASSWORD:\n    TOKEN = login()\nelif not TOKEN:\n    return_error('Either\
    \ an authentication token or user credentials must be provided')\n\ninteg_context\
    \ = demisto.getIntegrationContext()\nif not integ_context or 'configs' not in\
    \ integ_context:\n    integ_context['configs'] = []\n\nENGINE_CONFIGS = integ_context['configs']\n\
    \ntry:\n    if demisto.command() == 'test-module':\n        path = 'sys/health'\n\
    \        send_request(path)\n        demisto.results('ok')\n    elif demisto.command()\
    \ == 'fetch-credentials':\n        fetch_credentials()\n    elif demisto.command()\
    \ == 'hashicorp-list-secrets-engines':\n        list_secrets_engines_command()\n\
    \    elif demisto.command() == 'hashicorp-list-secrets':\n        list_secrets_command()\n\
    \    elif demisto.command() == 'hashicorp-list-policies':\n        list_policies_command()\n\
    \    elif demisto.command() == 'hashicorp-get-policy':\n        get_policy_command()\n\
    \    elif demisto.command() == 'hashicorp-get-secret-metadata':\n        get_secret_metadata_command()\n\
    \    elif demisto.command() == 'hashicorp-delete-secret':\n        delete_secret_command()\n\
    \    elif demisto.command() == 'hashicorp-undelete-secret':\n        undelete_secret_command()\n\
    \    elif demisto.command() == 'hashicorp-destroy-secret':\n        destroy_secret_command()\n\
    \    elif demisto.command() == 'hashicorp-disable-engine':\n        disable_engine_command()\n\
    \    elif demisto.command() == 'hashicorp-enable-engine':\n        enable_engine_command()\n\
    \    elif demisto.command() == 'hashicorp-seal-vault':\n        seal_vault_command()\n\
    \    elif demisto.command() == 'hashicorp-unseal-vault':\n        unseal_vault_command()\n\
    \    elif demisto.command() == 'hashicorp-create-token':\n        create_token_command()\n\
    \    elif demisto.command() == 'hashicorp-configure-engine':\n        configure_engine_command()\n\
    \    elif demisto.command() == 'hashicorp-reset-configuration':\n        reset_config_command()\n\
    except Exception as e:\n    LOG(e)\n    LOG.print_log()\n    return_error(e.message)"
  subtype: python2
  type: python
tests:
- hashicorp_test
toversion: 4.1.9
