category: Case Management
commonfields:
  id: RSA Archer
  version: -1
configuration:
- defaultvalue: ''
  display: Server URL (e.g. https://192.168.0.1/rsaarcher/)
  name: server
  required: true
  type: 0
- defaultvalue: ''
  display: Instance name
  name: instanceName
  required: true
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ''
  display: Timezone offset in minutes of the RSA Archer server machine (+60, -60,
    in minutes)
  name: timeZone
  required: false
  type: 0
- defaultvalue: ''
  display: Application ID for fetch
  name: fetchApplicationId
  required: false
  type: 0
- defaultvalue: ''
  display: The application's base ID. For example "Incident ID"
  name: fieldsToDisplay
  required: false
  type: 0
- defaultvalue: ''
  display: fetchFilter - Specific filters for fetching in the form of an xml string
  name: fetchFilter
  required: false
  type: 0
- defaultvalue: 'false'
  display: Use Archer's REST API instead of its SOAP API
  name: useRest
  required: false
  type: 8
- defaultvalue: 'false'
  display: Use European Time format (dd/mm/yyyy) instead of the American one
  name: useEuropeanTime
  required: false
  type: 8
description: The RSA Archer GRC Platform provides a common foundation for managing
  policies, controls, risks, assessments and deficiencies across lines of business.
display: RSA Archer
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAqCAYAAAB4Ip8uAAAPyUlEQVR42s1ceXAk5XUf7bKH9mBvrTTzvdcjLavVSt3vfSPtQcJhwCEFCQ5gB2zK2A6uwqHK2E7IRYIT7IrtlJ2CUD7ADjF2OCpZF46LsrFJbEMIN3FYwIB3zbW7sMfM9Nff93XPSNqz88eMFjHbPZJWmrW66pVUKnX36/fr7x2/977O+OCt9cHrrP88aVGC1paBViuk0y3waZlTeGigFUa4vRrp4kDwdRroNgXeTgU0ooFHFNDeALy7DfJnAiGvtF1y6+GFpwslvGXK8doyv4FDA88vg7dgvPhAC7SQCyZzfuBM7v8yGuhFDbRTA+2Yjhjglw3wL0LkH0fAX9dZ7zqVG9iqcXBpKwwUdqyfbxx5pnH45gj4UQ1sA+A4RI4jlLFGihXUJACq/51jDRwHgo4ap/BWCPxT7dA/VJdvuazaMbT+VIHrOwODVZR3GqBvjxcLfFcI8q6ioEvSzi1DYW7g0LkB8kdNR89Zh9qXNV9MFvmoRY5nQqK6hMhxABRHDmsL8oHqitzVCtwZA7q6IndWlOu/L3LYGhgHHFDs10U1yPi/B8CxqetqgWPjeHEV+Vf7hXvnV5bnLq0CrWolwAHS90axcNxe46WKMrZATxwAb3nSuSUhe8pIN/rg3VZCvqHsDHY3f5uARvxxBpgpUUCxAY41UBzmh44alD8Lsu450zFMGby5Qc7788gZ2meRYzMOPDVFGa+rBoot1MCO84OlMvRvbZlrFgOFCrJKs1tdl4NFpCuTzt+f7cuVwfuLMnif9dH9dIBetukNFdCIOgkDTdaI6rjSFFeBigeE99GTMYxCPk0BfcECHzaTuLdukGASuoYOxWHnph8cmXfpopa556x7e4jcXA/k2Ah6oJh3T288f1+2t81kCxss0vkGvTOMQ20nDXAwBVENvycpboHjClKlmPOumrpb42tD4GNBE11NzcUdCpG1D7RXIe1QQC8poF8HQPtCYF1FOVJz6e/WVwPFFr1Id2weahW4u3sGNlaA39ATvGxBzZscLefdC1JzEKTJJYdNAK4q4BcU8HYF/PwEsl0jvRghv15BWbHAsQFOBhk5Dh3v7dElF8rJGuaw2IRG8F6DnOiOw9pbX4qAt2n0/jgQtKWI3KV7aHEpKxf6OTo9ADenBW0O0PtwAPRlBfRQhPxahPKwAY4ryLEC7xutjL1vr+O/Deu5wkTeJEKOA8Hbgp6hudO6aRLAAVDsC3rGF3KVD3KJD/L0ZhKAXKqRVvrg9SnkDyiHvhah3GuQU5SXsXIGHlDr5aTKKZPr+1wFBxPBjYDjAPnxItJ5Uy9VvN4A6ZoQ+X6D/Hwg3A2tAvfw/MU53b3pl3qS4S0Aji3SqMoPbm4JwAroCR+4bRrX3aKBHhnLqBuvHyIfU3l5/kTXiVbAgkC4z9kEj6BrRnh+V75fTMcGBrz5CrgnEG7LauKwo+dag4XE1Rs0WcVlwXe3CuCnFPKC6Vy7mO3PaqCndYLyFZSxAvrmRNcoYeGMANhP0rEC8pAPA5/JzPJDdw+tNE7hsTAlxChBqcBbhwO1dpOclQBnMplMWbhXRMiVIGH1BUAv6HxzRqYMdE6EbJN0rKLUZaD3zHaAQ6dwuQE6FiRl+sjKF96tEfKBJJBDh2K7dvD2WQuw6fKWakEvJ7lpJaioBDnN63TvvRWUYTLAbBR6F8xmcH3B8zXSQ1HD6vXrPEEE/GB5Td8SlXV/GCaEoQAoNvmhPdXlnRtmJcCZTCZTAvrPpBhqkHU5x7K5ft6mENkk6RghHymD99nZDLASfK4FPqIanr9WltEhm5WfyGQymVLOvSxCeSwRYKcQm46eL8xegLu9RIAtsg7Ao+bMD60IwHszNUYh7y4Db5qtAAfCuz9CeULsrTNW21UXr85kMpkDjrcgAH4ySojTBii2OLhjvzOYn3UAK3BP10CvBMkkyv5QkJh4FdB9lQQjqTpDFgK/qfOFq2cbuCV0t0QgbbL3kcd8QTe/+2Vwr0pz0xY49nPuDbMO4JKgqyLkanCie4594Kf3ijMnLOR9we+xyIfTCAKDFIfAIzbb/5AW3hUGaaVBOec3DXAR++8Ma9VCEmBvl3MD6xqwWKlRPhcmxOsa987/VwS3a9YAXBLcbYD/1ySWSRxbZ/BLk8rEczxHC75tuE6cpDUXQpRxWKMhd4Yobynm+i9SwgWDsv1Ug/vc8q7+g/nBt5IzYxmbzt7EEtF29X3SgEzkDgxSXAbvI7MCYCW8szXwY7aB6BjLHg1w9ZVV6E32egc6vZUGvPurKI+3BdNYIFtvIRrg2IJ8PUJ5b4junww7fedqIbtOBcCvrsl/oeoUUoDiqurqH0w67+jchY5xhnaYhFVcb4s+VXL6lrYM4DiPbaPOhrnvzpJ5btlxl/lIAwrogxboWyFS2WByAR+BjJWgW6dqtD2id1WAA3dEUOs/T9T7Dca4b6j1i0OUUQXk4ypPt2igy4Kcu6IV4EaOxKojX0kleATd3+z8vev472wK+REhxwrdy1u6ggPovy5AfjhA/olCfrAM9HON9GwF+bUIeVTXM7/E1YUcG6SnylnqPBnj7cP184zgjww7hefDOtCT6fsG73iOuN5ciEKgZ43wPufn3fxMAlwS7qdswssd1O59zHbTe5ud//p6t78i5C7dkHD5QHFYc9//bdE7rWUA7xXeWRFKY8b1WoNxvdd010mxRX65DCSna8Tvti/tUFnvkxb5uQj4SAXlhF0a9a6pjpquFZRxBLw7ALr5jXW9y6er1wHkDgv8lE1wsfX84OdhD03oYv0e7xs2pfNUQR71Bf1+S2Pw6x1bbx5xJtcZ0fWkygA97gPRTK4Wg7RYC+99yuG7A+A3h1FW6oZ8V6O/WczWWAPaAj1ZRP6taa1eR15hgJJjL9Ax5Uxu4MHv9rZUQJaCFC+oBD+wPzc4p3UAr9q8PET3Fxa4ecKDMq6g3KUEf7GcG2jprFMpz2ss0Ps10q1G0KNV5D1WvDOSM1FyFqGMQ6R9AXiXnBTnnNuw0AD9LI2WtOhtL3dvzE2aJMnxv9uUujgUHETrm7v6aWfRxqGLo5T6tG7Ut4q48Ys+uoOnnEHKegsDoM3VXnmtceiuYeSXQqdm6GCCcZkQaV+xi6fch7Vi4Hcs8NGgAZQAKNboxtGarX8zpWdw3HNC5ER8tKDYrit893DP+jktLZMClN9OSnRMbYR1z9vC7Z4NrNKBtbz+jeXy6jBPPzL1qcrUlVwbFvxJMcdT8jga5QOptGT3wK7Rxb+78SSIqAeT6EsNHOv8Jn944fItLQV4dNHyXu0UdtnUuk3+czHnLsjMkiPspmUB0vst0PYohf6sVwFHfcEfmOx1K2sLZ4YOVdIqBx/ojpPiE5AvSku2NMjYZjfe0nKiw/QMftokDMTp2vDYsbLov3jWNQHyMmcFP2hTx4o4tsB3Bl39k7PB2sJ3Qie5IVJB6fuCT2pkuOwUFissPBymxHWDvKfkyL6WAqzAW2MFPZJaGgh+VjnektkGcrljIG+BElmjEDnWTmF7nJm7ZsKMFwbcWnKWzKpppB9NR0/dccZVBuWxIKX0VA7/dcupynJn/+8lTW6MGUs57k2zsl+bc/8yiVAwyLFGWfTXrHUmBtj7ctLsWZ0fP6LAe990dIzbTlulncFnTXptvaskZLalAKvOjW0a+F8i5MSYFiIVyz3kzTaAX/a2/EGY804gaAxybATbHX0Dvc05d7cnRLkz6SWJkGMl6GmFA/Onq+eu3sL1UUJ9ffw+wH/a8mZDEdy8BT6BYhtzVSo/tG142Zo5swngXev6Lm2cVR5rzwVYKI20L2lKYxrh/pkGPqZT3LMvvD+aCT1/1S+dao5eNCm21UA7fcHLW95NUoKuryT0QOt7lEYqK7JXziaA/Vz/DY1bW8bF4F8emdfekfpC593OEPiZRrLn+Pkodxw+bf6amdK1lJOftykNnArKOEC6ruUA78sOLdJAD4eJoycca/CeUd2FKT/0C3Jovu6Ul/gTzHBN0WCrLfITaSWeQe/eMroL0zNc9yojOLWpEgr+qxlNCnOyL0LenQRwrYlCzxrRoG8r+sF+js62yJFpoAbH9unqvLwxyBemNGT+Wp+8oAJ0pIpyj0LvpgA9nhaHnaNFSsivWqBYJTJPFIerh65JNfaGDYu0oEeSaElbG4fdf2Qt9c14eQfeHRHIxJeqgnKklKWPtRxglXXnaOHd0riLbmwDmgEqqik0Heza/iVWeE+FKGNT39NbQX5TC+87AdCHSzmvZwqrdo4FutAC/aDmRpOH3IIeemF0wXnZ9GbAwMU2YQqytnop1uDdZsXAjH/pQOXIC5GDNHo4EPxfenxJ2rKJjuxAdwj8kkmMTzLWgrbFbXMmZQBf0E1jcb1x73EF5agF/rVB+WMDdIsPdH0AdLkv6LwSemeVwTsnQO+iAOjjSsh/9AU/GqH004YRNHAcOoOj0SqR2vV50XXb/BQK0QDHIbBfwv7zWlbaCe9fKymUqBF8cLjXvazlAGcymcy+fP8nKnBigX58b1K2/w8nXL2O+9tGSK1TOkHje9H1HfKHqyirFZQ2RDYRSlNFGVVRHoxQNt0rrOsdJY3yawcXr0gdBvSz688yjhwJUvcl8/cV0txWAeznva0a6FBaLB7uLmx7bMmyhS0HeHd+4yIN8iGbOAnJsUF+UaPXdGwmFBs/P4qFYTNumMBv0Sb1Sn7wiEF5h843H9Iznb33hI5MoSV5VKP3wZYycN1yXuDI76d5kKpTiB5fsvLcOgtz4icc1AyOzera3iITJHyuIEQ+5ouBppOV1ZXd7QrlhwzSQxWU0VgMbvY9jqkAO/aNjwry7srq7hvCTprTnLVitsBFlfA8Bin2c/z0qys3L820+LCr8xdplIca7Voem5wBeafFQlsmrH80ZbzUd8C/rIEWzogyOe+fhlHGlRM+OMLxCPLBfWLwwgnjjuMutIIviUThmxXkV83x3m0tUQoSPraSNqpjjn8ohuMICvs1eLf7gibcHWHysi1Avmck4Vki5PhwnuNdawqfOhX1e5xpW2xB/nTYkSfoUdfvqMnz2RkL/FULfPt4CYG/VQbvxrfBmzcjLIxbWGOA7wiB7zXA94yXEOV/qBxfO7W+K/UFwvtQiHRbCPxkAByM1Z4V5FoS1wBoBd8Z0DPI+0PkH4bo3nAw3z/putpHb5lF/opB/jfd8BwW+F4L9PV9a3lV5hQdO90tF1Rz3n2mwa4a+J4QaJsS9PGMDzyvUTTw/CJ4M5rilwTNV8DtpQbxgRfZLJ3UYLpBb24AcqXOueu0GLhAC+9jVtCNgaDvKeHuCZBGlCAbgPc/GujvDfA1Ct3zlUOogafsRkvgzrXI7T7yooTnaC8Lb37mFB9hl9tebtClCNxugNr9HC35f2N+TfS/OTQQAAAAAElFTkSuQmCC
name: RSA Archer
script:
  commands:
  - arguments:
    - description: ID of the application to create record in
      name: applicationId
      required: true
    - description: 'Record fields in JSON format: { Name1: Value1, Name2: Value2 }.
        Field name is case sensitive.'
      name: fieldsToValues
      required: true
    description: Creates a new content record in the given application.
    name: archer-create-record
    outputs:
    - contextPath: Archer.Record.Id
      description: Content Id
      type: number
    - contextPath: Archer.Record.Fields
      description: Content property fields
  - arguments:
    - description: The Content (record) ID to update
      name: contentId
    - description: ID of the application to update record in
      name: applicationId
      required: true
    - description: 'Record fields in JSON format: { Name1: Value1, Name2: Value2 }.
        Field name is case sensitive.'
      name: fieldsToValues
      required: true
    - description: 'The incident id of the record. For example: id=12345 for INC-12345'
      name: incidentId
    description: Updates existing content record in the given application.
    name: archer-update-record
  - arguments:
    - description: The incident (record) ID to get details for
      name: contentId
    - description: ID of the application to get record from
      name: applicationId
      required: true
    - description: 'The incident id of the record. For example: id=12345 for INC-12345'
      name: incidentId
    description: Gets information about a content record in the given application.
    name: archer-get-record
    outputs:
    - contextPath: Archer.Record.Id
      description: Content Id of the record
      type: number
    - contextPath: Archer.Record
      description: Content property fields
    - contextPath: Archer.Record.Incident Status
      description: Incident Status
    - contextPath: Archer.Record.Record Status
      description: Record Status
    - contextPath: Archer.Record.Last Updated
      description: Last Updated
      type: date
    - contextPath: Archer.Record.Days Open
      description: Days Open
    - contextPath: Archer.Record.Date Created
      description: Date Created
      type: date
    - contextPath: Archer.Record.Title
      description: Title
      type: string
    - contextPath: Archer.Record.Incident Summary
      description: Incident Summary
      type: string
    - contextPath: Archer.Record.Threat Category
      description: Threat Category
    - contextPath: Archer.Record.Threat Valid
      description: Threat Valid
  - arguments:
    - default: true
      description: Get application by name (leave empty to get all applications)
      name: findByName
    - description: Get application by ID (leave empty to get all applications)
      name: findById
    description: Gets application details or list of all applications.
    name: archer-search-applications
    outputs:
    - contextPath: Archer.Applications.Id
      description: Application Id
    - contextPath: Archer.Applications.Type
      description: Application Type
    - contextPath: Archer.Applications.Name
      description: Application Name
    - contextPath: Archer.Applications.Status
      description: Application Status
    - contextPath: Archer.Applications.Guid
      description: Unique Id of application
  - arguments:
    - description: ID of the application to search records in
      name: applicationId
      required: true
    - defaultValue: Incident ID
      description: 'Fields to present in the search results in array format (for example:
        "Title,Incident Summary")'
      isArray: true
      name: fieldsToDisplay
    - defaultValue: '10'
      description: Maximum results to return from the search (default is 10)
      name: maxResults
    - description: Search value (leave empty to search for all)
      name: searchValue
    - description: Name of field to search on (leave empty to search for all)
      name: fieldToSearchOn
    - auto: PREDEFINED
      description: Numeric search operator
      name: numericOperator
      predefined:
      - Equals
      - NotEqual
      - GreaterThan
      - LessThan
    - auto: PREDEFINED
      description: Date search operator
      name: dateOperator
      predefined:
      - Equals
      - DoesNotEqual
      - GreaterThan
      - LessThan
    - auto: PREDEFINED
      description: Order by descending order
      name: isDescending
      predefined:
      - 'true'
      - 'false'
    - auto: PREDEFINED
      description: Get the inner records of the records found by the search
      name: getInnerRecords
      predefined:
      - 'true'
      - 'false'
    - auto: PREDEFINED
      description: Get an extended responses with all of the data regarding this search.
        For example, "fullData=true"
      name: fullData
      predefined:
      - 'true'
      - 'false'
    description: Search for records inside the given application.
    name: archer-search-records
    outputs:
    - contextPath: Archer.Record.Id
      description: Content Id
      type: number
    - contextPath: Archer.Record.ApplicationId
      description: Application Id
      type: number
    - contextPath: Archer.Record.Fields
      description: Content property fields
  - arguments:
    - default: true
      description: ID of the application to search fields in
      name: applicationId
      required: true
    description: Gets all application fields by application ID
    name: archer-get-application-fields
    outputs:
    - contextPath: Archer.ApplicationFields
      description: Content property fields
  - arguments:
    - description: ID of the application to delete record in
      name: applicationId
      required: true
    - description: The Content (record) ID to delete
      name: contentId
    - description: 'The incident id of the record. For example: id=12345 for INC-12345'
      name: incidentId
    description: Delete existing content record in the given application.
    name: archer-delete-record
  - arguments:
    - description: ID of the field
      name: fieldID
      required: true
    - description: ID of the application to get field value from
      name: applicationId
      required: true
    description: Returns mapping from list value name to list value id
    name: archer-get-field
  - arguments: []
    description: Gets all the reports from Archer
    name: archer-get-reports
  - arguments:
    - description: The GUID of the report
      name: reportGuid
      required: true
    - defaultValue: '100'
      description: Maximum pages of the reports
      name: maxResults
    description: Performs statistic search by report Guid
    name: archer-execute-statistic-search-by-report
    outputs:
    - contextPath: Archer.StatisticSearch
      description: The results of the search
  - arguments:
    - description: The GUID of the report
      name: reportGuid
      required: true
    description: 'Returns search criteria by report GUID '
    name: archer-get-search-options-by-guid
  - arguments:
    - description: The GUID of the report
      name: reportGuid
      required: true
    description: Search records by report Guid
    name: archer-search-records-by-report
    outputs:
    - contextPath: Archer.SearchByReport.Records
      description: The records found by the search
    - contextPath: Archer.SearchByReport.RecordsAmount
      description: Amount of records found by the search
    - contextPath: Archer.SearchByReport.FieldDefinitions
      description: Field definitions of the found records
  - arguments:
    - description: Level ID
      name: level
      required: true
    description: Return mapping of fields by level id
    name: archer-get-mapping-by-level
  - arguments:
    - description: 'ID of the application to get the incident from. For example: applicationId="75"'
      name: applicationId
      required: true
    - description: 'The Incident IDs to get details for, separated by commas. For
        example: IncidentIds="12345,67891" '
      name: incidentIds
      required: true
    description: Fetch specific incident from Archer to the war room. Also used for
      manual fetching automation
    name: archer-manually-fetch-incident
  - arguments:
    - description: Archer's file ID
      name: fileId
      required: true
    description: Downloads file from Archer to Demisto's war room context
    name: archer-get-file
  - arguments:
    - description: ID of the application which we want to upload the file to
      name: applicationId
      required: true
    - description: The Content (record) ID to update
      name: contentId
    - description: 'The incident id of the record. For example: id=12345 for INC-12345'
      name: incidentId
    - description: The entry id of the file in Demisto's context
      name: entryId
    - defaultValue: Supporting Documentation
      description: 'Archer field name to associate the file with. Initial value is:
        "Supporting Documentation"'
      name: associatedField
    description: Uploads a file to Archer and adds its id to the context attached
      files
    name: archer-upload-file
  - arguments:
    - description: ID of the application which we want to upload the file to
      name: applicationId
      required: true
    - description: The Content (record) ID to update
      name: contentId
    - description: 'The incident id of the record. For example: id=12345 for INC-12345'
      name: incidentId
    - description: 'The value you want to add to Detailed Analysis. For example: value="test
        string"'
      name: value
      required: true
    description: Add data to Archer's Detailed Analysis field
    name: archer-add-to-detailed-analysis
  - arguments:
    - description: Username in the form of "Domain\username". For example, userInfo="mydomain\myusername"
      name: userInfo
      required: true
    description: Get the user id of an Archer user
    name: archer-get-user-id
    outputs:
    - contextPath: Archer.User.UserId
      description: The user id of the Archer user
  - arguments:
    - description: Field Id
      name: fieldID
      required: true
    description: Returns a list of values for a specified field, e.g., fieldID=16114.
      This command only works for value list fields (type 4).
    name: archer-get-valuelist
  - arguments: []
    description: Reset Archer's integration cache. Run this command if you change
      the fields of your Archer application
    name: archer-reset-cache
  isfetch: true
  runonce: false
  script: "var server = params.server.replace(/\\/+$/, \"\");\n\nvar commands = {\n\
    \  createRecord:     'archer-create-record',\n  updateRecord:     'archer-update-record',\n\
    \  updateRecordREST: 'archer-update-record-rest',\n  getRecord:        'archer-get-record',\n\
    \  searchApps:       'archer-search-applications',\n  searchRecords:    'archer-search-records',\n\
    \  getAppFields:     'archer-get-application-fields',\n  deleteRecord:     'archer-delete-record',\n\
    \  valueListForField: 'archer-get-field',\n  fetchIncidents: 'archer-fetch-incidents',\n\
    \  getReports: 'archer-get-reports',\n  executeStatisticSearchByReport: 'archer-execute-statistic-search-by-report',\n\
    \  getSearchOptionsByGuid: 'archer-get-search-options-by-guid',\n  searchRecordsByReport:\
    \ 'archer-search-records-by-report',\n  getMappingByLevel: 'archer-get-mapping-by-level',\n\
    \  manualFetch: 'archer-manually-fetch-incident',\n  getFile: 'archer-get-file',\n\
    \  uploadFile: 'archer-upload-file',\n  addToDetailedAnalysis: 'archer-add-to-detailed-analysis',\n\
    \  getUserId: 'archer-get-user-id',\n  getSubformId: 'archer-get-subform-id',\n\
    \  getValueList: 'archer-get-valuelist'\n};\n\nvar urlDictionary = {};\nurlDictionary.login\
    \ = '/ws/general.asmx';\nurlDictionary.logout = '/ws/general.asmx';\nurlDictionary.levelIdByModuleId\
    \ = '/api/core/system/level/module/%applicationId%';\nurlDictionary.fieldByLevelId\
    \ = '/api/core/system/fielddefinition/level/%levelId%';\nurlDictionary[commands.createRecord]\
    \ = '/ws/record.asmx';\nurlDictionary[commands.updateRecord] = '/ws/record.asmx';\n\
    urlDictionary[commands.getRecord] = '/ws/record.asmx';\nurlDictionary[commands.searchApps]\
    \ = '/api/core/system/application';\nurlDictionary[commands.searchRecords] = '/ws/search.asmx';\n\
    urlDictionary[commands.deleteRecord] = '/ws/record.asmx';\nurlDictionary[commands.valueListForField]\
    \ = '/ws/field.asmx';\nurlDictionary[commands.getReports] = '/ws/search.asmx';\n\
    urlDictionary[commands.executeStatisticSearchByReport] = '/ws/search.asmx';\n\
    urlDictionary[commands.getSearchOptionsByGuid] = '/ws/search.asmx';\nurlDictionary[commands.searchRecordsByReport]\
    \ = '/ws/search.asmx';\nurlDictionary[commands.getFile] = '/ws/record.asmx';\n\
    urlDictionary[commands.uploadFile] = '/api/core/content/attachment';\nurlDictionary[commands.getUserId]\
    \ = '/ws/accesscontrol.asmx';\n\nvar methodDictionary = {};\nmethodDictionary.login\
    \ = 'POST';\nmethodDictionary.logout = 'POST';\nmethodDictionary.levelIdByModuleId\
    \ = 'POST';\nmethodDictionary.fieldByLevelId = 'POST';\nmethodDictionary[commands.createRecord]\
    \ = 'POST';\nmethodDictionary[commands.updateRecord] = 'POST';\nmethodDictionary[commands.updateRecordREST]\
    \ = 'PUT';\nmethodDictionary[commands.getRecord] = 'POST';\nmethodDictionary[commands.searchApps]\
    \ = 'POST';\nmethodDictionary[commands.searchRecords] = 'POST';\nmethodDictionary[commands.deleteRecord]\
    \ = 'POST';\nmethodDictionary[commands.valueListForField] = 'POST';\nmethodDictionary[commands.getReports]\
    \ = 'POST';\nmethodDictionary[commands.executeStatisticSearchByReport] = 'POST';\n\
    methodDictionary[commands.getSearchOptionsByGuid] = 'POST';\nmethodDictionary[commands.searchRecordsByReport]\
    \ = 'POST';\nmethodDictionary[commands.getFile] = 'POST';\nmethodDictionary[commands.uploadFile]\
    \ = 'POST';\nmethodDictionary[commands.getUserId] = 'POST';\nmethodDictionary[commands.getSubformId]\
    \ = 'POST';\n\nvar GLOBAL_MAPPING = {};\nvar dateRe = /(\\d{1,2})\\/(\\d{1,2})\\\
    /(\\d{4})\\s*(\\d{1,2}):(\\d{2}):(\\d{2})\\s*(AM|PM)/;\n\n// Requests senders\n\
    \nfunction sendRestRequest(url, cmd, bodyContent, httpTunneling, queryParams)\
    \ {\n    var headers = {\n        'Content-Type': ['application/json'],\n    \
    \    'Accept': ['application/json']\n    };\n\n    if(httpTunneling) {\n     \
    \   headers['X-Http-Method-Override'] = ['GET'];\n    }\n\n    var fullurl = server\
    \ + url;\n\n    if (queryParams) {\n        fullurl += queryParams;\n    }\n \
    \   var body = JSON.stringify(bodyContent);\n    var currentToken;\n\n    var\
    \ cache = getIntegrationContext();\n    // if we don't have token\n    if (Object.keys(cache).length\
    \ > 0 && Object.keys(cache).indexOf(\"token\") > -1) {\n        // there is a\
    \ lock in place\n        var locked = true;\n        var total = 0;\n        while\
    \ (Object.keys(cache).indexOf(\"lock\") > -1 && (cache[\"lock\"] === true || cache[\"\
    lock\"] === \"true\") && locked && cache[\"valid\"]){\n            logInfo(\"\
    Waiting for lock to end\");\n            total += 2000;\n            sleep(2000);\n\
    \            cache = getIntegrationContext();\n            if (cache[\"lock\"\
    ] !== true || total > 60000){\n                // breaking lock after 1 minute\n\
    \                locked = false;\n            }\n        }\n        // no lock\n\
    \        if (!(Object.keys(cache).indexOf(\"lock\") > -1) || cache[\"valid\"]\
    \ !== false){\n            currentToken = cache[\"token\"];\n            logInfo(\"\
    Taking token \" + currentToken + \" from cache\")\n        } else {\n        \
    \    currentToken = getAuthToken();\n            var dic = {};\n            dic[\"\
    token\"] = currentToken;\n            dic[\"lock\"] = true;\n            var updatedCache\
    \ = mergeOptions(cache, dic);\n            setIntegrationContext(updatedCache);\n\
    \            logInfo(\"Token wasn't found in cache, created token: \" + currentToken\
    \ + \" and putting it in the cache\")\n        }\n    } else {\n        currentToken\
    \ = getAuthToken();\n        var dic = {};\n        dic[\"token\"] = currentToken;\n\
    \        dic[\"lock\"] = true;\n        var updatedCache = mergeOptions(cache,\
    \ dic);\n        setIntegrationContext(updatedCache);\n        logInfo(\"Token\
    \ wasn't found in cache, created token: \" + currentToken + \" and putting it\
    \ in the cache\")\n    }\n\n    for(i = 0; i<15; i++){\n        if (currentToken)\
    \ {\n            headers.Authorization = ['Archer session-id=' + currentToken];\n\
    \        }\n\n        var result = http(\n            fullurl,\n            {\n\
    \                Method: methodDictionary[cmd],\n                Headers: headers,\n\
    \                Body: body ? body : ''\n            },\n            params.insecure,\n\
    \            params.proxy\n        );\n\n        if (result.StatusCode < 200 ||\
    \ result.StatusCode >= 300) {\n            logInfo('Bad status code from Archer:\
    \ ' + result.StatusCode + ' with session token: ' + headers.Authorization + '\
    \ for request to path: ' + fullurl);\n            logInfo('Result from Archer:\
    \ ' + result.Body + ' request body was: ' + body);\n            // check if we\
    \ are locked and if there is a new token in place already\n            cache =\
    \ getIntegrationContext();\n            var locked = false;\n            var total\
    \ = 0;\n\n            while (Object.keys(cache).indexOf(\"lock\") > -1 && (cache[\"\
    lock\"] === true) && locked){\n                logInfo(\"Waiting for lock to end\"\
    );\n                sleep(2000);\n                cache = getIntegrationContext();\n\
    \                total += 2000;\n\n                if (cache[\"lock\"] !== true\
    \ || total > 60000){\n                    // breaking the lock after 1 minute\n\
    \                    locked = false;\n                }\n            }\n     \
    \       if (Object.keys(cache).indexOf(\"valid\") > -1 && cache[\"valid\"] ===\
    \ true && cache[\"token\"] !== currentToken){\n                currentToken =\
    \ cache[\"token\"];\n            } else {\n                currentToken = getAuthToken();\n\
    \            }\n\n            var dic = {};\n            dic[\"token\"] = currentToken;\n\
    \            dic[\"lock\"] = true;\n            var updatedCache = mergeOptions(cache,\
    \ dic);\n            setIntegrationContext(updatedCache);\n            logInfo(\"\
    Putting a newly token in cache which was generated after an error, token is: \"\
    \ + currentToken);\n\n            if (i==14){\n                var dic = {};\n\
    \                dic[\"valid\"] = false;\n                dic[\"lock\"] = false;\n\
    \                var updatedCache = mergeOptions(cache, dic);\n              \
    \  setIntegrationContext(updatedCache);\n                throw 'Request to RSA\
    \ Archer ' + fullurl + ' failed, request status code: ' + result.StatusCode +\
    \ ' and Body: ' + result.Body + '.';\n            }\n            continue;\n \
    \       }\n        logInfo('Successful request to RSA Archer ' + fullurl + ' with\
    \ session token: ' + currentToken);\n        var dic = {};\n        dic[\"token\"\
    ] = currentToken;\n        dic[\"valid\"] = true;\n        dic[\"lock\"] = false;\n\
    \        var updatedCache = mergeOptions(cache, dic);\n        setIntegrationContext(updatedCache);\n\
    \        return JSON.parse(result.Body);\n    }\n}\n\nfunction soapRequestSender(cmd,\
    \ bodyContent, SOAPAction) {\n    var headers = {'Content-Type': ['text/xml; charset=utf-8']};\n\
    \    if (SOAPAction) {\n        headers.SOAPAction = [SOAPAction];\n    }\n  \
    \  var url =  server +  urlDictionary[cmd];\n    var result = http(\n        url,\n\
    \        {\n            Method: methodDictionary[cmd],\n            Headers: headers,\n\
    \            Body: bodyContent\n        },\n        params.insecure,\n       \
    \ params.proxy\n    );\n    return result;\n}\n\nfunction sendSoapRequest(cmd,\
    \ bodyContent, SOAPAction) {\n    var headers = {'Content-Type': ['text/xml; charset=utf-8']};\n\
    \    if (SOAPAction) {\n        headers.SOAPAction = [SOAPAction];\n    }\n  \
    \  var url =  server +  urlDictionary[cmd];\n    var result = http(\n        url,\n\
    \        {\n            Method: methodDictionary[cmd],\n            Headers: headers,\n\
    \            Body: bodyContent\n        },\n        params.insecure,\n       \
    \ params.proxy\n    );\n\n    if (result.StatusCode < 200 || result.StatusCode\
    \ >= 300) {\n        throw 'Request to RSA Archer ' + url + ' failed, request\
    \ status code: ' + result.StatusCode + ' and Body: ' + result.Body + '.';\n  \
    \  }\n\n    return result.Body;\n}\n\nfunction getRecordSendSoapRequest(cmd, applicationId,\
    \ contentId) {\n    var currentToken;\n    var cache = getIntegrationContext();\n\
    \    // if we don't have token\n    if (Object.keys(cache).length > 0 && Object.keys(cache).indexOf(\"\
    token\") > -1) {\n        currentToken = cache[\"token\"];\n    } else {\n   \
    \     currentToken = getAuthToken();\n        var dic = {};\n        dic[\"token\"\
    ] = currentToken;\n        var updatedCache = mergeOptions(cache, dic);\n    \
    \    setIntegrationContext(updatedCache);\n    }\n\n    for(var i = 0; i<5; i++){\n\
    \        var soap = getContentSoapRequest(currentToken, applicationId, contentId);\n\
    \        var SOAPAction = 'http://archer-tech.com/webservices/GetRecordById';\n\
    \        var result = soapRequestSender(cmd, soap, SOAPAction);\n        if (result.StatusCode\
    \ < 200 || result.StatusCode >= 300) {\n            if (result.StatusCode ===\
    \ 500 || result.StatusCode === -1 || result.StatusCode === 401){ // unauthorized,\
    \ try again\n                currentToken = getAuthToken();\n                var\
    \ dic = {};\n                dic[\"token\"] = currentToken;\n                var\
    \ updatedCache = mergeOptions(cache, dic);\n                setIntegrationContext(updatedCache);\n\
    \                continue;\n            }\n            throw 'Request to RSA Archer\
    \ failed, request status code: ' + result.StatusCode + ' and Body: ' + result.Body\
    \ + '.';\n        }\n        return result.Body;\n    }\n}\n\nfunction searchSendSoapRequest(\n\
    \  cmd,\n  appId,\n  fields,\n  maxResults,\n  fieldIdToSearchOn,\n  fieldNameToSearchOn,\n\
    \  searchValue,\n  sortByFieldId, isDescending, numericOperator, dateOperator,\
    \ pageNumber, fetchFilter) {\n    var currentToken;\n\n    var cache = getIntegrationContext();\n\
    \    // if we don't have token\n    if (Object.keys(cache).length > 0 && Object.keys(cache).indexOf(\"\
    token\") > -1) {\n        // there is a lock in place\n        var locked = true;\n\
    \        var total = 0;\n        while (Object.keys(cache).indexOf(\"lock\") >\
    \ -1 && (cache[\"lock\"] === true || cache[\"lock\"] === \"true\") && locked &&\
    \ cache[\"valid\"]){\n            logInfo(\"Waiting for lock to end\");\n    \
    \        total += 2000;\n            sleep(2000);\n            cache = getIntegrationContext();\n\
    \            if (cache[\"lock\"] !== true || total > 60000){\n               \
    \ // breaking lock after 1 minute\n                locked = false;\n         \
    \   }\n        }\n        // no lock\n        if (!(Object.keys(cache).indexOf(\"\
    lock\") > -1) || cache[\"valid\"] !== false){\n            currentToken = cache[\"\
    token\"];\n            logInfo(\"Taking token \" + currentToken + \" from cache\"\
    )\n        } else {\n            currentToken = getAuthToken();\n            var\
    \ dic = {};\n            dic[\"token\"] = currentToken;\n            dic[\"lock\"\
    ] = true;\n            var updatedCache = mergeOptions(cache, dic);\n        \
    \    setIntegrationContext(updatedCache);\n            logInfo(\"Token wasn't\
    \ found in cache, created token: \" + currentToken + \" and putting it in the\
    \ cache\")\n        }\n    } else {\n        currentToken = getAuthToken();\n\
    \        var dic = {};\n        dic[\"token\"] = currentToken;\n        dic[\"\
    lock\"] = true;\n        var updatedCache = mergeOptions(cache, dic);\n      \
    \  setIntegrationContext(updatedCache);\n        logInfo(\"Token wasn't found\
    \ in cache, created token: \" + currentToken + \" and putting it in the cache\"\
    )\n    }\n\n    for(var i = 0; i<15; i++){\n        var soap = getContentsByAppIdRequest(\n\
    \                currentToken,\n                appId,\n                fields,\n\
    \                maxResults,\n                fieldIdToSearchOn,\n           \
    \     fieldNameToSearchOn,\n                searchValue,\n                sortByFieldId,\n\
    \                isDescending,\n                numericOperator,\n           \
    \     dateOperator,\n                pageNumber,\n                fetchFilter);\n\
    \n        var SOAPAction = 'http://archer-tech.com/webservices/ExecuteSearch';\n\
    \        var result = soapRequestSender(cmd, soap, SOAPAction);\n        if (result.StatusCode\
    \ < 200 || result.StatusCode >= 300) {\n            if (result.StatusCode ===\
    \ 500 || result.StatusCode === 401 || result.StatusCode === -1){ // unauthorized,\
    \ try again\n                // check if we are locked and if there is a new token\
    \ in place already\n                cache = getIntegrationContext();\n       \
    \         var locked = false;\n                var total = 0;\n\n            \
    \    while (Object.keys(cache).indexOf(\"lock\") > -1 && (cache[\"lock\"] ===\
    \ true) && locked){\n                    logInfo(\"Waiting for lock to end\");\n\
    \                    sleep(2000);\n                    cache = getIntegrationContext();\n\
    \                    total += 2000;\n\n                    if (cache[\"lock\"\
    ] !== true || total > 60000){\n                        // breaking the lock after\
    \ 1 minute\n                        locked = false;\n                    }\n \
    \               }\n                if (Object.keys(cache).indexOf(\"valid\") >\
    \ -1 && cache[\"valid\"] === true && cache[\"token\"] !== currentToken){\n   \
    \                 currentToken = cache[\"token\"];\n                } else {\n\
    \                    currentToken = getAuthToken();\n                }\n\n   \
    \             var dic = {};\n                dic[\"token\"] = currentToken;\n\
    \                dic[\"lock\"] = true;\n                var updatedCache = mergeOptions(cache,\
    \ dic);\n                setIntegrationContext(updatedCache);\n              \
    \  logInfo(\"Putting a newly token in cache which was generated after an error,\
    \ token is: \" + currentToken);\n\n                if (i==14){\n             \
    \       var dic = {};\n                    dic[\"valid\"] = false;\n         \
    \           dic[\"lock\"] = false;\n                    var updatedCache = mergeOptions(cache,\
    \ dic);\n                    setIntegrationContext(updatedCache);\n          \
    \          throw 'Request to RSA Archer ' + soap + ' failed, request status code:\
    \ ' + result.StatusCode + ' and Body: ' + result.Body + '.';\n               \
    \ }\n                continue;\n            }\n            throw 'Request to RSA\
    \ Archer ' + soap + ' failed, request status code: ' + result.StatusCode + ' and\
    \ Body: ' + result.Body + '.';\n\n        }\n        logInfo('Successful search\
    \ records request to RSA Archer with session token: ' + currentToken);\n     \
    \   var dic = {};\n        dic[\"token\"] = currentToken;\n        dic[\"valid\"\
    ] = true;\n        dic[\"lock\"] = false;\n        var updatedCache = mergeOptions(cache,\
    \ dic);\n        setIntegrationContext(updatedCache);\n\n        return result.Body;\n\
    \    }\n}\n\nfunction downloadFileSendSoapRequest(cmd, fileId) {\n    var currentToken;\n\
    \    var cache = getIntegrationContext();\n    // if we don't have token\n   \
    \ if (Object.keys(cache).length > 0 && Object.keys(cache).indexOf(\"token\") >\
    \ -1) {\n        currentToken = cache[\"token\"];\n    } else {\n        currentToken\
    \ = getAuthToken();\n        var dic = {};\n        dic[\"token\"] = currentToken;\n\
    \        var updatedCache = mergeOptions(cache, dic);\n        setIntegrationContext(updatedCache);\n\
    \    }\n\n    for(var i = 0; i<5; i++){\n        var soap = getAttachmentFileSoapRequest(currentToken,\
    \ fileId);\n        var SOAPAction = 'http://archer-tech.com/webservices/GetAttachmentFile';\n\
    \        var result = soapRequestSender(cmd, soap, SOAPAction);\n        if (result.StatusCode\
    \ < 200 || result.StatusCode >= 300) {\n            if (result.StatusCode ===\
    \ 500 || result.StatusCode === -1 || result.StatusCode === 401){ // unauthorized,\
    \ try again\n                currentToken = getAuthToken();\n                var\
    \ dic = {};\n                dic[\"token\"] = currentToken;\n                var\
    \ updatedCache = mergeOptions(cache, dic);\n                setIntegrationContext(updatedCache);\n\
    \                continue;\n            }\n            throw 'Request to RSA Archer\
    \ ' + url + ' failed, request status code: ' + result.StatusCode + ' and Body:\
    \ ' + result.Body + '.';\n        }\n        return result.Body;\n    }\n}\n\n\
    function getContentIdsByIncIdsSendSoapRequest(appId, displayFields, incidentIds,\
    \ levelId, displayId) {\n    var currentToken = getAuthToken();\n    var incidentIds;\n\
    \    for(var i = 0; i<5; i++){\n        var soap = getRecordIdsByIncIdsSoapRequest(currentToken,\
    \ appId, displayFields, incidentIds, levelId, displayId);\n        var SOAPAction\
    \ = 'http://archer-tech.com/webservices/ExecuteSearch';\n        var result =\
    \ soapRequestSender('archer-search-records', soap, SOAPAction);\n        if (result.StatusCode\
    \ < 200 || result.StatusCode >= 300) {\n            if (result.StatusCode ===\
    \ 500|| result.StatusCode === 401 || result.StatusCode === -1){ // unauthorized,\
    \ try again\n                currentToken = getAuthToken();\n                continue;\n\
    \            }\n            throw 'Request to RSA Archer ' + soap + ' failed,\
    \ request status code: ' + result.StatusCode + ' and Body: ' + result.Body + '.';\n\
    \        }\n        return result.Body;\n    }\n}\n\nfunction getAuthToken() {\n\
    \    var soap = createUserSessionFromInstanceSoapRequest(params.instanceName,\n\
    \                                                        params.credentials.identifier,\n\
    \                                                        params.credentials.password);\n\
    \    var SOAPAction = 'http://archer-tech.com/webservices/CreateUserSessionFromInstance';\n\
    \    var rawResponse;\n    var result;\n    var url;\n    for (var i = 0; i<5;\
    \ i++){\n        result = soapRequestSender('login', soap, SOAPAction);\n    \
    \    if (result.StatusCode < 200 || result.StatusCode >= 300) {\n            if\
    \ (result.StatusCode === 500 || result.StatusCode === -1 || result.StatusCode\
    \ === 401){ // unauthorized, try again\n                continue;\n          \
    \  }\n            throw 'Request to RSA Archer ' + url + ' failed, request status\
    \ code: ' + result.StatusCode + ' and Body: ' + result.Body + '.';\n        }\n\
    \        rawResponse = result.Body;\n        break;\n    }\n    try {\n      \
    \  var response = JSON.parse(x2j(rawResponse));\n    } catch (err) {\n       \
    \ throw \"Problem with login, please make sure that you have the right credentials.\
    \ Original server response: \" + rawResponse + \" Error was: \" + err\n    }\n\
    \    if (typeof rawResponse !== 'string' || rawResponse.length == 0) {\n     \
    \   throw \"Login failed. Request = \" + soap + \" Response = \" + rawResponse;\n\
    \    }\n\n    var token = dq(response, 'Envelope.Body.CreateUserSessionFromInstanceResponse.CreateUserSessionFromInstanceResult');\n\
    \    return token;\n}\n\nfunction destroyAuthToken(token) {\n    var soap = terminateSessionSoapRequest(token);\n\
    \    var SOAPAction = 'http://archer-tech.com/webservices/TerminateSession';\n\
    \    for (var i = 0; i<5; i++){\n        try {\n            var result = soapRequestSender('logout',\
    \ soap, SOAPAction);\n            if (result.StatusCode < 200 || result.StatusCode\
    \ >= 300) {\n                if (result.StatusCode === 500 || result.StatusCode\
    \ === -1){ // unauthorized, try again\n                    continue;\n       \
    \         }\n                throw 'destroyAuthToken Request to RSA Archer failed,\
    \ request status code: ' + result.StatusCode + ' and Body: ' + result.Body + '.';\n\
    \            }\n\n            return;\n        } catch(err) {\n            if\
    \ (err.indexOf('Invalid session token') > -1) {\n                // it means the\
    \ session token already expired so no need to be terminated\n                return;\n\
    \            }\n            throw err;\n        }\n    }\n}\n\n/**\n * Overwrites\
    \ obj1's values with obj2's and adds obj2's if non existent in obj1\n * @param\
    \ obj1\n * @param obj2\n * @returns obj3 a new object based on obj1 and obj2\n\
    \ */\nfunction mergeOptions(obj1,obj2){\n    var obj3 = {};\n    for (var attrname\
    \ in obj1) { obj3[attrname] = obj1[attrname]; }\n    for (var attrname in obj2)\
    \ { obj3[attrname] = obj2[attrname]; }\n    return obj3;\n}\n\nfunction sleep(ms)\
    \ {\n    var start = new Date().getTime();\n    var expire = start + ms;\n   \
    \ while (new Date().getTime() < expire) {\n        /*Do nothing*/\n    }\n   \
    \ return;\n}\n\n// SOAP templates creators\n\nfunction createUserSessionFromInstanceSoapRequest(instanceName,\
    \ userName, password) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"\
    utf-8\"?>' +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '  <soap:Body>' +\n    '    <CreateUserSessionFromInstance xmlns=\"\
    http://archer-tech.com/webservices/\">' +\n    '      <userName>' + userName +\
    \ '</userName>' +\n    '      <instanceName>' + instanceName + '</instanceName>'\
    \ +\n    '      <password>' + escapeXMLChars(password) + '</password>' +\n   \
    \ '    </CreateUserSessionFromInstance>' +\n    '  </soap:Body>' +\n    '</soap:Envelope>'\n\
    \    );\n}\n\nfunction terminateSessionSoapRequest(token) {\n    return(\n   \
    \ '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n    '<soap:Envelope xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n    '    <soap:Body>'\
    \ +\n    '        <TerminateSession xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '        <sessionToken>' + token + '</sessionToken>' +\n    '      \
    \  </TerminateSession>' +\n    '    </soap:Body>' +\n    '</soap:Envelope>'\n\
    \    );\n}\n\nfunction getContentsByAppIdRequest(token, appId, displayFields,\
    \ maxResults,\n    fieldIdToSearchOn, fieldNameToSearchOn, searchValue, sortByFieldId,\n\
    \    isDescending, numericOperator, dateOperator, pageNumber, fetchFilter) {\n\
    \    var readyMaxResults = (maxResults === undefined || maxResults === null) ?\
    \ '100' : maxResults;\n    return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\"\
    ?>' +\n    '<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    >' +\n    '   <soap:Body>' +\n    '       <ExecuteSearch xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '   \
    \        <searchOptions>' +\n    '               <![CDATA[' +\n    '         \
    \          <SearchReport>' +\n    '                       <PageSize>' + readyMaxResults\
    \ + '</PageSize>' +\n    '                       <PageNumber>' + pageNumber +\
    \ '</PageNumber>' +\n    '                       <MaxRecordCount>' + (readyMaxResults\
    \ || '1') + '</MaxRecordCount>' +\n    '                       <ShowStatSummaries>false</ShowStatSummaries>'\
    \ +\n    '                       <DisplayFields>' + displayFields + '</DisplayFields>'\
    \ +\n    '                       <Criteria>' +\n    '                        \
    \   <ModuleCriteria>' +\n    '                               <Module name=\"appname\"\
    >' + appId + '</Module>' +\n    '                           </ModuleCriteria>'\
    \ +\n                                (fieldIdToSearchOn ?\n    '             \
    \              <Filter>' +\n    '                               <Conditions>'\
    \ +\n                                        (dateOperator ?\n    '          \
    \                         <DateComparisonFilterCondition>' +\n    '          \
    \                             <Operator>' + dateOperator + '</Operator>' +\n \
    \   '                                       <Field name=\"'+ escapeXMLChars(fieldNameToSearchOn)\
    \ +'\">' + fieldIdToSearchOn + '</Field>' +\n    '                           \
    \            <Value>' + searchValue + '</Value>' +\n    '                    \
    \                   <TimeZoneId>UTC Standard Time</TimeZoneId>' +\n    '     \
    \                                  <IsTimeIncluded>TRUE</IsTimeIncluded>' +\n\
    \    '                                   </DateComparisonFilterCondition>' : '')\
    \ +\n                                        ((!dateOperator && numericOperator)\
    \ ?\n    '                                   <NumericFilterCondition>' +\n   \
    \ '                                       <Operator>' + numericOperator + '</Operator>'\
    \ +\n    '                                       <Field name=\"'+ escapeXMLChars(fieldNameToSearchOn)\
    \ +'\">' + fieldIdToSearchOn + '</Field>' +\n    '                           \
    \            <Value>' + searchValue + '</Value>' +\n    '                    \
    \               </NumericFilterCondition>' : '') +\n                         \
    \               ((!dateOperator && !numericOperator) ?\n    '                \
    \                   <TextFilterCondition>' +\n    '                          \
    \             <Operator>Contains</Operator>' +\n    '                        \
    \               <Field name=\"'+ escapeXMLChars(fieldNameToSearchOn) +'\">' +\
    \ fieldIdToSearchOn + '</Field>' +\n    '                                    \
    \   <Value>' + searchValue + '</Value>' +\n    '                             \
    \      </TextFilterCondition>' : '') +\n                                     \
    \   (fetchFilter ? fetchFilter : \"\") +\n    '                              \
    \ </Conditions>' +\n    '                           </Filter>'\n             \
    \                   : '') +\n                                (sortByFieldId ?\n\
    \    '                           <SortFields>' +\n    '                      \
    \         <SortField>' +\n    '                                   <Field>' + sortByFieldId\
    \ + '</Field>' +\n    '                                   <SortType>' + (isDescending\
    \ ? 'Descending' : 'Ascending') + '</SortType>' +\n    '                     \
    \          </SortField>' +\n    '                           </SortFields>'\n \
    \                               : '') +\n    '                       </Criteria>'\
    \ +\n    '                   </SearchReport>' +\n    '               ]]>' +\n\
    \    '           </searchOptions>' +\n    '           <pageNumber>1</pageNumber>'\
    \ +\n    '       </ExecuteSearch>' +\n    '   </soap:Body>' +\n    '</soap:Envelope>'\n\
    \    );\n}\n\nfunction createContentSoapRequest(token, appId, fields) {\n    return\
    \ (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n    '<soap:Envelope xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchema- instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n    '   <soap:Body>'\
    \ +\n    '       <CreateRecord xmlns=\"http://archer-tech.com/webservices/\">'\
    \ +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '    \
    \       <moduleId>' + appId + '</moduleId>' +\n    '           <fieldValues> '\
    \ +\n    '               <![CDATA[ ' +\n    '                   <Record>' + fields\
    \ + '</Record>' +\n    '                ]]>' +\n    '           </fieldValues>'\
    \ +\n    '       </CreateRecord>' +\n    '   </soap:Body> ' +\n    '</soap:Envelope>'\n\
    \    );\n}\n\nfunction updateContentSoapRequest(token, appId, contentId, fields)\
    \ {\n    return (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?> ' +\n    '<soap:Envelope\
    \ xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n    '   <soap:Body>'\
    \ +\n    '       <UpdateRecord xmlns=\"http://archer-tech.com/webservices/\">'\
    \ +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '    \
    \       <moduleId>' + appId + '</moduleId>' +\n    '           <contentId>' +\
    \ contentId +'</contentId>' +\n    '           <fieldValues>' +\n    '       \
    \        <![CDATA[' +\n    '                   <UpdateRecord>' + fields + '</UpdateRecord>'\
    \ +\n    '               ]]>' +\n    '           </fieldValues>' +\n    '    \
    \   </UpdateRecord>' +\n    '   </soap:Body>' +\n    '</soap:Envelope>'\n    );\n\
    }\n\nfunction getContentSoapRequest(token, appId, contentId) {\n    return (\n\
    \    '<?xml version=\"1.0\" encoding=\"utf-8\"?> ' +\n    '<soap:Envelope xmlns:xsi=\"\
    http://www.w3.org/2001/XMLSchemainstance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">' +\n    '   <soap:Body>'\
    \ +\n    '       <GetRecordById xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '   \
    \        <moduleId>' + appId + '</moduleId>' +\n    '           <contentId>' +\
    \ contentId +'</contentId>' +\n    '       </GetRecordById>' +\n    '   </soap:Body>'\
    \ +\n    '</soap:Envelope>'\n    );\n}\n\nfunction deleteContentSoapRequest(token,\
    \ appId, contentId) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"\
    ?>' +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '   <soap:Body>' +\n    '       <DeleteRecord xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '   \
    \        <moduleId>' + appId + '</moduleId>' +\n    '           <contentId>' +\
    \ contentId + '</contentId>' +\n    '       </DeleteRecord>' +\n    '   </soap:Body>'\
    \ +\n    '</soap:Envelope>'\n    );\n}\n\nfunction getValueListForFieldSoapRequest(token,\
    \ fieldID){\n    return (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>'+\n\
    \    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\" xmlns:xsd=\"\
    http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >'+\n        '<soap:Body>'+\n            '<GetValueListForField xmlns=\"http://archer-tech.com/webservices/\"\
    >'+\n                '<sessionToken>'+token+'</sessionToken>'+\n             \
    \   '<fieldId>'+fieldID+'</fieldId>'+\n            '</GetValueListForField>'+\n\
    \        '</soap:Body>'+\n    '</soap:Envelope>'\n    );\n}\n\nfunction getReportsSoapRequest(token){\n\
    \    return (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>'+\n    '<soap:Envelope\
    \ xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \ xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">'+\n        '<soap:Body>'+\n\
    \            '<GetReports xmlns=\"http://archer-tech.com/webservices/\">'+\n \
    \               '<sessionToken>'+token+'</sessionToken>'+\n            '</GetReports>'+\n\
    \        '</soap:Body>'+\n    '</soap:Envelope>'\n    );\n}\n\nfunction executeStatisticSearchByReportSoapRequest(token,\
    \ reportGuid, maxResults) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"\
    utf-8\"?>' +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '  <soap:Body>' +\n    '    <ExecuteStatisticSearchByReport xmlns=\"\
    http://archer-tech.com/webservices/\">' +\n    '      <sessionToken>' + token\
    \ + '</sessionToken>' +\n    '      <reportIdOrGuid>' + reportGuid + '</reportIdOrGuid>'\
    \ +\n    '      <pageNumber>' + maxResults + '</pageNumber>' +\n    '    </ExecuteStatisticSearchByReport>'\
    \ +\n    '  </soap:Body>' +\n    '</soap:Envelope>'\n    );\n}\n\nfunction getSearchOptionsByGuidSoapRequest(token,\
    \ reportGuid) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\
    \ +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '  <soap:Body>' +\n    '    <GetSearchOptionsByGuid xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '      <sessionToken>' + token + '</sessionToken>' +\n    '      <searchReportGuid>'\
    \ + reportGuid + '</searchReportGuid>' +\n    '    </GetSearchOptionsByGuid>'\
    \ +\n    '  </soap:Body>' +\n    '</soap:Envelope>'\n    );\n}\n\nfunction searchRecordsByReportSoapRequest(token,\
    \ reportGuid, pageNumber) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"\
    utf-8\"?>' +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '  <soap:Body>' +\n    '    <SearchRecordsByReport xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '      <sessionToken>' + token + '</sessionToken>' +\n    '      <reportIdOrGuid>'\
    \ + reportGuid + '</reportIdOrGuid>' +\n    '      <pageNumber>' + pageNumber\
    \ + '</pageNumber>' +\n    '    </SearchRecordsByReport>' +\n    '  </soap:Body>'\
    \ +\n    '</soap:Envelope>'\n    );\n}\n\nfunction getAttachmentFileSoapRequest(token,\
    \ fileId) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?>' +\n\
    \    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"\
    http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '  <soap:Body>' +\n    '    <GetAttachmentFile xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '      <sessionToken>' + token + '</sessionToken>' +\n    '      <fileId>'\
    \ + fileId + '</fileId>' +\n    '    </GetAttachmentFile>' +\n    '  </soap:Body>'\
    \ +\n    '</soap:Envelope>'\n    );\n}\n\nfunction getRecordIdsByIncIdsSoapRequest(token,\
    \ appId, displayFields, incidentIds, levelId, displayId) {\n    return (\n   \
    \ '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n    '<soap:Envelope xmlns:soap=\"\
    http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\
    \ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">' +\n    '   <soap:Body>'\
    \ +\n    '       <ExecuteSearch xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '   \
    \        <searchOptions>' +\n    '               <![CDATA[' +\n    '         \
    \          <SearchReport>' +\n    '                       <PageSize> 100 </PageSize>'\
    \ +\n    '                       <DisplayFields>'+\n    '                    \
    \       <DisplayField name=\"Incident Id\">'+displayId+'</DisplayField> '+\n \
    \   '                       </DisplayFields>' +\n    '                       <Criteria>'\
    \ +\n    '                           <Keywords>' + incidentIds + '</Keywords>'\
    \ +\n    '                           <ModuleCriteria>' +\n    '              \
    \                 <Module name=\"appname\">' + appId + '</Module>' +\n    '  \
    \                             <IsKeywordModule>true</IsKeywordModule>' +\n   \
    \ '                               <LevelIds> ' +\n    '                      \
    \             <LevelId>' + levelId + '</LevelId>' +\n    '                   \
    \            </LevelIds>' +\n    '                           </ModuleCriteria>'\
    \ +\n    '                       </Criteria>' +\n    '                   </SearchReport>'\
    \ +\n    '               ]]>' +\n    '           </searchOptions>' +\n    '  \
    \         <pageNumber>1</pageNumber>' +\n    '       </ExecuteSearch>' +\n   \
    \ '   </soap:Body>' +\n    '</soap:Envelope>'\n    );\n}\n\nfunction getContentSubFormSoapRequest(token,\
    \ appId, fieldId, fieldValues) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"\
    utf-8\"?> ' +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '   <soap:Body>' +\n    '       <CreateSubformRecord xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '   \
    \        <subformModuleId>' + appId + '</subformModuleId>' +\n    '          \
    \ <subformFieldId>' + fieldId +'</subformFieldId>' +\n    '           <fieldValues>'\
    \ +\n    '               <![CDATA[' +\n    '                   <CreateSubformRecord>'\
    \ + fieldValues + '</CreateSubformRecord>' +\n    '               ]]>' +\n   \
    \ '           </fieldValues>' +\n    '       </CreateSubformRecord>' +\n    '\
    \   </soap:Body>' +\n    '</soap:Envelope>'\n    );\n}\n\nfunction getUserIdSoapRequest(token,\
    \ userName, userDomain) {\n    return (\n    '<?xml version=\"1.0\" encoding=\"\
    utf-8\"?> ' +\n    '<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\"\
    \ xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\
    >' +\n    '   <soap:Body>' +\n    '       <LookupDomainUserId xmlns=\"http://archer-tech.com/webservices/\"\
    >' +\n    '           <sessionToken>' + token + '</sessionToken>' +\n    '   \
    \        <username>' + userName + '</username>' +\n    '           <usersDomain>'\
    \ + userDomain +'</usersDomain>' +\n    '       </LookupDomainUserId>' +\n   \
    \ '   </soap:Body>' +\n    '</soap:Envelope>'\n    );\n}\n// helper functions\n\
    \nfunction extractObjectFromXML(xml, path) {\n    var searchRes = dq(xml, path);\n\
    \    if (searchRes === \"\" || searchRes === null){\n        return [];\n    }\n\
    \    if (searchRes.indexOf(\"<?xml\") > -1) {\n        var index = searchRes.indexOf(\"\
    >\");\n        if (index !== -1) {\n            searchRes = searchRes.substr(index\
    \ + 1);\n        }\n    }\n    return JSON.parse(x2j(searchRes));\n}\n\nfunction\
    \ verifyOrMakeArray(arr){\n    return Array.isArray(arr)? arr : [arr];\n}\n\n\
    function createInnerRecordsHumanReadable(tables){\n    var markdown = \"\";\n\
    \    tables.forEach(function (table){\n        markdown += tableToMarkdown(table[0],\
    \ table[2], table[1]);\n    });\n    return markdown;\n}\n\nfunction reLogin(token){\n\
    \    destroyAuthToken(token);\n    return getAuthToken();\n}\n\nfunction getValueListJustForField(dataArgs)\
    \ {\n    // used to get a list of values corresponding to a specific field id\n\
    \    var result = getValueListResult(commands.valueListForField, dataArgs);\n\n\
    \    result = JSON.parse(x2j(result));\n    results = {}\n    results['valueList']\
    \ = result\n    return results\n}\n\nfunction getValueListResult(command, dataArgs){\n\
    \    // used to get a list of values corresponding to a specific field id\n  \
    \  var SOAPAction = 'http://archer-tech.com/webservices/GetValueListForField';\n\
    \    var fieldID = dataArgs.fieldID;\n\n    var token;\n    var response;\n  \
    \  for (var i=0; i<15; i++){\n        var cache = getIntegrationContext();\n \
    \       // if we don't have token\n        if (Object.keys(cache).length > 0 &&\
    \ Object.keys(cache).indexOf(\"token\") > -1) {\n            token = cache[\"\
    token\"];\n        } else {\n            token = getAuthToken();\n           \
    \ var dic = {};\n            dic[\"token\"] = token;\n            var updatedCache\
    \ = mergeOptions(cache, dic);\n            setIntegrationContext(updatedCache);\n\
    \        }\n        var soap = getValueListForFieldSoapRequest(token, fieldID);\n\
    \        try {\n            response = JSON.parse(x2j(sendSoapRequest(command,\
    \ soap, SOAPAction)));\n            break;\n        } catch (err) {\n        \
    \    if (i==14){\n                throw \"Archer didn't create a new record. We\
    \ received the following response \" + JSON.stringify(response);\n           \
    \ }\n            token = getAuthToken();\n            var dic = {};\n        \
    \    dic[\"token\"] = token;\n            var updatedCache = mergeOptions(cache,\
    \ dic);\n            setIntegrationContext(updatedCache);\n        }\n    }\n\
    \    return dq(response, 'Envelope.Body.GetValueListForFieldResponse.GetValueListForFieldResult');\n\
    }\n\nfunction getValueListForField(command, dataArgs){\n    var result = getValueListResult(command,\
    \ dataArgs);\n    result = dq(JSON.parse(x2j(result)), 'SelectDef.SelectDefValues.SelectDefValue(true)={Name:\
    \ val.Name, Id : val.Id}');\n\n    if (typeof result === 'object' && result.constructor\
    \ === Array)\n    {\n\n    }\n    else\n    {\n        result = [result];\n  \
    \  }\n    var ret = {};\n    for (var key in result){\n        ret[result[key]['Name']]\
    \ = result[key]['Id'];\n    }\n    return ret;\n}\n\nfunction inputToXML(fieldsToValue,\
    \ mapping){\n    var fields = '';\n    for (var key in fieldsToValue) {\n    \
    \    if (mapping[key] !== undefined) {\n            switch(mapping[key].Type){\n\
    \                case 1:\n                case 2:\n                case 3:\n \
    \               case 11:\n                    if (Array.isArray(fieldsToValue[key])){\n\
    \                        fields += '<Field id=\"' + mapping[key].Id +'\" value=\"\
    ' + fieldsToValue[key][0] +'\">';\n                        for(var i=1; i<fieldsToValue[key].length;\
    \ i++){\n                            fields+= '<MultiValue value=\"'+fieldsToValue[key][i]+'\"\
    \ />';\n                        }\n                        fields+= '</Field>';\n\
    \                    } else{\n                        fields += '<Field id=\"\
    ' + mapping[key].Id +'\" value=\"' + fieldsToValue[key] + '\" />';\n         \
    \           }\n                    break;\n                case 19:\n        \
    \            fields += '<Field id=\"' + mapping[key].Id +'\" value=\"' + fieldsToValue[key]\
    \ + '\" />';\n                    break;\n                case 9:\n          \
    \          if (Array.isArray(fieldsToValue[key])){\n                        fields\
    \ += '<Field id=\"' + mapping[key].Id +'\" value=\"' + fieldsToValue[key][0] +'\"\
    >';\n                        for(var i=1; i<fieldsToValue[key].length; i++){\n\
    \                            fields+= '<MultiValue value=\"'+fieldsToValue[key][i]+'\"\
    \ />';\n                        }\n                        fields+= '</Field>';\n\
    \                    } else{\n                        fields += '<Field id=\"\
    ' + mapping[key].Id +'\" value=\"' + fieldsToValue[key] + '\" />';\n         \
    \           }\n                    break;\n                case 18:\n        \
    \            fields += '<Field id=\"' + mapping[key].Id +'\" value=\"' + fieldsToValue[key][0]\
    \ +'\">';\n                    for(var i=1; i<fieldsToValue[key].length; i++){\n\
    \                        fields+= '<MultiValue value=\"'+fieldsToValue[key][i]+'\"\
    \ />';\n                    }\n                    fields+= '</Field>';\n    \
    \                break;\n                case 4:\n                    //fieldsToValue[key]\
    \ is of the form [value1, value2,...]\n                    var listValueIdtoName\
    \ = getValueListForField(commands.valueListForField, {fieldID : mapping[key].Id});\n\
    \                    if (Array.isArray(fieldsToValue[key])){\n               \
    \         var fieldValue = listValueIdtoName[fieldsToValue[key][0]] || fieldsToValue[key][0];\n\
    \                        fields += '<Field id=\"' + mapping[key].Id +'\" value=\"\
    ' + fieldValue +'\">';\n                        for(var i=1; i<fieldsToValue[key].length;\
    \ i++){\n                            fields+= '<MultiValue value=\"'+listValueIdtoName[fieldsToValue[key][i]]+'\"\
    \ />';\n                        }\n                        fields+= '</Field>';\n\
    \                    } else{\n                        if (isNaN(fieldsToValue[key])){\n\
    \                            fields += '<Field id=\"' + mapping[key].Id +'\" value=\"\
    ' + listValueIdtoName[fieldsToValue[key]] + '\" />';\n                       \
    \ } else{\n                            fields += '<Field id=\"' + mapping[key].Id\
    \ +'\" value=\"' + fieldsToValue[key] + '\" />';\n                        }\n\
    \                    }\n                    break;\n\n                case 7:\n\
    \                    //fieldsToValue[key] is of the form [{value: ___ , link:\
    \ ___}, {value: ___ , link: ___}, ...]\n                    fields += '<Field\
    \ id=\"' + mapping[key].Id +'\" value=\"' + fieldsToValue[key][0].value + '\"\
    \ link=\"'+fieldsToValue[key][0].link+'\">';\n                    for(var i=1;\
    \ i<fieldsToValue[key].length; i++){\n                        fields+= '<MultiValue\
    \ value=\"'+fieldsToValue[key][i].value+'\" link=\"'+fieldsToValue[key][i].link+'\"\
    \ />';\n                    }\n                    fields+= '</Field>';\n    \
    \                break;\n                case 8:\n                    if(fieldsToValue[key]\
    \ && fieldsToValue[key] !== undefined){\n                        fields += '<Field\
    \ id=\"' + mapping[key].Id + '\">';\n                        fields += '<Users>';\n\
    \                        fields += '<User id=\"' + fieldsToValue[key] + '\"></User>';\n\
    \                        fields += '</Users>';\n                        fields\
    \ += '</Field>';\n                        break;\n                    }\n\n  \
    \              case 15:\n                    //fieldsToValue[key] is of the form\
    \ {groups: [group1, group2,...], users : [user1, user2,...]}\n               \
    \     fields+= '<Field id=\"' + mapping[key].Id + '\" >';\n                  \
    \  groups = fieldsToValue[key].groups;\n                    users = fieldsToValue[key].users;\n\
    \                    if(groups && Array.isArray(groups) && groups.length > 0){\n\
    \                        fields += '<Groups>';\n                        for(var\
    \ i=0; i<groups.length; i++){\n                            fields += '<Group id=\"\
    ' + groups[i] + '\" />';\n                        }\n                        fields\
    \ += '</Groups>'\n                    }\n                    if(users && Array.isArray(users)\
    \ && users.length > 0){\n                        fields += '<Users>';\n      \
    \                  for(var i=0; i<users.length; i++){\n                      \
    \      fields += '<User id=\"' + users[i] + '\" />';\n                       \
    \ }\n                        fields += '</Users>'\n                    }\n   \
    \                 fields+='</Field>';\n                    break;\n          \
    \      case 23:\n                    if (Array.isArray(fieldsToValue[key])){\n\
    \                        fields += '<Field id=\"' + mapping[key].Id +'\" value=\"\
    ' + fieldsToValue[key][0] +'\">';\n                        for(var i=1; i<fieldsToValue[key].length;\
    \ i++){\n                            fields+= '<MultiValue value=\"'+fieldsToValue[key][i]+'\"\
    \ />';\n                        }\n                        fields+= '</Field>';\n\
    \                    } else{\n                        fields += '<Field id=\"\
    ' + mapping[key].Id +'\" value=\"' + fieldsToValue[key] + '\" />';\n         \
    \           }\n                    break;\n                case 24: // subform\n\
    \                    // get subform id\n                    if (Array.isArray(fieldsToValue[key])){\n\
    \                        fields += '<Field id=\"' + mapping[key].Id +'\" value=\"\
    ' + fieldsToValue[key][0] +'\">';\n                        for(var i=1; i<fieldsToValue[key].length;\
    \ i++){\n                            fields+= '<MultiValue value=\"'+fieldsToValue[key][i]+'\"\
    \ />';\n                        }\n                        fields+= '</Field>';\n\
    \                    } else{\n                        var idToCheck = mapping[key].Id;\n\
    \                        var secFields = '<Field id=\"29906\" value=\"' + fieldsToValue[key]+'\"\
    \ />';\n                        var subFormId = getSubformId(idToCheck, 411, secFields);\n\
    \                        fields += '<Field id=\"' + idToCheck +'\" value=\"' +\
    \ subFormId + '\" />';\n                    }\n                    break;\n  \
    \              //case 14, 16 : not supported yet\n            }\n        }\n \
    \   }\n    return fields;\n}\n\nfunction createFieldsContentsObject(fieldsToValue,\
    \ mapping){\n    // This function prepares the payload for the REST API, specifically\
    \ it creates an Object for each field in fieldsToValue, with its proper mapping\n\
    \    // Each field has an Archer type. For example, type 1 correlates for Text\
    \ fields\n    // Example for fieldsToValue: {\"Title\":\"Demisto\",\"Date/Time\
    \ Occurred\":\"3/23/2018 7:00 AM\",\"Date/Time Identified\":\"3/23/2018 7:00 AM\"\
    ,\"Date/Time Reported\":\"3/23/2018 7:00 AM\",\"Incident Summary\":\"test\"}\n\
    \    // Example for mapping: \"Title\":{\"Type\":1,\"Id\":16132,\"levelId\":232},\"\
    Incident ID (DFM)\":{\"Type\":6,\"Id\":16133,\"levelId\":232},\n    //       \
    \                   \"Target Asset Type\":{\"Type\":4,\"Id\":16134,\"levelId\"\
    :232},\"Date/Time Escalated\":{\"Type\":3,\"Id\":16135,\"levelId\":232}...\n\n\
    \    var fieldsContent = {};\n    for (var fieldName in fieldsToValue) {\n   \
    \     if (mapping[fieldName] !== undefined) {\n            var fieldValue = fieldsToValue[fieldName];\n\
    \            var fieldNameMapping = mapping[fieldName];\n            switch(fieldNameMapping.Type){\n\
    \                case 1:\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 1,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': fieldValue\n\
    \                     };\n                     break;\n\n                case\
    \ 2:\n                    fieldsContent[fieldNameMapping.Id.toString()] = {\n\
    \                        'Type': 2,\n                        'FieldId': parseInt(fieldNameMapping.Id),\n\
    \                        'Value': fieldValue\n                    };\n       \
    \             break;\n\n                case 3:\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 3,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': fieldValue\n\
    \                    };\n                    break;\n\n                case 4:\n\
    \                    //fieldValue is of the form [value1, value2,...]\n      \
    \              var listValueIdtoName = getValueListForField(commands.valueListForField,\
    \ {fieldID : fieldNameMapping.Id});\n                    var valueList = [];\n\
    \                    if (listValueIdtoName !== {}){\n                        if\
    \ (Array.isArray(fieldValue)){\n                            for(var i=0; i<fieldValue.length;\
    \ i++){\n                                if (listValueIdtoName[fieldValue[i]]\
    \ !== undefined){\n                                     valueList.push(listValueIdtoName[fieldValue[i]]);\n\
    \                                }\n                            }\n          \
    \                  if (valueList.length === 0){\n                            \
    \    valueList = fieldValue;\n                            }\n                \
    \        } else if (listValueIdtoName[fieldValue] !== undefined) {\n         \
    \                   valueList.push(listValueIdtoName[fieldValue]);\n         \
    \               }\n                    }\n                    if (valueList.length\
    \ === 0) {\n                        valueList.push(fieldValue);\n            \
    \        }\n\n\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 4,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': {\n       \
    \                     'ValuesListIds': valueList,\n                          \
    \  'OtherText': null\n                        }\n                    };\n    \
    \                break;\n\n                case 7:\n                    //fieldValue\
    \ is of the form [{value: ___ , link: ___}, {value: ___ , link: ___}, ...]\n \
    \                   var valueList = [];\n\n                    valueList.push({\n\
    \                        'Name': fieldValue[0].value,\n                      \
    \  'URL': fieldValue[0].link\n                    })\n                    for(var\
    \ i=1; i<fieldValue.length; i++){\n                        valueList.push({\n\
    \                            'Name': fieldValue[i].value,\n                  \
    \          'URL': fieldValue[i].link\n                        })\n           \
    \         }\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 7,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': valueList\n\
    \                    };\n                    break;\n\n                case 8:\n\
    \                //fieldValue is of the form {groups: [group1, group2,...], users\
    \ : [user1, user2,...]}\n                    if(fieldValue && fieldValue !== undefined){\n\
    \                        var valueObject = {};\n                        var added\
    \ = false;\n                        var groups = fieldValue.groups;\n        \
    \                var users = fieldValue.users;\n                        if(groups\
    \ && Array.isArray(groups) && groups.length > 0){\n                          \
    \  var groupValueList = [];\n                            for(var i=0; i<groups.length;\
    \ i++){\n                                groupValueList.push({\n             \
    \                       \"ID\": parseInt(groups[i])\n                        \
    \        });\n                            }\n                            valueObject['GroupList']\
    \ = groupValueList;\n                            added = true;\n             \
    \           }\n                        if(users && Array.isArray(users) && users.length\
    \ > 0){\n                            var usersValueList = [];\n              \
    \              for(var i=0; i<users.length; i++){\n                          \
    \      usersValueList.push({\n                                    \"ID\": parseInt(users[i])\n\
    \                                });\n                            }\n        \
    \                    valueObject['UserList'] = usersValueList;\n             \
    \               added = true;\n                        }\n                   \
    \     if (!added){\n                            valueObject['UserList'] = [{\n\
    \                                    \"ID\": fieldValue\n                    \
    \            }];\n                        }\n                        fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                            'Type': 8,\n                            'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                            'Value': valueObject\n\
    \                        };\n                    }\n                    break;\n\
    \n                case 9:\n                    if(fieldValue && fieldValue !==\
    \ undefined){\n                        contentIdsList = [];\n                \
    \        fieldValue = verifyOrMakeArray(fieldValue);\n                       \
    \ for(var i=0; i<fieldValue.length; i++){\n                            contentIdsList.push({\n\
    \                                \"ContentID\": parseInt(fieldValue[i])\n    \
    \                        })\n                        }\n\n                   \
    \     fieldsContent[fieldNameMapping.Id.toString()] = {\n                    \
    \        'Type': 9,\n                            'FieldId': parseInt(fieldNameMapping.Id),\n\
    \                            'Value': contentIdsList\n                       \
    \ };\n                    }\n                    break;\n\n                case\
    \ 11:\n                    valueList = []\n                    if (Array.isArray(fieldValue)){\n\
    \                        for(var i=0; i<fieldValue.length; i++){\n           \
    \                 valueList.push(fieldValue[i])\n                        }\n \
    \                   } else {\n                        valueList.push(fieldValue)\n\
    \                    }\n\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 11,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': valueList\n\
    \                    }\n                    break;\n\n                case 12:\n\
    \                    valueList = [];\n                    if (Array.isArray(fieldValue)){\n\
    \                        for(var i=0; i<fieldValue.length; i++){\n           \
    \                 valueList.push(fieldValue[i])\n                        }\n \
    \                   } else {\n                        valueList.push(fieldValue)\n\
    \                    }\n\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 12,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': valueList\n\
    \                    }\n                    break;\n\n                case 19:\n\
    \                    fieldsContent[fieldNameMapping.Id.toString()] = {\n     \
    \                   'Type': 19,\n                        'FieldId': parseInt(fieldNameMapping.Id),\n\
    \                        'IpAddressBytes': fieldValue\n                     }\n\
    \                    break;\n\n                case 18:\n                    valueList\
    \ = [];\n                    if (Array.isArray(fieldValue)){\n               \
    \         for(var i=0; i<fieldValue.length; i++){\n                          \
    \  valueList.push(fieldValue[i]);\n                        }\n               \
    \     } else {\n                        valueList.push(fieldValue);\n        \
    \            }\n\n                    fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                        'Type': 18,\n                        'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                        'Value': {'ValuesListIds':\
    \ valueList, 'OtherText': null}\n                    }\n\n                   \
    \ break;\n\n                case 23:\n                    valueList = [];\n  \
    \                  if (Array.isArray(fieldValue)){\n                        for(var\
    \ i=0; i<fieldValue.length; i++){\n                            valueList.push(fieldValue[i])\n\
    \                        }\n                    } else {\n                   \
    \     valueList.push(fieldValue)\n                    }\n\n                  \
    \  fieldsContent[fieldNameMapping.Id.toString()] = {\n                       \
    \ 'Type': 23,\n                        'FieldId': parseInt(fieldNameMapping.Id),\n\
    \                        'Value': valueList\n                    }\n\n       \
    \             break;\n                case 24: // subform - we need to create\
    \ a sub record of another module id and then add its id to our record\n      \
    \              // get subform id\n                    valueList = [];\n      \
    \              if (Array.isArray(fieldValue)){\n                        for(var\
    \ i=0; i<fieldValue.length; i++){\n                            valueList.push(fieldValue[i])\n\
    \                        }\n                        fieldsContent[fieldNameMapping.Id.toString()]\
    \ = {\n                            'Type': 24,\n                            'FieldId':\
    \ parseInt(fieldNameMapping.Id),\n                            'Value': valueList\n\
    \                        }\n                    } else {\n                   \
    \     var idToCheck = fieldNameMapping.Id;\n                        var secFields\
    \ = '<Field id=\"29906\" value=\"' + fieldValue +'\" />';\n                  \
    \      var subFormId = getSubformId(idToCheck, 411, secFields, fieldValue);\n\
    \                        fieldsContent[fieldNameMapping.Id.toString()] = {\n \
    \                           'Type': 24,\n                            'FieldId':\
    \ parseInt(idToCheck),\n                            'Value': [subFormId]\n   \
    \                     }\n                    }\n                    break;\n \
    \           }\n        }\n    }\n    // example for fieldsContent: {\"16132\"\
    :{\"Type\":1,\"FieldId\":16132,\"Value\":\"Demisto\"},\"16108\":{\"Type\":1,\"\
    FieldId\":16108,\"Value\":\"test\"}}\n    return fieldsContent;\n}\n\nfunction\
    \ getSearchRecords(parsedJSON, getInnerRecords, fullData) {\n    /* getSearchRecords\
    \ is used in searchRecords and creates an Object with each of the search results\
    \ full records(with all\n       of their inner fields) including their full inner\
    \ records(with all of their inner fields). Note that it does it only\n       for\
    \ the first level of the inner records, they would have only a summary of their\
    \ inner records but not the full record objects. */\n    var records = dq(parsedJSON,\
    \ 'Records.Record');\n    if (!records) {\n        return [];\n    }\n    var\
    \ outputs =[];\n    var seenRecords = {};\n    records = verifyOrMakeArray(records);\n\
    \    records.forEach(function (record) {\n        // iterating over all of the\
    \ records\n        var contentId = record['-contentId'];\n        var moduleId\
    \ = record['-moduleId'];\n        var toContext = {\n            Id: contentId,\n\
    \            ModuleId: moduleId,\n            Fields: {}\n        };\n       \
    \ // used later on to check if we need to bring more mappings\n        var seenModuleIds\
    \ = {};\n        seenModuleIds[moduleId] = moduleId;\n        // Getting base\
    \ record\n        if (fullData){\n           var recordObject = getRecord(commands.getRecord,\
    \ contentId, moduleId, false)[0].keyValsForFetch;\n            toContext.Fields.Record\
    \ = recordObject;\n            if (getInnerRecords){\n                // iterating\
    \ over the base records inner records and getting their entire object\n      \
    \          var innerRecords = verifyOrMakeArray(recordObject.innerRecords); //\
    \ contains all possible inner records\n                innerRecords.forEach(function\
    \ (innerRecord){\n                    if (innerRecord){\n                    \
    \    if (innerRecord.levelId === \"33\"){ //buggy record type in Archer\n    \
    \                        return;\n                        }\n                \
    \        var innerRecordContentId = innerRecord.contentId;\n                 \
    \       if (seenRecords[innerRecordContentId]){\n                            innerRecord.Record\
    \ = seenRecords[innerRecordContentId];\n                        } else {\n   \
    \                         var innerRecordModuleId = innerRecord.ModuleId || args.applicationId;\n\
    \                            if(innerRecordModuleId && !(innerRecordModuleId in\
    \ seenModuleIds)){\n                                // we have an inner record\
    \ from another module, so we bring the field mappings of the new module\n    \
    \                            extendAppIdMapping(innerRecordModuleId);\n      \
    \                          seenModuleIds[innerRecordModuleId] = innerRecordModuleId;\n\
    \                            }\n                            var recordRes = getRecord(commands.getRecord,\
    \ innerRecordContentId, innerRecordModuleId, false);\n                       \
    \     var innerRecordRes = recordRes.length > 0 ? recordRes[0].keyValsForFetch\
    \ : innerRecord;\n                            innerRecord.Record = innerRecordRes;\n\
    \                            seenRecords[innerRecordContentId] = innerRecordRes;\n\
    \                        }\n                    }\n                });\n     \
    \       }\n        }\n\n\n        var fields = verifyOrMakeArray(record.Field);\n\
    \        fields.forEach(function (field) {\n            if (field['#text'] !=\
    \ null) {\n                toContext.Fields[GLOBAL_MAPPING[field['-id']].Name]\
    \ = field['#text'];\n            } else if (field.ListValues != null && field.ListValues.ListValue['#text']\
    \ !== null) {\n                toContext.Fields[GLOBAL_MAPPING[field['-id']].Name]\
    \ = field.ListValues.ListValue['#text'];\n            } else {\n             \
    \   toContext.Fields[GLOBAL_MAPPING[field['-id']].Name] = field['#text'];\n  \
    \          }\n        });\n        outputs.push(toContext);\n    });\n    return\
    \ outputs;\n}\n\nfunction getOccurredTime(recordTimeStr, tz) {\n    var occurred\
    \ = new Date();\n    if (recordTimeStr) {\n        var tzHour = tz / 60;\n   \
    \     if (tzHour < 0) {\n            tzHour *= -1;\n        }\n        var tzMinute\
    \ = tz % 60;\n        var tzPrefix = tz < 0 ? '-' : '+';\n        var tzHourstr\
    \ = tzHour + '';\n        if (tzHourstr.length < 2) {\n            tzHourstr =\
    \ '0' + tzHourstr;\n        }\n        var tzMinutestr = tzMinute +'';\n     \
    \   if (tzMinutestr.length < 2) {\n            tzMinutestr = '0' + tzMinutestr;\n\
    \        }\n\n        // convert 7/18/2017 8:17:49 AM to 2017-07-18T20:17:49-0800\n\
    \        var dateStr = recordTimeStr.split(' ')[0];\n        var monthStr;\n \
    \       var dayStr;\n        if (params.useEuropeanTime){\n            // convert\
    \ 05/03/2019 09:16:43 to 2019-03-05T09:16:43-0800\n            dayStr = dateStr.split('/')[0];\n\
    \            monthStr = dateStr.split('/')[1];\n        } else {\n           \
    \ // convert 7/18/2017 8:17:49 to 2017-07-18T20:17:49-0800\n            monthStr\
    \ = dateStr.split('/')[0];\n            dayStr = dateStr.split('/')[1];\n    \
    \    }\n\n        var yearStr = dateStr.split('/')[2];\n\n        var timeStr\
    \ = recordTimeStr.split(' ')[1];\n        var hourInt;\n        var hourStr;\n\
    \        if (params.useEuropeanTime){\n            // convert 05/03/2019 09:16:43\
    \ to 2019-03-05T09:16:43-0800\n            hourInt = Number(timeStr.split(':')[0]);\n\
    \            hourStr = hourInt + '';\n            if (Number(hourInt) < 10 &&\
    \ hourStr.length === 1) {\n                hourStr = \"0\" + hourStr;\n      \
    \      }\n        } else {\n            // convert 7/18/2017 8:17:49 to 2017-07-18T20:17:49-0800\n\
    \            var extStr = recordTimeStr.split(' ')[2];\n            hourInt =\
    \ Number(timeStr.split(':')[0]);\n            if (extStr == \"PM\" && hourInt\
    \ < 12) {\n                hourInt = hourInt + 12;\n            }\n\n        \
    \    if (extStr == \"AM\" && hourInt == 12) {\n                hourInt = hourInt\
    \ - 12;\n            }\n\n            hourStr = hourInt + '';\n            if\
    \ (Number(hourInt) < 10 && hourStr.length === 1) {\n                hourStr =\
    \ \"0\" + hourStr;\n            }\n        }\n\n        var minStr = timeStr.split(':')[1];\n\
    \        var secStr = timeStr.split(':')[2];\n\n        if (Number(minStr) < 10\
    \ && minStr.length === 1) {\n            minStr = \"0\" + minStr;\n        }\n\
    \n        if (Number(dayStr) < 10 && dayStr.length === 1) {\n            dayStr\
    \ = \"0\" + dayStr;\n        }\n\n        if (Number(monthStr) < 10 && monthStr.length\
    \ === 1) {\n            monthStr = \"0\" + monthStr;\n        }\n\n        recordTimeStr\
    \ = yearStr + '-' +  monthStr + '-' + dayStr + 'T' + hourStr + ':' + minStr +\
    \ ':' + secStr;\n        occurred = new Date(Date.parse(recordTimeStr + tzPrefix\
    \ + tzHourstr + tzMinutestr));\n    }\n\n    return occurred;\n}\n\nfunction toDateArcherString(date)\
    \ {\n    var day = Number(date.getDate());\n    var month = Number(date.getMonth())\
    \ + 1;\n    var year = date.getFullYear();\n    var hour = date.getHours();\n\
    \    var minutes = date.getMinutes();\n    var seconds = date.getSeconds();\n\
    \    var ext = 'AM';\n    var finalHour = hour;\n\n    if (hour > 12) {\n    \
    \    ext = 'PM';\n        finalHour = (hour - 12);\n        if (finalHour == 12)\
    \ {\n            ext = 'AM';\n        }\n    } else if (hour < 12) {\n       \
    \ finalHour = hour;\n        ext = 'AM';\n    } else if (hour == 12) {\n     \
    \   ext = 'PM';\n    }\n\n    if (minutes < 10) {\n        minutes = '0' + minutes;\n\
    \    }\n\n    if (seconds < 10) {\n        seconds = '0' + seconds;\n    }\n\n\
    \    // format such: 7/22/2017 3:58 PM (American) or 22/7/2017 3:58 PM (European)\n\
    \    if (params.useEuropeanTime){\n        return day + '/' + month + '/' + year\
    \ + ' ' + finalHour + ':' + minutes + ':' + seconds + ' ' + ext;\n    }\n    return\
    \ month + '/' + day + '/' + year + ' ' + finalHour + ':' + minutes + ':' + seconds\
    \ + ' ' + ext;\n}\n\n// mappings functions\n\nfunction createMappingNameToFieldId(levels)\
    \ {\n    var nameToFieldIdMapping = {};\n    if (!levels) {\n        throw 'Mapping\
    \ levels to Fields failed';\n    }\n    levels = verifyOrMakeArray(levels);\n\n\
    \    levels.forEach(function (lvl) {\n        var url = replaceInTemplatesAndRemove(urlDictionary.fieldByLevelId,\
    \ {\n            levelId: lvl\n        });\n        var fieldsLevelInfo = sendRestRequest(url,\
    \ '', true);\n\n        if (!Array.isArray(fieldsLevelInfo)) {\n            fieldsLevelInfo\
    \ = [fieldsLevelInfo];\n        }\n\n        fieldsLevelInfo.forEach(function\
    \ (field) {\n            if (field.RequestedObject.Type !== 25) {\n          \
    \      nameToFieldIdMapping[field.RequestedObject.Name] = {\n                \
    \    Type: field.RequestedObject.Type,\n                    Id: field.RequestedObject.Id,\n\
    \                    levelId: lvl\n                };\n            }\n       \
    \ });\n    });\n\n    return nameToFieldIdMapping;\n}\n\nfunction extendMappingFieldIdToName(levels){\n\
    \    var newMapping = createMappingFieldIdToName(levels);\n    for (var attrname\
    \ in newMapping) {\n        GLOBAL_MAPPING[attrname] = newMapping[attrname];\n\
    \    }\n}\n\nfunction getLevelsByApplicationId(applicationId) {\n    var url =\
    \ replaceInTemplatesAndRemove(urlDictionary.levelIdByModuleId, {\n        applicationId:\
    \ applicationId\n    });\n    var lvlResponse = sendRestRequest(url, 'levelIdByModuleId',\
    \ '', true);\n    return dq(lvlResponse, 'RequestedObject.Id');\n}\n\nfunction\
    \ extendAppIdMapping(applicationId){\n    // creates mapping of field ids to names\
    \ by application and level ids\n    var levels = getLevelsByApplicationId(applicationId);\n\
    \    extendMappingFieldIdToName(levels);\n}\n\n// the following group of functions\
    \ is used almost exclusively for the getRecord function\n\nfunction getRecordContentMapping(fields,\
    \ applicationId, contentId, saveFiles) {\n    /* we have records who are linked\
    \ to the record we are working on.\n       innerRecordsTable will have the data\
    \ related to the linked records\n       recordVals will have the data related\
    \ to the work record, and brief summary of the linked records\n       attachedFiles\
    \ would be an array with the data needed to download the record's attached files\
    \ */\n\n    var recordVals = [];\n    var innerRecordsArray = [];\n    if (fields)\
    \ {\n        fields.forEach(function (field) {\n            var groupValue;\n\
    \            if (field.Groups) { // handling the nested Groups field\n       \
    \         groupValue = getGroupsString(field.Groups);\n            }\n       \
    \     // used later on to check if we need to bring more mappings\n          \
    \  var seenModuleIds = {};\n            var seenLevelIds = {};\n            seenModuleIds[applicationId]\
    \ = applicationId;\n\n            var innerRecordrows = [];\n            if (field.Record)\
    \ { // handling the nested Record field (inner record)\n                var innerRecords\
    \ = verifyOrMakeArray(field.Record);\n                if (field['-id'] && !(GLOBAL_MAPPING[field['-id']])){\
    \ // checking if we need to bring more mappings\n                    var sonLevelId\
    \ = findSonLevelId(innerRecords, applicationId, contentId);\n                \
    \    if (sonLevelId !== null){\n                        extendMappingFieldIdToName(sonLevelId);\n\
    \                    }\n                }\n\n                innerRecords.forEach(function(innerRecord){\n\
    \                /* iterating over the inner records and creating an column and\
    \ row Object for each of them\n                   these objects are used for the\
    \ human readable of the inner records, and for populating the\n              \
    \     main record's inner records fields */\n\n                    if(innerRecord){\n\
    \                        var recordFields = verifyOrMakeArray(innerRecord['Field']);\n\
    \                        var newModuleId;\n                        var newLevelId;\n\
    \                        if(innerRecord['-moduleId']){ // means that it is a linked\
    \ record from another module\n                            newModuleId = innerRecord['-moduleId'];\n\
    \                            if (!(newModuleId in seenModuleIds)){ // checking\
    \ if we need to bring more mappings\n                                extendAppIdMapping(newModuleId);\n\
    \                                seenModuleIds[newModuleId] = newModuleId;\n \
    \                           }\n                        } else if (innerRecord['-levelId'])\
    \ { // possibly means that it is a linked record from another module\n       \
    \                     newLevelId = innerRecord['-levelId'];\n                \
    \            if ((newLevelId && newLevelId === \"33\") || innerRecord['-levelId']\
    \ === \"33\"){\n                                return; // buggy level id\n  \
    \                          }\n                            if (!(newLevelId in\
    \ seenLevelIds)){ // checking if we need to bring more mappings\n            \
    \                    extendMappingFieldIdToName(newLevelId);\n               \
    \                 seenLevelIds[newLevelId] = newLevelId;\n                   \
    \         }\n                        }\n\n                        var innerRecordObject\
    \ = {\n                            'ModuleId': newModuleId || applicationId,\n\
    \                            'contentId': innerRecord['-id'],\n              \
    \              'levelId': innerRecord['-levelId']\n                        };\n\
    \                        if (innerRecordsArray.indexOf(innerRecordObject) ===\
    \ -1){\n                            innerRecordsArray.push (innerRecordObject);\n\
    \                        }\n                        var row = {};\n          \
    \              row['ModuleId'] = newModuleId || applicationId;\n             \
    \           row['LevelId'] = innerRecord['-levelId'];\n                      \
    \  recordFields.forEach(function (f){\n                            row = innerRecordRowBuilder(f,\
    \ row);\n                        });\n                        innerRecordrows.push(row);\n\
    \                    }\n                });\n            }\n            // if\
    \ there are no items in innerRecordrows we set it to null to ensure that the contexts\
    \ would have null and not []\n            if (innerRecordrows === undefined ||\
    \ innerRecordrows.length === 0){\n                innerRecordrows = null;\n  \
    \          }\n\n            var fieldName;\n            var levelId;\n       \
    \     var files;\n            var dateValue;\n            var usersValue;\n\n\
    \            if (field['Users']){\n                usersValue = userFieldHandler(field['Users']);\n\
    \                fieldName = GLOBAL_MAPPING[field['-id']].Name;\n            }\n\
    \            else if (field['-value'] !== undefined && dateRe.test(field['-value'])){\
    \ // a datetime field\n                dateValue = getOccurredTime(field['-value'],\
    \ 0);\n                fieldName = GLOBAL_MAPPING[field['-id']].Name;\n      \
    \      }\n            else if (field['-fileID']){ // attached files\n        \
    \        files = getFilesString(field);\n                fieldName = 'files';\n\
    \            } else if (field['-id'] && (GLOBAL_MAPPING[field['-id']])){\n   \
    \             fieldName = GLOBAL_MAPPING[field['-id']].Name;\n               \
    \ levelId = GLOBAL_MAPPING[field['-id']].levelId;\n            } else { // in\
    \ the edge case that we don't have the mapping of the field\n                fieldName\
    \ = field['-id'];\n                levelId = \" \";\n            }\n\n       \
    \     recordVals.push({\n                FieldId: field['-id'],\n            \
    \    FieldName: fieldName,\n                FieldType: field['-type'],\n     \
    \           Value: usersValue || dateValue || groupValue || field['-value'] ||innerRecordrows\
    \ || files,\n                LevelId: levelId\n            });\n        });\n\n\
    \        recordVals.push({\n            FieldName: 'innerRecords',\n         \
    \   Value: innerRecordsArray,\n            FieldId: \" \",\n            LevelId:\
    \ \" \",\n            FieldType: \" \"\n        });\n    }\n    return recordVals;\n\
    }\n\nfunction getRecordInnerRecordsValues(fields, applicationId){\n    /* we have\
    \ inner records who are linked to the record we are working on.\n       innerRecordsTable\
    \ will have the data related to the linked records */\n\n    var innerRecordsTable\
    \ = [];\n    if (fields) {\n        fields.forEach(function (field) {\n      \
    \      // innerRecordrows and innerRecordcolumns are used to create the table\
    \ of the inner records\n            var innerRecordrows = [];\n            if\
    \ (field.Record) { // handling the nested Record field (inner record)\n      \
    \          var innerRecords = verifyOrMakeArray(field.Record);\n             \
    \   var tableName;\n                if (field['-id'] && (GLOBAL_MAPPING[field['-id']])){\n\
    \                    tableName = GLOBAL_MAPPING[field['-id']].Name;\n        \
    \        }else{  // handling the edge case that we are missing mappings\n    \
    \                tableName = field['-id'];\n                }\n\n            \
    \    var innerRecordcolumns = [];\n\n                innerRecords.forEach(function(innerRecord){\n\
    \                /* iterating over the inner records and creating an column and\
    \ row Object for each of them\n                   these objects are used for the\
    \ human readable of the inner records, and for populating the\n              \
    \     main record's inner records fields */\n\n                    if(innerRecord){\n\
    \                        var row = {};\n                        var recordFields\
    \ = verifyOrMakeArray(innerRecord['Field']);\n                        var newModuleId;\n\
    \                        var newLevelId;\n                        if(innerRecord['-moduleId']){\
    \ // means that it is a linked record from another module\n                  \
    \          newModuleId = innerRecord['-moduleId'];\n                        }\n\
    \n                        innerRecordcolumns.push('ModuleId');\n             \
    \           row['ModuleId'] = newModuleId || applicationId;\n\n              \
    \          innerRecordcolumns.push('LevelId');\n                        row['LevelId']\
    \ = innerRecord['-levelId'];\n\n                        var innerRecordObject\
    \ = {\n                            'ModuleId': row['ModuleId'],\n            \
    \                'contentId': innerRecord['-id'],\n                          \
    \  'levelId': innerRecord['-levelId']\n                        };\n          \
    \              recordFields.forEach(function (f){\n                          \
    \  // building the columns of the inner records table\n                      \
    \      if (GLOBAL_MAPPING[f['-id']] && innerRecordcolumns.indexOf(GLOBAL_MAPPING[f['-id']].Name)\
    \ === -1){\n                                innerRecordcolumns.push(GLOBAL_MAPPING[f['-id']].Name);\n\
    \                            }else if (f['-id'] && !GLOBAL_MAPPING[f['-id']] &&\
    \  innerRecordcolumns.indexOf(f['-id']) === -1){\n                           \
    \     // in case of an edge case where we don't have the mapping\n           \
    \                     innerRecordcolumns.push(f['-id']);\n                   \
    \         }\n                            // building a row of the inner records\
    \ table\n                            row = innerRecordRowBuilder(f, row);\n  \
    \                      });\n                        innerRecordrows.push(row);\n\
    \                    }\n                });\n                innerRecordsTable.push([tableName,\
    \ innerRecordcolumns, innerRecordrows]);\n            }\n\n        });\n    }\n\
    \    return innerRecordsTable;\n}\n\nfunction getRecordAttachments(fields){\n\
    \    /* we have files attached to the record we are getting to Demisto.\n    \
    \   attachedFiles would be an array with the data needed to download the record's\
    \ attached files\n       attachedFiles = [{fileId: 111, fileName: \"abc\"}, {...}]\
    \ */\n\n    var attachedFiles = [];\n    if (fields) {\n        fields.forEach(function\
    \ (field) {\n            if (field['-fileID']){ // attached files\n          \
    \      var filesArr = getFilesArr(field);\n                attachedFiles = attachedFiles.concat(filesArr);\n\
    \            }\n        });\n    }\n    return attachedFiles;\n}\n\nfunction innerRecordRowBuilder(field,\
    \ row){\n    var users;\n    var rowValue;\n    if (field['Users']){\n       \
    \ rowValue = userFieldHandler(field['Users']);\n    } else if (field['-value']\
    \ !== undefined && dateRe.test(field['-value'])){ // datetime field\n        rowValue\
    \ = getOccurredTime(field['-value'], 0);\n    } else {\n        rowValue = field['-value']\
    \ || \" \";\n    }\n\n    if(GLOBAL_MAPPING[field['-id']] && GLOBAL_MAPPING[field['-id']].Name){\n\
    \        row[GLOBAL_MAPPING[field['-id']].Name] = rowValue;\n    }else if (field['-id']\
    \ && !GLOBAL_MAPPING[field['-id']]){\n        // in case of an edge case where\
    \ we don't have the mapping\n        row[field['-id']] = rowValue;\n    }\n  \
    \  return row;\n}\n\nfunction getFilesString(field){\n    var files = \"\";\n\
    \    files += \"fileID: \" + field['-fileID'] + \" fileName: \" + field['-fileName'];\n\
    \    if (field['MultiValue']){ // means we have more than one attached files\n\
    \        var filesArr = verifyOrMakeArray(field['MultiValue']);\n        for(var\
    \ i=0; i<filesArr.length; i++){\n            var innerFile = filesArr[i];\n  \
    \          files += \", fileID: \" + innerFile['-fileID'] + \" fileName: \" +\
    \ innerFile['-fileName'];\n        }\n    }\n    return files;\n}\n\nfunction\
    \ getGroupsString(groups){\n    var group = groups.Group;\n    var groupValue;\n\
    \    if (group) {\n        group = verifyOrMakeArray(group);\n        group.forEach(function\
    \ (gr) {\n            groupValue = groupValue ? groupValue + ',' + gr['-name']\
    \ : gr['-name']\n        })\n    }\n    return groupValue;\n}\n\nfunction getFilesArr(field){\n\
    \    var filesArr = [];\n    filesArr.push({\"fileID\": field['-fileID'], \"fileName\"\
    :field['-fileName']});\n    if (field['MultiValue']){ // means we have more than\
    \ one attached files\n        var innerFilesArr = verifyOrMakeArray(field['MultiValue']);\n\
    \        for(var i=0; i<innerFilesArr.length; i++){\n            var innerFile\
    \ = innerFilesArr[i];\n            filesArr.push({\"fileID\": innerFile['-fileID'],\
    \ \"fileName\":innerFile['-fileName']});\n        }\n    }\n    return filesArr;\n\
    }\n\nfunction userFieldHandler(usersField){\n    var users = \" \";\n    if(usersField['User']){\n\
    \    // \"User\": {\"-firstName\":\"Sh\",\"-id\":\"208\",\"-lastName\":\"S\",\"\
    -middleName\":\"S@a.com\",\"-updateDate\":\"4/18/2017\",\"-updateLogin\":\"208\"\
    }\n        var user = usersField['User'];\n        if (Array.isArray(usersField['User'])){\n\
    \            usersField['User'].forEach(function (user){\n                if (user['-middleName']\
    \ !== undefined && user['-middleName'].length > 0) {\n                    users\
    \ += user['-firstName'] + \" \" + user['-middleName'] + \" \" + user['-lastName'];\n\
    \                }\n                else {\n                    users += user['-firstName']\
    \ + \" \" + user['-lastName'];\n                }\n            })\n        } else{\n\
    \            if (user['-middleName'] !== undefined && user['-middleName'].length\
    \ > 0) {\n                users = user['-firstName'] + \" \" + user['-middleName']\
    \ + \" \" + user['-lastName'];\n            }\n            else {\n          \
    \      users = user['-firstName'] + \" \" + user['-lastName'];\n            }\n\
    \        }\n\n\n    }else{\n        users = usersField;\n    }\n    return users;\n\
    }\n\nfunction findSonLevelId(innerRecords, applicationId, contentId){\n    /*\
    \ Archer has a known bug of bringing records from another module without their\
    \ correct module id.\n       To solve this issue we look inside the inner records\
    \ and look for the records father. We get the\n       father record and then get\
    \ the original record's correct level id from the father inner records\n     \
    \  as the original record is his son. Later on we will use this level id to get\
    \ the correct mappings\n       for the original record */\n\n    var sonLevelId\
    \ = null;\n    var foundFather = null;\n    var fatherModuleId;\n    var fatherContentId;\n\
    \    for( var i = 0 ; i < innerRecords.length; i++){\n        if(innerRecords[i]['-moduleId']){\
    \ // means that it is a linked record from another module\n            fatherModuleId\
    \ = innerRecords[i]['-moduleId'];\n        }else{\n            fatherModuleId\
    \ = applicationId;\n        }\n        fatherContentId = innerRecords[i]['-id'];\n\
    \        // linked record father should have the level id of the record, from\
    \ it we would get the right mapping\n        var fatherJSON = getRecordJSON(commands.getRecord,\
    \ fatherContentId, fatherModuleId);\n        if (fatherJSON !== {}){\n       \
    \     var fatherInnerRecords = verifyOrMakeArray(fatherJSON.Record.Field);\n \
    \           for( var j = 0 ; j < fatherInnerRecords.length; j++){\n          \
    \      if(fatherInnerRecords[j].Record){\n                    if (fatherInnerRecords[j].Record['-id']\
    \ === contentId){\n                        sonLevelId = fatherInnerRecords[j].Record['-levelId'];\n\
    \                        // now we found the correct levelId\n               \
    \         foundFather = true;\n                        break;\n              \
    \      }\n                }\n            }\n        }\n        if (foundFather){\n\
    \            break;\n        }\n    }\n    return sonLevelId;\n}\n\nfunction createContentContext\
    \ (recordId, records) {\n    var context = {};\n    records.forEach(function (r)\
    \ {\n        context[r.FieldName] = r.Value;\n    });\n    context.Id = recordId;\n\
    \    return context;\n}\n\nfunction createKeyValsForFetch (recordId, records)\
    \ {\n    var keyVals = {};\n    records.forEach(function (r) {\n        keyVals[r.FieldName]\
    \ = r.Value;\n    });\n    keyVals.recordId = recordId;\n    return keyVals;\n\
    }\n\nfunction downloadFile(fileId){\n    // download file from Archer\n    rawResponse\
    \ = downloadFileSendSoapRequest(commands.getFile, fileId);\n    var response =\
    \ JSON.parse(x2j(rawResponse));\n    var fileResponse = extractObjectFromXML(response,\
    \ 'Envelope.Body.GetAttachmentFileResponse.GetAttachmentFileResult');\n\n    var\
    \ fileData = fileResponse['files']['file']['#text'];\n    var fileName = fileResponse['files']['file']['-name'];\n\
    \n    return [fileData,fileName];\n\n}\n\nfunction getRecordJSON(command, contentId,\
    \ applicationId) {\n    var contentId = contentId || args.contentId;\n    var\
    \ applicationId = applicationId || args.applicationId;\n    extendAppIdMapping(applicationId);\n\
    \    var rawResponse;\n    var response;\n    rawResponse = getRecordSendSoapRequest(command,\
    \ applicationId, contentId);\n\n    if (typeof rawResponse !== 'string' || rawResponse.length\
    \ == 0) {\n        logInfo(\"getRecordJSON couldn't find the specified record\
    \ with contentId:\" + JSON.stringify(contentId) + \" rawResponse = \" + JSON.stringify(rawResponse));\n\
    \        return {};\n    }\n    try {\n        response = JSON.parse(x2j(rawResponse));\n\
    \    }\n    catch(err){\n        logError('getRecordJSON error is ' + JSON.stringify(err));\n\
    \    }\n\n    var parsedJSON = extractObjectFromXML(response, 'Envelope.Body.GetRecordByIdResponse.GetRecordByIdResult');\n\
    \    return parsedJSON;\n}\n\nfunction getFullRecord(contentId, moduleId) {\n\
    \    /* getFullRecord is used to get the full record data(including full data\
    \ on its inner records) */\n\n    var seenRecords = {};\n    // used later on\
    \ to check if we need to bring more mappings\n    var seenModuleIds = {};\n  \
    \  seenModuleIds[moduleId] = moduleId;\n\n    // Getting base record\n    var\
    \ record = getRecord(commands.getRecord, contentId, moduleId, false)[0].keyValsForFetch;\n\
    \n    // iterating over the base records inner records and getting their entire\
    \ object\n    var innerRecords = verifyOrMakeArray(record.innerRecords); // contains\
    \ all possible inner records\n    innerRecords.forEach(function (innerRecord){\n\
    \        if (innerRecord){\n            if (innerRecord.levelId === \"33\"){ //buggy\
    \ record type in Archer\n                return;\n            }\n            var\
    \ innerRecordContentId = innerRecord.contentId;\n            if (seenRecords[innerRecordContentId]){\n\
    \                innerRecord.Record = seenRecords[innerRecordContentId];\n   \
    \         } else {\n                var innerRecordModuleId = innerRecord.ModuleId\
    \ || args.applicationId;\n                if(innerRecordModuleId && !(innerRecordModuleId\
    \ in seenModuleIds)){\n                    // we have an inner record from another\
    \ module, so we bring the field mappings of the new module\n                 \
    \   extendAppIdMapping(innerRecordModuleId);\n                    seenModuleIds[innerRecordModuleId]\
    \ = innerRecordModuleId;\n                }\n                var recordRes = getRecord(commands.getRecord,\
    \ innerRecordContentId, innerRecordModuleId, false);\n                var innerRecordRes\
    \ = recordRes.length > 0 ? recordRes[0].keyValsForFetch : innerRecord;\n     \
    \           innerRecord.Record = innerRecordRes;\n                seenRecords[innerRecordContentId]\
    \ = innerRecordRes;\n            }\n        }\n    });\n\n    return record;\n\
    }\n\nfunction createIncidentsArr(records, dataArgs){\n    logDebug(\"Entering\
    \ createIncidentsArr\");\n\n    var incidents = [];\n    var lastTime;\n    var\
    \ details = \"\";\n\n    if (records && records.Contents && records.Contents.length\
    \ > 0) {\n        for (var i = 0; i < records.Contents.length; i++) {\n      \
    \      details = \"\";\n            logDebug(\"Number of records is: {0}\".format(records.Contents.length));\n\
    \            var res = records.Contents[i];\n            logDebug(\"Current value\
    \ of res is: {0}\".format(JSON.stringify(res)));\n            logDebug(\"Current\
    \ value of res.Fields is: {0}\".format(JSON.stringify(res.Fields)));\n       \
    \     var labels = [];\n            var fields = Object.keys(res.Fields);\n  \
    \          logDebug(\"Current value of fields is: {0}\".format(fields.toString()));\n\
    \            if (fields) {\n                logDebug(\"Number of fields is: {0}\"\
    .format(fields.length));\n                for (var j = 0; j < fields.length; j++)\
    \ {\n                    logDebug(\"Currently handling field number {0}\".format(j.toString()));\n\
    \                    var fieldName = fields[j];\n                    var fieldValue;\n\
    \                    fieldValue = res.Fields[fieldName];\n                   \
    \ logDebug(\"Current field name is {0}\".format(fieldName));\n               \
    \     if (fieldName === \"Record\" || fieldName == \"innerRecords\"){\n      \
    \                  var recordValues = fieldValue;\n                        Object.keys(recordValues).forEach(function(key)\
    \ {\n                            if (key === \"Date Created\") {\n\n         \
    \                       if(params.useEuropeanTime) {\n                       \
    \             lastTime = getOccurredTime(recordValues[key], 0);\n\n          \
    \                      } else {\n                                    lastTime\
    \ = recordValues[key];\n                                }\n                  \
    \          }\n                            if (recordValues[key] !== null && recordValues[key]\
    \ !== undefined){\n                                if (Array.isArray(recordValues[key])){\
    \ // array of nested objects\n                                    labels.push({\
    \ 'type': key, 'value': JSON.stringify(recordValues[key])});\n               \
    \                 } else {\n                                    labels.push({\
    \ 'type': key, 'value': recordValues[key]});\n                               \
    \     if (key.toLowerCase().indexOf(\"details\") !== -1 || key.toLowerCase().indexOf(\"\
    summary\") !== -1){\n                                        details += key +\
    \ ':' + '\\n' + recordValues[key] + '\\n';\n                                 \
    \   }\n                                }\n                            }\n    \
    \                    });\n                    } else {\n                     \
    \   if (fieldValue !== null && fieldValue !== undefined){\n                  \
    \          if (Array.isArray(fieldValue)){ // array of nested objects\n      \
    \                          labels.push({ 'type': fieldName, 'value': JSON.stringify(fieldValue)});\n\
    \                                if (fieldName === \"attachedFiles\"){\n     \
    \                               fieldValue.forEach(function(val){\n          \
    \                              var innerDic = {};\n                          \
    \              innerDic[\"attachedFiles->FileID\"] = val['fileID'];\n        \
    \                                labels.push(innerDic);\n                    \
    \                });\n                                } else if (fieldName !==\
    \ \"innerRecords\" && fieldValue.length === 1){\n                            \
    \        for (var i = 0 ; i< fieldValue.length; i++ ){\n                     \
    \                   var obj = fieldValue[i];\n                               \
    \         for (var key in obj) {\n                                           \
    \ if (obj.hasOwnProperty(key)){\n                                            \
    \    var innerDic = {};\n                                                if (key\
    \ !== \"ModuleId\" && key !== \"LevelId\"){\n                                \
    \                    innerDic[fieldName + '->'+ key] = obj[key];\n           \
    \                                         labels.push(innerDic);\n           \
    \                                     }\n                                    \
    \        }\n                                        }\n                      \
    \              }\n                                }\n                        \
    \    }\n\n                            else {\n                               \
    \ labels.push({ 'type': fieldName, 'value': fieldValue });\n                 \
    \           }\n                            if (fieldName.toLowerCase().indexOf(\"\
    details\") !== -1 || fieldName.toLowerCase().indexOf(\"summary\") !== -1){\n \
    \                               details += fieldName + ':' + ' \\n' + fieldValue\
    \ + '\\n';\n                            }\n                        }\n       \
    \             }\n                    if (fieldName === \"Date Created\") {\n \
    \                       if(params.useEuropeanTime) {\n                       \
    \     lastTime = getOccurredTime(fieldValue, 0);\n                        } else\
    \ {\n                            lastTime = fieldValue;\n                    \
    \    }\n                    }\n                }\n            }\n            var\
    \ raw = JSON.stringify(res);\n            labels.push({ 'type': 'ModuleId', 'value':\
    \ dataArgs.applicationId});\n            labels.push({ 'type': 'ContentId', 'value':\
    \ res.Id});\n            labels.push({ 'type': 'rawJSON', 'value': raw });\n\n\
    \            incidents.push({\n                name: 'RSA Archer Incident: ' +\
    \ res.Id,\n                labels: labels,\n                details: details,\n\
    \                rawJSON: raw,\n                occurred: lastTime\n         \
    \   });\n        }\n    }\n    return incidents;\n}\n\nfunction buildIncident(records,\
    \ contentId, moduleId){\n    var labels = [];\n    var lastTime;\n    var details\
    \ = \"\";\n\n    if (records) {\n        var fields = Object.keys(records);\n\
    \        if (fields) {\n            for (var j = 0; j < fields.length; j++) {\n\
    \                var fieldName = fields[j];\n                var fieldValue;\n\
    \                fieldValue = records[fieldName];\n                var labelDic\
    \ = {}\n                if (fieldName === \"Record\"){\n                    var\
    \ recordValues = fieldValue;\n                    Object.keys(recordValues).forEach(function(key)\
    \ {\n                        if (key === \"Date Created\") {\n               \
    \             if(params.useEuropeanTime) {\n                                lastTime\
    \ = getOccurredTime(recordValues[key], 0);\n                            } else\
    \ {\n                                lastTime = recordValues[key];\n         \
    \                   }\n                        }\n                        if (recordValues[key]\
    \ !== null && recordValues[key] !== undefined){\n                            if\
    \ (Array.isArray(recordValues[key])){ // array of nested objects\n           \
    \                     labelDic[key] = JSON.stringify(recordValues[key]);\n   \
    \                         } else {\n                                labelDic[key]\
    \ = recordValues[key];\n                                if (key.toLowerCase().indexOf(\"\
    details\") !== -1 || key.toLowerCase().indexOf(\"summary\") !== -1){\n       \
    \                             details += key + ':' + '\\n' + recordValues[key]\
    \ + '\\n';\n                                }\n                            }\n\
    \                            labels.push(labelDic);\n                        }\n\
    \                    });\n                } else {\n                    if (fieldValue\
    \ !== null && fieldValue !== undefined){\n                        if (Array.isArray(fieldValue)){\
    \ // array of nested objects\n                            labelDic[fieldName]\
    \ = JSON.stringify(fieldValue);\n                            if (fieldName ===\
    \ \"attachedFiles\"){\n                                fieldValue.forEach(function(val){\n\
    \                                    var innerDic = {};\n                    \
    \                innerDic[\"attachedFiles->FileID\"] = val['fileID'];\n      \
    \                              labels.push(innerDic);\n                      \
    \          });\n                            } else if (fieldName !== \"innerRecords\"\
    ){\n                                for (var i = 0 ; i< fieldValue.length; i++\
    \ ){\n                                    var obj = fieldValue[i];\n         \
    \                           for (var key in obj) {\n                         \
    \               if (obj.hasOwnProperty(key)){\n                              \
    \              var innerDic = {};\n                                          \
    \  if (key !== \"ModuleId\" && key !== \"LevelId\"){\n                       \
    \                         innerDic[fieldName + '->'+ key] = obj[key];\n      \
    \                                          labels.push(innerDic);\n          \
    \                                  }\n                                       \
    \ }\n                                    }\n                                }\n\
    \                            }\n                        }else{\n             \
    \               labelDic[fieldName] = fieldValue;\n                        }\n\
    \                        labels.push(labelDic);\n                    }\n     \
    \               if (fieldName.toLowerCase().indexOf(\"details\") !== -1 || fieldName.toLowerCase().indexOf(\"\
    summary\") !== -1){\n                        details += fieldName + ':' + ' \\\
    n' + fieldValue + '\\n';\n                    }\n                }\n         \
    \       if (fieldName === \"Date Created\") {\n                    if(params.useEuropeanTime)\
    \ {\n                        lastTime = getOccurredTime(fieldValue, 0);\n    \
    \                } else {\n                        lastTime = fieldValue;\n  \
    \                  }\n\n                }\n            }\n        }\n        var\
    \ raw = JSON.stringify(records);\n        labels.push({ 'ModuleId': moduleId});\n\
    \        labels.push({ 'ContentId': contentId});\n        labels.push({'rawJSON':\
    \ raw });\n\n        return {\n            name: 'RSA Archer Incident: ' + contentId,\n\
    \            labels: labels,\n            details: details,\n            rawJSON:\
    \ raw,\n            occurred: lastTime\n        };\n    }\n}\n\nfunction getContentIdsFromIncIds(applicationId,\
    \ incidentIds){\n    // gets the content ids of the respective incident ids from\
    \ Archer\n\n    var contentIdsArr = [];\n    var displayFields = params.fieldsToDisplay\
    \ || \"Incident ID\";\n    var incidentIdsString = \"\";\n    var incidentIdsArr\
    \ = incidentIds.split(\",\");\n    for(var i = 0; i <incidentIdsArr.length ; i++){\n\
    \        incidentIdsString += \"INC-\" + incidentIdsArr[i] + \" \";\n    }\n\n\
    \    var levelId = getLevelsByApplicationId(applicationId);\n    var nameToFieldMapping\
    \ = createMappingNameToFieldId(levelId);\n\n    var response = getContentIdsByIncIdsSendSoapRequest(applicationId,\
    \ displayFields, incidentIdsString, levelId, nameToFieldMapping[displayFields].Id);\n\
    \    var rawResponse = JSON.parse(x2j(response));\n    var parsedJSON = extractObjectFromXML(rawResponse,\
    \ 'Envelope.Body.ExecuteSearchResponse.ExecuteSearchResult');\n    if (!Array.isArray(parsedJSON)){\n\
    \        var recordsArr = verifyOrMakeArray(parsedJSON.Records.Record);\n    \
    \    recordsArr.forEach(function (record){\n            contentIdsArr.push(record['-contentId']);\n\
    \        });\n    }\n\n    return contentIdsArr;\n}\n\nfunction getSubformId(fieldId,\
    \ applicationId, fieldValues, valueForSubform) {\n    var result;\n    /* Used\
    \ to get the id of a subform field*/\n    if (params.useRest){\n    // in case\
    \ that the user wants to use the REST API\n        var levels = getLevelsByApplicationId(applicationId);\n\
    \        var content = {\n            \"Content\": {\n                \"LevelId\"\
    : levels[0],\n                \"FieldContents\": {\n                    \"29906\"\
    : {\n                        'Type': 1,\n                        'FieldId': 29906,\n\
    \                        'Value': valueForSubform\n                     }\n  \
    \              }\n            },\n            \"SubformFieldId\": fieldId\n  \
    \      };\n\n        var resp = sendRestRequest('/api/core/content', commands.getSubformId,\
    \ content, false);\n        try {\n            result = resp['RequestedObject']['Id'];\n\
    \        } catch (err) {\n            throw \"Archer didn't create a new record.\
    \ We received the following response \" + JSON.stringify(resp)\n        }\n  \
    \  } else {\n        // use the SOAP API\n        var SOAPAction = 'http://archer-tech.com/webservices/CreateSubformRecord';\n\
    \        var token;\n        var response;\n        for (var i=0; i<15; i++){\n\
    \            var cache = getIntegrationContext();\n            // if we don't\
    \ have token\n            if (Object.keys(cache).length > 0 && Object.keys(cache).indexOf(\"\
    token\") > -1) {\n                token = cache[\"token\"];\n            } else\
    \ {\n                token = getAuthToken();\n                var dic = {};\n\
    \                dic[\"token\"] = token;\n                var updatedCache = mergeOptions(cache,\
    \ dic);\n                setIntegrationContext(updatedCache);\n            }\n\
    \            var soap = getContentSubFormSoapRequest(token, applicationId, fieldId,\
    \ fieldValues);\n            try {\n                response = JSON.parse(x2j(sendSoapRequest(commands.getRecord,\
    \ soap, SOAPAction)));\n                break;\n            } catch (err) {\n\
    \                if (i==14){\n                    throw \"Archer didn't create\
    \ a new record. We received the following response \" + JSON.stringify(response);\n\
    \                }\n                token = getAuthToken();\n                var\
    \ dic = {};\n                dic[\"token\"] = token;\n                var updatedCache\
    \ = mergeOptions(cache, dic);\n                setIntegrationContext(updatedCache);\n\
    \            }\n        }\n        result = dq(response, 'Envelope.Body.CreateSubformRecordResponse.CreateSubformRecordResult');\n\
    \    }\n    return result;\n}\n\nfunction verifyFieldsToValue(appFieldMapping,\
    \ fieldsToValueJSON, appID) {\n    // For each application ID, the records of\
    \ that application ID have different fields.\n    // This function verifies the\
    \ fields specified in the fieldsToValue argument are known by Archer to be compatible\
    \ with the given app ID.\n    var userSpecifiedFields = Object.keys(fieldsToValueJSON);\n\
    \    var actualFieldsOfGivenApp = Object.keys(appFieldMapping);\n    userSpecifiedFields.forEach(function(fieldSpecifiedByUser)\
    \ {\n        if (!(actualFieldsOfGivenApp.indexOf(fieldSpecifiedByUser) > -1))\
    \ {\n            var wrongFieldErrorMessage = \"Error: you've specified the following\
    \ field in the arg fieldsToValues: {0}, which does not exist for records of the\
    \ app ID: {1}. \\n\".format(fieldSpecifiedByUser, appID);\n            var possibleFieldsForGivenAppIDMessage\
    \ = \"The allowed fields for application ID {0} are {1}\".format(appID, JSON.stringify(actualFieldsOfGivenApp));\n\
    \            throw (wrongFieldErrorMessage + possibleFieldsForGivenAppIDMessage);\n\
    \        }\n    })\n}\n\nfunction getGroupIDFromGroupName(groupsDataFromArcher,\
    \ userSuppliedGroupName) {\n    var desiredGroupID = -1;\n    for (var i=0; i<groupsDataFromArcher.length;\
    \ i++){\n        var currentArcherGroupData = groupsDataFromArcher[i].RequestedObject;\n\
    \        var currentArcherGroupName = currentArcherGroupData.Name;\n        if\
    \ (currentArcherGroupName.trim().toLowerCase() === userSuppliedGroupName.trim().toLowerCase()){\n\
    \            desiredGroupID = currentArcherGroupData.Id;\n        }\n    }\n \
    \   return desiredGroupID;\n}\n\n\nfunction getUserIDFromUserName(allUsersArcherData,\
    \ userSuppliedUserName) {\n    var desiredUserID = -1;\n    for (var i=0; i<allUsersArcherData.length;\
    \ i++){\n        var currentArcherUserData = allUsersArcherData[i].RequestedObject;\n\
    \        var currentArcherUserName = currentArcherUserData.UserName;\n       \
    \ if (currentArcherUserName.trim().toLowerCase() === userSuppliedUserName.trim().toLowerCase()){\n\
    \            desiredUserID = currentArcherUserData.Id;\n        }\n    }\n   \
    \ return desiredUserID;\n}\n\n\nfunction getGroupData() {\n    var groupsData\
    \ = sendRestRequest(\"/api/core/system/group\", 'archer-create-record', '', true);\n\
    \    return groupsData;\n}\n\nfunction getUserData() {\n    var userData = sendRestRequest(\"\
    /api/core/system/user\", 'archer-create-record', '', true);\n    return userData;\n\
    }\n\n\n// integration commands functions\nfunction replaceMultiselectNameWithID(fieldsToValues,\
    \ createRecordMapping) {\n    var modifiedfieldsToValues = fieldsToValues;\n \
    \   var allGroupsArcherData = getGroupData();\n    var allUsersArcherData = getUserData();\n\
    \    for (var fieldName in fieldsToValues) {\n        if (createRecordMapping[fieldName])\
    \ {\n            var fieldValue = fieldsToValues[fieldName];\n            var\
    \ fieldNameMapping = createRecordMapping[fieldName];\n            var fieldType\
    \ = fieldNameMapping.Type;\n            var isFieldTypeMultiselect = fieldType\
    \ === 8;\n\n            if (isFieldTypeMultiselect) {\n                fieldValue\
    \ = (typeof fieldValue === \"string\") ? JSON.parse(fieldValue) : fieldValue;\n\
    \                var groupsFromUser = fieldValue.groups;\n                var\
    \ usersListFromUser = fieldValue.users;\n\n                if (!(groupsFromUser\
    \ == null)) {\n                    var groupsWithIDsInsteadOfNames = [];\n   \
    \                 for (var groupIndex = 0; groupIndex < groupsFromUser.length;\
    \ groupIndex++) {\n                        var currentUserSuppliedGroupName =\
    \ groupsFromUser[groupIndex];\n                        var currentGroupID = getGroupIDFromGroupName(allGroupsArcherData,\
    \ currentUserSuppliedGroupName)\n\n                        groupsWithIDsInsteadOfNames.push(currentGroupID);\n\
    \                    }\n\n                    fieldValue['groups'] = groupsWithIDsInsteadOfNames;\n\
    \                    modifiedfieldsToValues[fieldName] = fieldValue;\n       \
    \         }\n\n                if (!(usersListFromUser == null)) {\n         \
    \           var usersWithIDsInsteadOfNames = [];\n                    for (var\
    \ userIndex = 0; userIndex < usersListFromUser.length; userIndex++) {\n      \
    \                  var currentUserSuppliedUserName = usersListFromUser[userIndex];\n\
    \                        var currentUserID = getUserIDFromUserName(allUsersArcherData,\
    \ currentUserSuppliedUserName);\n\n                        usersWithIDsInsteadOfNames.push(currentUserID);\n\
    \                    }\n\n                    fieldValue['users'] = usersWithIDsInsteadOfNames;\n\
    \                    modifiedfieldsToValues[fieldName] = fieldValue;\n       \
    \         }\n            }\n        }\n    }\n    return modifiedfieldsToValues;\n\
    \n}\n\nfunction createRecord(command, dataArgs) {\n    // corresponds to 'archer-create-record'\
    \ command. Creates a new record in Archer\n    logDebug(\"Entering createRecord\"\
    );\n    var contentId;\n    var levels;\n    var createRecordMapping;\n    var\
    \ appId = dataArgs.applicationId;\n    var fieldsToValue = JSON.parse(dataArgs.fieldsToValues);\n\
    \    var fieldsToValueKeys = Object.keys(fieldsToValue);\n    logDebug(\"App ID\
    \ is: {0}, \\n Fields To Value keys are: {1}\".format(appId, fieldsToValueKeys.toString()));\n\
    \    if (fieldsToValue === null || typeof fieldsToValue !== 'object') {\n    \
    \    throw 'Invalid Argument fieldToValue';\n    }\n\n    var cache = getIntegrationContext();\n\
    \    if (Object.keys(cache).length > 0 && isKeyInCache(appId)) {\n        levels\
    \ = cache[appId][\"levels\"];\n        createRecordMapping = cache[appId][\"mapping\"\
    ];\n        logDebug(\"createRecordMapping is: {0}\".format((JSON.stringify(createRecordMapping))));\n\
    \        verifyFieldsToValue(createRecordMapping, fieldsToValue, appId);\n\n \
    \   } else {\n        levels = getLevelsByApplicationId(appId);\n        createRecordMapping\
    \ = createMappingNameToFieldId(levels);\n        logDebug(\"createRecordMapping\
    \ is: {0}\".format((JSON.stringify(createRecordMapping))));\n        verifyFieldsToValue(createRecordMapping,\
    \ fieldsToValue, appId);\n        var dic = {};\n        var innerDic = {};\n\
    \        innerDic[\"levels\"] = levels;\n        innerDic[\"mapping\"] = createRecordMapping;\n\
    \        dic[appId] = innerDic;\n        var updatedCache = mergeOptions(cache,\
    \ dic);\n        setIntegrationContext(updatedCache);\n    }\n\n    if (params.useRest){\n\
    \        // in case that the user wants to use the REST API\n        fieldsToValue\
    \ = replaceMultiselectNameWithID(fieldsToValue, createRecordMapping);\n      \
    \  logDebug(\"Using REST API\");\n        var content = {\n            \"Content\"\
    : {\n                \"LevelId\": levels[0],\n                \"FieldContents\"\
    : createFieldsContentsObject(fieldsToValue, createRecordMapping)\n           \
    \ }\n        };\n\n        var resp = sendRestRequest('/api/core/content', command,\
    \ content, false);\n        try {\n            contentId = resp['RequestedObject']['Id'];\n\
    \        } catch (err) {\n            throw \"Error: Archer returned an error\
    \ and didn't create a new record.\";\n        }\n\n    } else {\n        // use\
    \ the SOAP API\n        logDebug(\"Using SOAP API\");\n        var token;\n  \
    \      var fields = inputToXML(fieldsToValue, createRecordMapping);\n        var\
    \ rawResponse;\n\n        for (var i=0; i<15; i++){\n            var cache = getIntegrationContext();\n\
    \            // if we don't have token\n            if (Object.keys(cache).length\
    \ > 0 && Object.keys(cache).indexOf(\"token\") > -1) {\n                token\
    \ = cache[\"token\"];\n            } else {\n                token = getAuthToken();\n\
    \                var dic = {};\n                dic[\"token\"] = token;\n    \
    \            var updatedCache = mergeOptions(cache, dic);\n                setIntegrationContext(updatedCache);\n\
    \            }\n            var soap = createContentSoapRequest(token, appId,\
    \ fields);\n            var SOAPAction = 'http://archer-tech.com/webservices/CreateRecord';\n\
    \            try {\n                rawResponse = sendSoapRequest(command, soap,\
    \ SOAPAction);\n                break;\n            } catch (err) {\n        \
    \        if (i==14){\n                    throw \"Error: Archer returned an error\
    \ and didn't create a new record. \";\n                }\n                token\
    \ = getAuthToken();\n                var dic = {};\n                dic[\"token\"\
    ] = token;\n                var updatedCache = mergeOptions(cache, dic);\n   \
    \             setIntegrationContext(updatedCache);\n            }\n        }\n\
    \        var response = JSON.parse(x2j(rawResponse));\n\n        if (typeof rawResponse\
    \ !== 'string' || rawResponse.length == 0) {\n            throw \"Error in response.\
    \ Request = \" + soap + \" Response = \" + rawResponse;\n        }\n\n       \
    \ contentId = dq(response, 'Envelope.Body.CreateRecordResponse.CreateRecordResult');\n\
    \    }\n\n    var md = JSON.parse(JSON.stringify(fieldsToValue));\n    md.Id =\
    \ contentId;\n\n    if (!contentId) {\n        return {\n            ContentsFormat:\
    \ formats[\"markdown\"],\n            Type: entryTypes[\"error\"],\n         \
    \   Contents: \"Received an error\" + JSON.stringify(response)\n        };\n \
    \   }\n\n    return {\n        Type: entryTypes.note,\n        Contents: {\n \
    \           \"CreateRecordResult\": contentId\n        },\n        ContentsFormat:\
    \ formats.json,\n        HumanReadable: tableToMarkdown(command, md),\n      \
    \  ReadableContentsFormat: formats.markdown,\n        EntryContext: {\n      \
    \      'Archer.Record(val.Id==obj.Id)': {\n                Id: contentId,\n  \
    \              Fields: fieldsToValue\n            }\n        }\n    };\n}\n\n\
    function updateRecord(command, dataArgs) {\n    // corresponds to 'archer-update-record'\
    \ command. Updates the field/s of a record in Archer\n    logDebug(\"Entering\
    \ updateRecords\");\n\n    var appId = dataArgs.applicationId;\n    var contentId\
    \ = dataArgs.contentId;\n    var fieldsToValue;\n    if (typeof dataArgs.fieldsToValue\
    \ === 'object'){\n        fieldsToValue = dataArgs.fieldsToValue;\n    } else\
    \ {\n        fieldsToValue = JSON.parse(dataArgs.fieldsToValues);\n    }\n   \
    \ var incidentId = dataArgs.incidentId;\n    if (incidentId){\n        contentId\
    \ = getContentIdsFromIncIds(appId, incidentId)[0];\n    }\n    if (fieldsToValue\
    \ === null || typeof fieldsToValue !== 'object') {\n        throw 'Invalid Argument\
    \ fieldToValue';\n    }\n    var fieldsToValueKeys = Object.keys(fieldsToValue);\n\
    \    logDebug(\"App ID is: {0}, \\n Fields To Value keys are: {1}\".format(appId,\
    \ fieldsToValueKeys.toString()));\n\n    var cache = getIntegrationContext();\n\
    \    var updateRecordMapping;\n    if (Object.keys(cache).length > 0 && isKeyInCache(appId)\
    \ ) {\n        levels = cache[appId][\"levels\"];\n        updateRecordMapping\
    \ = cache[appId][\"mapping\"];\n        logDebug(\"updateRecordMapping value is:\
    \ {0}\".format(JSON.stringify(updateRecordMapping)));\n    } else {\n        levels\
    \ = getLevelsByApplicationId(appId);\n        updateRecordMapping = createMappingNameToFieldId(levels);\n\
    \        logDebug(\"updateRecordMapping value is: {0}\".format(JSON.stringify(updateRecordMapping)));\n\
    \        var dic = {};\n        var innerDic = {};\n        innerDic[\"levels\"\
    ] = levels;\n        innerDic[\"mapping\"] = updateRecordMapping;\n        dic[appId]\
    \ = innerDic;\n        var updatedCache = mergeOptions(cache, dic);\n        setIntegrationContext(updatedCache);\n\
    \    }\n\n    if (params.useRest){\n        // in case that the user wants to\
    \ use the REST API\n        fieldsToValue = replaceMultiselectNameWithID(fieldsToValue,\
    \ updateRecordMapping);\n        var content = {\n            \"Content\": {\n\
    \                \"Id\": contentId,\n                \"LevelId\": levels[0],\n\
    \                \"FieldContents\": createFieldsContentsObject(fieldsToValue,\
    \ updateRecordMapping)\n            }\n        };\n\n        var resp = sendRestRequest('/api/core/content',\
    \ commands.updateRecordREST, content, false);\n\n        try {\n            contentId\
    \ = resp['RequestedObject']['Id'];\n        } catch (err) {\n            throw\
    \ \"Error: Archer returned an error and didn't update any record.\";\n       \
    \ }\n\n    } else {\n        // use the SOAP API\n        var token;\n       \
    \ var rawResponse;\n        var fields = inputToXML(fieldsToValue, updateRecordMapping);\n\
    \n        for (var i=0; i<15; i++){\n            var cache = getIntegrationContext();\n\
    \            // if we don't have token\n            if (Object.keys(cache).length\
    \ > 0 && Object.keys(cache).indexOf(\"token\") > -1) {\n                token\
    \ = cache[\"token\"];\n            } else {\n                token = getAuthToken();\n\
    \                var dic = {};\n                dic[\"token\"] = token;\n    \
    \            var updatedCache = mergeOptions(cache, dic);\n                setIntegrationContext(updatedCache);\n\
    \            }\n            var soap = updateContentSoapRequest(token, appId,\
    \ contentId, fields);\n            var SOAPAction = 'http://archer-tech.com/webservices/UpdateRecord';\n\
    \            try {\n                rawResponse = sendSoapRequest(command, soap,\
    \ SOAPAction);\n                break;\n            } catch (err) {\n        \
    \        if (i==14){\n                    throw \"Error: Archer returned an error\
    \ and didn't update any record.\";\n                }\n                token =\
    \ getAuthToken();\n                var dic = {};\n                dic[\"token\"\
    ] = token;\n                var updatedCache = mergeOptions(cache, dic);\n   \
    \             setIntegrationContext(updatedCache);\n            }\n        }\n\
    \n        var response = JSON.parse(x2j(rawResponse));\n        if (typeof rawResponse\
    \ !== 'string' || rawResponse.length == 0) {\n            throw \"Error in response.\
    \ Request = \" + soap + \" Response = \" + rawResponse;\n        }\n\n       \
    \ var result = dq(response, 'Envelope.Body.UpdateRecordResponse.UpdateRecordResult');\n\
    \        if (!result && result < 1) {\n            return {\n                ContentsFormat:\
    \ formats[\"markdown\"],\n                Type: entryTypes[\"error\"],\n     \
    \           Contents: \"Received an error\" + JSON.stringify(response)\n     \
    \       };\n        }\n    }\n\n    return {\n        Type: entryTypes.note,\n\
    \        ContentsFormat: formats.json,\n        Contents: {\n            \"updatedRecord\"\
    : contentId\n        },\n        ReadableContentsFormat: formats.markdown,\n \
    \       HumanReadable: 'content id = ' + contentId + ' was updated successfully'\n\
    \    }\n}\n\nfunction getRecord(command, contentId, applicationId, saveFiles)\
    \ {\n    /* corresponds to 'archer-get-record' command. Gets record from Archer\
    \ to the war room.\n       the logic of this function can be splitted into three\
    \ parts:\n         1) it gets the raw record object from Archer with \"getRecordSendSoapRequest\"\
    \ and parses it into parsedJSON.\n         2) it builds an clearly defined and\
    \ parsed record object, including details about its inner records. That\n    \
    \        happens during \"getRecordContentMapping\".\n         3) it constructs\
    \ the reply object where reply[0] is always the record itself, and the other items\
    \ in the array\n            would be each of the record's attached files.\n  \
    \     this function is also used extensively in searchRecords. */\n\n    var contentId\
    \ = contentId || args.contentId;\n    var applicationId = applicationId || args.applicationId;\n\
    \    var response;\n    var attachedFilesMarkdown;\n    var incidentId = args.incidentId;\n\
    \n    if (incidentId){\n        contentId = getContentIdsFromIncIds(applicationId,\
    \ incidentId)[0];\n    }\n    extendAppIdMapping(applicationId);\n    var rawResponse\
    \ = getRecordSendSoapRequest(command, applicationId, contentId);\n    if (typeof\
    \ rawResponse !== 'string' || rawResponse.length == 0) {\n        logInfo(\"We\
    \ couldn't find the specified record with contentId:\" + JSON.stringify(contentId)\
    \ + \" rawResponse = \" + JSON.stringify(rawResponse));\n        return [];\n\
    \    }\n    try {\n        response = JSON.parse(x2j(rawResponse));\n    }\n \
    \   catch(err){\n        logError('getRecord response parse error is ' + JSON.stringify(err));\n\
    \    }\n\n    var parsedJSON = extractObjectFromXML(response, 'Envelope.Body.GetRecordByIdResponse.GetRecordByIdResult');\n\
    \    var recordFields = parsedJSON.Record.Field;\n    /* important - the order\
    \ of these lines matters(!). getRecordInnerRecordsValues relays on the fact that\n\
    \       getRecordContentMapping brings the required mappings for this record and\
    \ its linked records */\n    var contentMapping = getRecordContentMapping(recordFields,\
    \ applicationId, contentId, saveFiles);\n    var innerRecordValues =  getRecordInnerRecordsValues(recordFields,\
    \ applicationId);\n    var innerRecordsMarkdown = createInnerRecordsHumanReadable(innerRecordValues);\n\
    \    var attachedFiles = getRecordAttachments(recordFields);\n\n    var keyValsForFetch\
    \ = createKeyValsForFetch(contentId, contentMapping);\n    keyValsForFetch.attachedFiles\
    \ = attachedFiles;\n    var record = JSON.parse(JSON.stringify(keyValsForFetch));\n\
    \    record.innerRecords = innerRecordValues;\n\n    var reply = [];\n    reply.push({\n\
    \        Type: entryTypes.note,\n        Contents: record,\n        keyValsForFetch:\
    \ keyValsForFetch,\n        ContentsFormat: formats.json,\n        ReadableContentsFormat:\
    \ formats.markdown,\n        EntryContext: {\n          'Archer.Record(val.Id==obj.Id)':\
    \ createContentContext(contentId, contentMapping)\n        }\n    });\n    if\
    \ (attachedFiles.length > 0){\n        if (saveFiles){\n        // we have files\
    \ attached to the record that we want to save we download them and save them to\
    \ the context\n            for (var i = 0 ; i< attachedFiles.length; i++){\n \
    \               var fileInfo = downloadFile(attachedFiles[i]['fileID']);\n   \
    \             var fileData = fileInfo[0];\n                var fileName = fileInfo[1];\n\
    \                var demistoFileId = saveFile(fileData, undefined, true);\n  \
    \              attachedFiles[i]['demistoFileId'] = demistoFileId;\n          \
    \      reply.push({Type: 3, FileID: demistoFileId, File: fileName, Contents: fileName,\
    \ ArcherFileId: attachedFiles[i]['fileID']});\n            }\n            attachedFilesMarkdown\
    \ = tableToMarkdown('Attached files', attachedFiles, ['fileID', 'fileName', 'demistoFileId']);\n\
    \        } else { // we don't want to download the files at the moment\n     \
    \       attachedFilesMarkdown = tableToMarkdown('Attached files', attachedFiles,\
    \ ['fileID', 'fileName']);\n        }\n    }\n    reply[0]['HumanReadable'] =\
    \ tableToMarkdown(command, contentMapping) + '\\n\\n' + innerRecordsMarkdown +\
    \ '\\n\\n' + attachedFilesMarkdown;\n    return reply;\n}\n\nfunction getListOfApplications(command)\
    \ {\n    // corresponds to 'archer-search-applications' command. Returns the list\
    \ of applications in Archer\n\n    var body = '';\n    var applicatInfo = [];\n\
    \    var queryParams = '';\n    if (args.findByName !== undefined) {\n       \
    \ body = { Value: \"?$filter=Name eq '\" + args.findByName + \"'\" };\n    } else\
    \ if (args.findById) {\n        queryParams = '/' + args.findById;\n    }\n\n\
    \    var applictions = sendRestRequest('/api/core/system/application', command,\
    \ body, true, queryParams)\n\n    if (!Array.isArray(applictions)) {\n       \
    \ applictions = [applictions];\n    }\n\n    applictions.forEach(function (app)\
    \ {\n        var record = app.RequestedObject;\n        if (record) {\n      \
    \      applicatInfo.push({\n                Type: record.Type,\n             \
    \   LanguageId: record.LanguageId,\n                Id: record.Id,\n         \
    \       Name: record.Name,\n                Guid: record.Guid,\n             \
    \   Status: record.Status\n            })\n        }\n    });\n\n    return {\n\
    \        Type: entryTypes.note,\n        Contents: applicatInfo,\n        ContentsFormat:\
    \ formats.json,\n        HumanReadable: tableToMarkdown(command, applicatInfo),\n\
    \        ReadableContentsFormat: formats.markdown,\n        EntryContext: {\n\
    \            'Archer.Applications': applicatInfo\n        }\n    };\n}\n\n\nfunction\
    \ getFieldIdInReverseMapping(idToNameMapping, fieldNameToSearch) {\n    for (var\
    \ fieldID in idToNameMapping) {\n        var currentFieldData = idToNameMapping[fieldID];\n\
    \        if (\"Name\" in currentFieldData && currentFieldData[\"Name\"] === fieldNameToSearch)\
    \ {\n            return fieldID;\n        }\n    }\n    return '';\n}\n\n\nfunction\
    \ searchRecords(command, dataArgs) {\n    /* corresponds to 'archer-search-records'\
    \ command. Returns records from Archer who matches the user's\n       search criteria.\
    \ Looks for incident ids from Archer and then gets each one of them in getSearchRecords\n\
    \       by using the getRecord function. */\n    logDebug(\"Entering searchRecords\"\
    );\n\n    var appId = dataArgs.applicationId;\n    var fieldsToDisplay = dataArgs.fieldsToDisplay;\n\
    \    var maxResults = dataArgs.maxResults;\n    var fieldToSearchOn = dataArgs.fieldToSearchOn;\n\
    \    var searchValue = dataArgs.searchValue;\n    var numericOperator = dataArgs.numericOperator;\n\
    \    var dateOperator = dataArgs.dateOperator;\n\n    logDebug(\"App ID is: {0},\
    \ \\n Search value is: {1}\".format(appId, searchValue));\n\n    var isDescending\
    \ = dataArgs.isDescending === 'true';\n    var pageNumber = dataArgs.pageNumber\
    \ || '1';\n    var fetchFilter = dataArgs.fetchFilter;\n    var getInnerRecords\
    \ = dataArgs.getInnerRecords === 'true';\n    var fullData = dataArgs.fullData\
    \ === 'true';\n\n    var cache = getIntegrationContext();\n    var nameToFieldMapping;\n\
    \    if (Object.keys(cache).length > 0 && isKeyInCache(appId)) {\n        levels\
    \ = cache[appId][\"levels\"];\n        nameToFieldMapping = cache[appId][\"mapping\"\
    ];\n        logDebug(\"nameToFieldMapping value is: {0}\".format(JSON.stringify(nameToFieldMapping)));\n\
    \    } else {\n        levels = getLevelsByApplicationId(appId);\n        nameToFieldMapping\
    \ = createMappingNameToFieldId(levels);\n        logDebug(\"nameToFieldMapping\
    \ value is: {0}\".format(JSON.stringify(nameToFieldMapping)));\n        var dic\
    \ = {};\n        var innerDic = {};\n        innerDic[\"levels\"] = levels;\n\
    \        innerDic[\"mapping\"] = nameToFieldMapping;\n        dic[appId] = innerDic;\n\
    \        var updatedCache = mergeOptions(cache, dic);\n        setIntegrationContext(updatedCache);\n\
    \    }\n    // fills the global mapping\n    extendMappingFieldIdToName(levels);\n\
    \n    var fields = '';\n\n    if (fieldsToDisplay && !Array.isArray(fieldsToDisplay)){\n\
    \        fieldsToDisplay = fieldsToDisplay.split(',');\n    }\n\n    if (!fieldsToDisplay)\
    \ {\n        fieldsToDisplay = [\"Incident ID\"];\n    }\n    if (fieldsToDisplay)\
    \ {\n        fieldsToDisplay.forEach(function (field) {\n            if (field\
    \ && field !== \"undefined\" && nameToFieldMapping[field] !== undefined) {\n \
    \               fields += '<DisplayField name=\"' + escapeXMLChars(field) +'\"\
    >' + nameToFieldMapping[field].Id + '</DisplayField>';\n            }\n      \
    \  });\n    }\n    logDebug(\"Fields to display is: {0}\".format(fieldsToDisplay))\n\
    \    var fieldIdToSearchOn;\n    var fieldNameToSearchOn;\n    if (fieldToSearchOn\
    \ && searchValue) { // the user entered search parameters\n        isFieldNameInMapping\
    \ = nameToFieldMapping[fieldToSearchOn] && typeof nameToFieldMapping[fieldToSearchOn]\
    \ !== 'undefined';\n        fieldIdToSearchOn = isFieldNameInMapping ? nameToFieldMapping[fieldToSearchOn].Id\
    \ : '';\n        if (fieldIdToSearchOn === '') {\n            fieldIdToSearchOn\
    \ = getFieldIdInReverseMapping(nameToFieldMapping, fieldToSearchOn)\n        }\n\
    \        fieldNameToSearchOn = fieldToSearchOn;\n    }else{ // performing a general\
    \ search\n        fieldNameToSearchOn = \"Date Created\";\n        isFieldNameInMapping\
    \ = nameToFieldMapping[fieldNameToSearchOn] && typeof nameToFieldMapping[fieldNameToSearchOn]\
    \ !== 'undefined';\n        fieldIdToSearchOn = isFieldNameInMapping? JSON.stringify(nameToFieldMapping[fieldNameToSearchOn].Id)\
    \ : '';\n        if (fieldIdToSearchOn === '') {\n            fieldIdToSearchOn\
    \ = getFieldIdInReverseMapping(nameToFieldMapping, fieldNameToSearchOn)\n    \
    \    }\n        dateOperator = \"GreaterThan\";\n        var day = 60 * 1000 *\
    \ 60 * 24;\n        searchValue = toDateArcherString(new Date(new Date().getTime()\
    \ - (day * 31)));\n    }\n    logDebug(\"Field name to search on is: {0}\".format(fieldToSearchOn))\n\
    \    logDebug(\"Fields to search on is: {0}\".format(fieldsToDisplay))\n    var\
    \ rawResponse = searchSendSoapRequest(\n        command,\n        appId,\n   \
    \     fields,\n        maxResults,\n        fieldIdToSearchOn,\n        fieldNameToSearchOn,\n\
    \        searchValue,\n        fieldIdToSearchOn,\n        isDescending,\n   \
    \     numericOperator,\n        dateOperator,\n        pageNumber,\n        fetchFilter);\n\
    \n    if (typeof rawResponse !== 'string' || rawResponse.length == 0) {\n    \
    \    logInfo(\"We couldn't find records in searchRecords: rawResponse = \" + JSON.stringify(rawResponse));\n\
    \        return [];\n    }\n    try {\n        response = JSON.parse(x2j(rawResponse));\n\
    \    }\n    catch(err){\n        throw ('searchRecords response parse error is\
    \ ' + JSON.stringify(err));\n    }\n    var parsedJson = extractObjectFromXML(response,\
    \ 'Envelope.Body.ExecuteSearchResponse.ExecuteSearchResult');\n    var output\
    \ = getSearchRecords(parsedJson, getInnerRecords, fullData);\n    var md = [];\n\
    \    output.forEach(function (out) {\n        md.push(treeToFlattenObject(out));\n\
    \    });\n\n    return {\n        Type: entryTypes.note,\n        Contents: output,\n\
    \        ContentsFormat: formats.json,\n        HumanReadable: tableToMarkdown(command,\
    \ md),\n        ReadableContentsFormat: formats.markdown,\n        EntryContext:\
    \ {\n            'Archer.Record(val.Id==obj.Id)': output\n        }\n    };\n\
    }\n\nfunction getAppFields() {\n    // corresponds to 'archer-get-application-fields'\
    \ command. Returns the values of a specific field id in Archer\n\n    var levels\
    \ = getLevelsByApplicationId(args.applicationId);\n    var appFieldsMapping =\
    \ createMappingFieldIdToName(levels);\n    var md = [];\n    for (var fieldId\
    \ in appFieldsMapping) {\n        md.push({\n            FieldId: fieldId,\n \
    \           FieldName: appFieldsMapping[fieldId].Name,\n            FieldType:\
    \ appFieldsMapping[fieldId].Type,\n            LevelId: appFieldsMapping[fieldId].levelId\n\
    \        })\n    }\n\n    return {\n        Type: entryTypes.note,\n        Contents:\
    \ md,\n        ContentsFormat: formats.json,\n        HumanReadable: tableToMarkdown(command,\
    \ md),\n        ReadableContentsFormat: formats.markdown,\n        EntryContext:\
    \ {\n            'Archer.ApplicationFields(val.FieldId === obj.FieldId)': md\n\
    \        }\n    };\n}\n\nfunction deleteRecord(command, dataArgs) {\n    // corresponds\
    \ to 'archer-delete-record' command. Deletes a record from Archer\n\n    var appId\
    \ = dataArgs.applicationId;\n    var contentId = dataArgs.contentId;\n    var\
    \ incidentId = dataArgs.incidentId;\n    if (incidentId){\n        contentId =\
    \ getContentIdsFromIncIds(appId, incidentId)[0];\n    }\n    var token = getAuthToken();\n\
    \    var soap =  deleteContentSoapRequest(token, appId, contentId);\n    var SOAPAction\
    \ = 'http://archer-tech.com/webservices/DeleteRecord';\n    var rawResponse =\
    \ sendSoapRequest(command, soap, SOAPAction);\n    var response = JSON.parse(x2j(rawResponse));\n\
    \n    if (typeof rawResponse !== 'string' || rawResponse.length == 0) {\n    \
    \    throw \"Error in response. Request = \" + soap + \" Response = \" + rawResponse;\n\
    \    }\n\n    var result = dq(response, 'Envelope.Body.DeleteRecordResponse.DeleteRecordResult');\n\
    \    if (!result && result < 1) {\n        return {\n            ContentsFormat:\
    \ formats.markdown,\n            Type: entryTypes.error,\n            Contents:\
    \ \"Recived an error while deleting record: \" + JSON.stringify(response)\n  \
    \      };\n    }\n\n    return {\n        Type: entryTypes.note,\n        Contents:\
    \ 'content id = ' + contentId + ' was deleted successfully'\n    }\n}\n\nfunction\
    \ getValueObjectForFieldId(dataArgs){\n    // corresponds to 'archer-get-field'\
    \ command. Returns the values of a specific field id in Archer\n\n    var fieldID\
    \ = dataArgs.fieldID;\n    var levels = getLevelsByApplicationId(args.applicationId);\n\
    \    var mapping = createMappingFieldIdToName(levels);\n    var result = mapping[fieldID];\n\
    \    try {\n        result.FieldId = fieldID;\n    } catch (e){\n        //no\
    \ match for this fieldID\n    }\n    return result;\n}\n\nfunction fetchIncidents(dataArgs)\
    \ {\n    // corresponds to 'archer-fetch-incidents' scenario. Fetch incidents\
    \ from an specific module in Archer\n    logDebug(\"Entering fetch incidents\"\
    );\n\n    var myTimezone = new Date().getTimezoneOffset() * -1;\n    var tz =\
    \ params.timeZone ? parseInt(params.timeZone) : myTimezone;\n    if (params.timeZone\
    \ === '0') {\n        tz = 0;\n    }\n\n    // The offset is given in milliseconds,\
    \ thus multiplying by 1000.\n    offset = tz ? 60 * 1000 * parseInt(tz) : 60 *\
    \ 1000 * new Date().getTimezoneOffset();\n\n    var cmd = commands.searchRecords;\n\
    \    var incidentRes = [];\n    var lastRun = getLastRun();\n\n    var day = 60\
    \ * 1000 * 60 * 24;\n    var lastTime = lastRun.lastTime;\n    var shouldAddOffset\
    \ = false;\n    if (!lastTime) {\n        shouldAddOffset = true;\n        lastTime\
    \ = new Date().getTime() - (day * 1);\n    }\n    dataArgs.applicationId = dataArgs.applicationId\
    \ || params.fetchApplicationId ;\n    dataArgs.dateOperator = 'GreaterThan';\n\
    \    dataArgs.searchValue = toDateArcherString(new Date(lastTime));\n    dataArgs.fieldToSearchOn\
    \ = \"Date Created\";\n    dataArgs.fieldsToDisplay = dataArgs.fieldsToDisplay\
    \ || params.fieldsToDisplay || \"Incident ID\";\n    dataArgs.isDescending = 'false';\n\
    \    dataArgs.fetchFilter = params.fetchFilter;\n    dataArgs.getInnerRecords\
    \ = 'true';\n    dataArgs.fullData = 'true';\n\n\n    logDebug(\"Entering searchRecords\
    \ from fetch incidents\");\n    var results = searchRecords(cmd, dataArgs);\n\
    \    var incidents = createIncidentsArr(results, dataArgs.applicationId);\n  \
    \  logDebug(\"Incidents returned are: {0}\".format(incidents.toString()));\n \
    \   if (incidents.length > 0){\n        shouldAddOffset = true;\n        lastTime\
    \ = incidents[incidents.length-1].occurred;\n        lastTime = lastTime.getTime()\n\
    \    }\n    var newLastTime = shouldAddOffset ? lastTime + offset : lastTime;\n\
    \    logDebug(\"New last time is: {0}\".format(newLastTime))\n    setLastRun({\
    \ lastTime: newLastTime});\n    return (JSON.stringify(incidents));\n}\n\nfunction\
    \ getReports(command) {\n    // corresponds to 'archer-get-reports' command. Gets\
    \ all the existing Archer reports\n\n    var token = getAuthToken();\n    var\
    \ soap = getReportsSoapRequest(token);\n    var SOAPAction = 'http://archer-tech.com/webservices/GetReports';\n\
    \    var rawResponse = sendSoapRequest(command, soap, SOAPAction);\n    destroyAuthToken(token);\n\
    \    var response = JSON.parse(x2j(rawResponse));\n\n    if (typeof rawResponse\
    \ !== 'string' || rawResponse.length == 0) {\n        throw \"Error in response.\
    \ Request = \" + soap + \" Response = \" + rawResponse;\n    }\n\n    var parsedJSON\
    \ = extractObjectFromXML(response, 'Envelope.Body.GetReportsResponse.GetReportsResult');\n\
    \n    return {\n        Type: entryTypes.note,\n        Contents: parsedJSON,\n\
    \        ContentsFormat: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        EntryContext: {\n            'Archer.Report(val.ReportGUID==obj.ReportGUID)':\
    \ parsedJSON\n        }\n    };\n}\n\nfunction executeStatisticSearchByReport(command,\
    \ dataArgs) {\n    // corresponds to 'archer-execute-statistic-search-by-report'\
    \ command. Performs a statistic search on a specific Archer report\n\n    var\
    \ maxResults = dataArgs.maxResults || '100';\n    var reportGuid = dataArgs.reportGuid;\n\
    \    var token = getAuthToken();\n\n    var soap = executeStatisticSearchByReportSoapRequest(token,\
    \ reportGuid, maxResults);\n    var SOAPAction = 'http://archer-tech.com/webservices/ExecuteStatisticSearchByReport';\n\
    \    var rawResponse = sendSoapRequest(command, soap, SOAPAction);\n    destroyAuthToken();\n\
    \    var response = JSON.parse(x2j(rawResponse));\n\n    if (typeof rawResponse\
    \ !== 'string' || rawResponse.length == 0) {\n        throw \"Error in response.\
    \ Request = \" + soap + \" Response = \" + rawResponse;\n    }\n\n    var parsedJSON\
    \ = extractObjectFromXML(response, 'Envelope.Body.ExecuteStatisticSearchByReportResponse.ExecuteStatisticSearchByReportResult');\n\
    \n    return {\n        Type: entryTypes.note,\n        Contents: parsedJSON,\n\
    \        ContentsFormat: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        EntryContext: {\n            'Archer.StatisticSearch(true)': parsedJSON\n\
    \        }\n    };\n}\n\nfunction getSearchOptionsByGuid(command, dataArgs) {\n\
    \    // corresponds to 'archer-get-search-options-by-guid' command. Gets the search\
    \ option for a specific Archer report\n\n    var reportGuid = dataArgs.reportGuid;\n\
    \    var token = getAuthToken();\n    var soap = getSearchOptionsByGuidSoapRequest(token,\
    \ reportGuid);\n    var SOAPAction = 'http://archer-tech.com/webservices/GetSearchOptionsByGuid';\n\
    \    var rawResponse = sendSoapRequest(command, soap, SOAPAction);\n    destroyAuthToken();\n\
    \    var response = JSON.parse(x2j(rawResponse));\n\n    if (typeof rawResponse\
    \ !== 'string' || rawResponse.length == 0) {\n        throw \"Error in response.\
    \ Request = \" + soap + \" Response = \" + rawResponse;\n    }\n\n    var parsedJSON\
    \ = extractObjectFromXML(response, 'Envelope.Body.GetSearchOptionsByGuidResponse.GetSearchOptionsByGuidResult');\n\
    \n    return {\n        Type: entryTypes.note,\n        Contents: parsedJSON,\n\
    \        ContentsFormat: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        EntryContext: {\n            'Archer.SearchOptions(true)': parsedJSON\n\
    \        }\n    };\n}\n\nfunction searchRecordsByReport(command, dataArgs) {\n\
    \    // corresponds to 'archer-search-records-by-report' command. Search records\
    \ by a specific Archer report\n\n    var reportGuid = dataArgs.reportGuid;\n \
    \   var currentPage = 1;\n    var moreRecords = true;\n    var searchResults =\
    \ {\n        \"RecordsAmount\": \"\",\n        \"Records\": [],\n        \"FieldDefinitions\"\
    : []\n    }\n    do {\n        var token = getAuthToken();\n        var soap =\
    \ searchRecordsByReportSoapRequest(token, reportGuid, currentPage);\n        var\
    \ SOAPAction = 'http://archer-tech.com/webservices/SearchRecordsByReport';\n \
    \       var rawResponse = sendSoapRequest(command, soap, SOAPAction);\n      \
    \  destroyAuthToken(token);\n        var response = JSON.parse(x2j(rawResponse));\n\
    \n        if (typeof rawResponse !== 'string' || rawResponse.length == 0) {\n\
    \            throw \"Error in response. Request = \" + soap + \" Response = \"\
    \ + rawResponse;\n        }\n        var parsedJSON = extractObjectFromXML(response,\
    \ 'Envelope.Body.SearchRecordsByReportResponse.SearchRecordsByReportResult');\n\
    \        if (parsedJSON.Records && parsedJSON.Records.Record){\n            currentPage\
    \ += 1;\n            searchResults['RecordsAmount'] = parsedJSON.Records['-count'];\n\
    \            searchResults['Records'].push(parsedJSON.Records.Record);\n     \
    \       searchResults['FieldDefinitions'].push(parsedJSON.Records.Metadata.FieldDefinitions.FieldDefinition)\n\
    \        } else {\n            moreRecords = false;\n        }\n    } while (moreRecords);\n\
    \n\n    return {\n        Type: entryTypes.note,\n        Contents: searchResults,\n\
    \        ContentsFormat: formats.json,\n        ReadableContentsFormat: formats.markdown,\n\
    \        EntryContext: {\n            'Archer.SearchByReport(true)': searchResults\n\
    \        }\n    };\n}\n\nfunction createMappingFieldIdToName(levels) {\n    //\
    \ corresponds to 'archer-get-mapping-by-level' command. Creates a mapping of field\
    \ id to names according to level ids\n\n    var fieldIdToNameMapping = {};\n \
    \   if (!levels) {\n        throw 'Mapping levels to Fields failed';\n    }\n\n\
    \    if (!Array.isArray(levels)) {\n        levels = [levels];\n    }\n\n    levels.forEach(function\
    \ (lvl) {\n        var url = replaceInTemplatesAndRemove(urlDictionary.fieldByLevelId,\
    \ {\n            levelId: lvl\n        });\n        var fieldsLevelInfo = sendRestRequest(url,\
    \ 'fieldByLevelId', '', true);\n\n        if (!Array.isArray(fieldsLevelInfo))\
    \ {\n           fieldsLevelInfo = [fieldsLevelInfo];\n        }\n\n        fieldsLevelInfo.forEach(function\
    \ (field) {\n            if (field.RequestedObject.Type !== 25) {\n          \
    \      fieldIdToNameMapping[field.RequestedObject.Id] = {\n                  \
    \  Type: field.RequestedObject.Type,\n                    Name: field.RequestedObject.Name,\n\
    \                    levelId: lvl\n                };\n            }\n       \
    \ });\n    });\n\n    return fieldIdToNameMapping;\n}\n\nfunction manualFetch(args){\n\
    \    /* corresponds to 'archer-manually-fetch-incident' command. Fetch an incident\
    \ or several incidents from Archer to Demisto.\n       used for the automation\
    \ which creates a new incident with the following data */\n\n    var incidentIds\
    \ = args.incidentIds;\n    var incidents = [];\n    var contentIdsArr;\n    var\
    \ incidentIdsArr = incidentIds.split(\",\");\n    var applicationId = args.applicationId;\n\
    \n    var contentIdsFromInc = getContentIdsFromIncIds(applicationId, incidentIds);\n\
    \n    if (contentIdsFromInc.length > 0){\n        contentIdsArr = contentIdsFromInc;\n\
    \    } else {\n        contentIdsArr = incidentIdsArr;\n    }\n\n    contentIdsArr.forEach(function\
    \ (contentId){\n        var record = getFullRecord(contentId, applicationId);\n\
    \        incidents.push(buildIncident(record, contentId, applicationId));\n  \
    \  });\n    return incidents;\n}\n\nfunction getFile(args){\n    // corresponds\
    \ to 'archer-get-file' command. Downloads a file from Archer and adds it to the\
    \ context\n\n    var fileId = args.fileId;\n    var fileInfo = downloadFile(fileId);\n\
    \    var fileData = fileInfo[0];\n    var fileName = fileInfo[1];\n    var demistoFileId\
    \ = saveFile(fileData, undefined, true);\n    return ({\n        Type: 3,\n  \
    \      FileID: demistoFileId,\n        File: fileName,\n        Contents: fileName\n\
    \    });\n}\n\nfunction uploadFile(args){\n    // corresponds to 'archer-upload-file'\
    \ command. Uploads a file from Demisto to Archer\n\n    var applicationId = args.applicationId;\n\
    \    var contentId = args.contentId;\n    var incidentId = args.incidentId;\n\
    \    var entryId = args.entryId;\n    var associatedField = args.associatedField;\n\
    \n    if (incidentId){\n        contentIdsFromInc = getContentIdsFromIncIds(applicationId,\
    \ incidentId);\n        if (contentIdsFromInc.length > 0){\n            contentId\
    \ = contentIdsFromInc[0];\n        } else {\n            contentId = incidentId;\n\
    \        }\n    }\n    var fileName = dq(invContext, \"File(val.EntryID == '\"\
    \ + entryId + \"').Name\");\n    if (fileName === null) {\n        fileName =\
    \ dq(invContext, \"InfoFile(val.EntryID == '\" + entryId + \"').Name\");\n   \
    \ }\n    if (Array.isArray(fileName)) {\n        if (fileName.length > 0) {\n\
    \            fileName = fileName[0];\n        } else {\n            fileName =\
    \ undefined;\n        }\n    }\n\n    var fileB64String = entrytoa(entryId);\n\
    \    var body = {\"AttachmentName\": fileName, \"AttachmentBytes\": fileB64String};\n\
    \    var response = sendRestRequest(urlDictionary[commands.uploadFile], commands.uploadFile,\
    \ body, false);\n    if (response['IsSuccessful'] == \"false\"){\n        throw\
    \ \"Uploading failed. Response was: \" + JSON.stringify(response);\n    }\n\n\
    \    var archerFileId = response.RequestedObject.Id;\n    var currentFiles = [archerFileId];\n\
    \    var currentRecord = getRecord(commands.getRecord, contentId, applicationId,\
    \ true);\n\n    for (var i=1; i<currentRecord.length; i++){\n        currentFiles.push(parseInt(currentRecord[i]['ArcherFileId']));\n\
    \    }\n    fieldsToValueObj = {};\n    fieldsToValueObj[associatedField] = currentFiles;\n\
    \    var args = {\n        \"applicationId\": applicationId,\n        \"contentId\"\
    : contentId,\n        \"fieldsToValue\": fieldsToValueObj,\n        \"incidentId\"\
    : incidentId\n    }\n    updateRecord(commands.updateRecord, args);\n    return\
    \ \"File uploaded successfully\";\n}\n\nfunction addToDetailedAnalysis(args){\n\
    \    // corresponds to 'archer-add-to-detailed-analysis' command. Adds more data\
    \ to detailed analysis\n\n    var detailedAnalysisArcherIds = [];\n    var applicationId\
    \ = args.applicationId;\n    var contentId = args.contentId;\n    var incidentId\
    \ = args.incidentId;\n    if (!contentId && !incidentId){\n        throw \"Please\
    \ enter either contentId or incidentId of the record\";\n    }\n\n    if (incidentId){\n\
    \        contentId = getContentIdsFromIncIds(applicationId, incidentId)[0];\n\
    \    }\n    var value = args.value;\n\n    currentRecord = getRecord(commands.getRecord,\
    \ contentId, applicationId, false)[0].Contents;\n    if (currentRecord['Detailed\
    \ Analysis']){\n        currentDetailedAnalysis = verifyOrMakeArray(currentRecord['Detailed\
    \ Analysis']);\n        currentDetailedAnalysis.forEach(function(item){\n    \
    \        if(item['Notes: Tracking ID']){\n                detailedAnalysisArcherIds.push(item['Notes:\
    \ Tracking ID']);\n            }\n        })\n    }\n\n    var fields = '<Field\
    \ id=\"29906\" value=\"' + value +'\" />';\n    detailedAnalysisArcherIds.push(getSubformId(30186,\
    \ 411, fields, value));\n\n    var args = {\n        \"applicationId\": applicationId,\n\
    \        \"contentId\": contentId,\n        \"fieldsToValue\": {\n           \
    \ \"Detailed Analysis\": detailedAnalysisArcherIds\n        },\n        \"incidentId\"\
    : incidentId\n    }\n    updateRecord(commands.updateRecord, args);\n\n    return\
    \ \"Detailed Analysis updated successfully\";\n}\n\nfunction getUserId(args){\n\
    \    // corresponds to 'archer-get-user-id' command. Retrieves a user id from\
    \ Archer\n\n    var userInfo = args.userInfo.split(\"\\\\\");\n    var userDomain\
    \ = userInfo[0];\n    var userName = userInfo[1].toLowerCase();\n\n    var token;\n\
    \    var rawResponse;\n    var cache;\n    for (var i=0; i<15; i++){\n       \
    \ cache = getIntegrationContext();\n        // if we don't have token\n      \
    \  if (Object.keys(cache).length > 0 && Object.keys(cache).indexOf(\"token\")\
    \ > -1) {\n            // there is a lock in place\n            var locked = true;\n\
    \            var total = 0;\n            while (Object.keys(cache).indexOf(\"\
    lock\") > -1 && (cache[\"lock\"] === true || cache[\"lock\"] === \"true\") &&\
    \ locked && cache[\"valid\"]){\n                logInfo(\"Waiting for lock to\
    \ end\");\n                total += 2000;\n                sleep(2000);\n    \
    \            cache = getIntegrationContext();\n                if (cache[\"lock\"\
    ] !== true || total > 60000){\n                    // breaking lock after 1 minute\n\
    \                    locked = false;\n                }\n            }\n     \
    \       // no lock\n            if (!(Object.keys(cache).indexOf(\"lock\") > -1)\
    \ || cache[\"valid\"] !== false){\n                token = cache[\"token\"];\n\
    \                logInfo(\"Taking token \" + token + \" from cache\")\n      \
    \      } else {\n                token = getAuthToken();\n                var\
    \ dic = {};\n                dic[\"token\"] = token;\n                dic[\"lock\"\
    ] = true;\n                var updatedCache = mergeOptions(cache, dic);\n    \
    \            setIntegrationContext(updatedCache);\n                logInfo(\"\
    Token wasn't found in cache, created token: \" + token + \" and putting it in\
    \ the cache\")\n            }\n        } else {\n            token = getAuthToken();\n\
    \            var dic = {};\n            dic[\"token\"] = token;\n            dic[\"\
    lock\"] = true;\n            var updatedCache = mergeOptions(cache, dic);\n  \
    \          setIntegrationContext(updatedCache);\n            logInfo(\"Token wasn't\
    \ found in cache, created token: \" + token + \" and putting it in the cache\"\
    )\n        }\n        var soap = getUserIdSoapRequest(token, userName, userDomain);\n\
    \        var SOAPAction = 'http://archer-tech.com/webservices/LookupDomainUserId';\n\
    \        try {\n            rawResponse = sendSoapRequest(command, soap, SOAPAction);\n\
    \            break;\n        } catch (err) {\n            logInfo('Bad Result\
    \ from Archer: ' + err + ' request body was: ' + soap);\n            // check\
    \ if we are locked and if there is a new token in place already\n            cache\
    \ = getIntegrationContext();\n            var locked = false;\n            var\
    \ total = 0;\n\n            while (Object.keys(cache).indexOf(\"lock\") > -1 &&\
    \ (cache[\"lock\"] === true) && locked){\n                logInfo(\"Waiting for\
    \ lock to end\");\n                sleep(2000);\n                cache = getIntegrationContext();\n\
    \                total += 2000;\n\n                if (cache[\"lock\"] !== true\
    \ || total > 60000){\n                    // breaking the lock after 1 minute\n\
    \                    locked = false;\n                }\n            }\n     \
    \       if (Object.keys(cache).indexOf(\"valid\") > -1 && cache[\"valid\"] ===\
    \ true && cache[\"token\"] !== token){\n                token = cache[\"token\"\
    ];\n            } else {\n                token = getAuthToken();\n          \
    \  }\n\n            var dic = {};\n            dic[\"token\"] = token;\n     \
    \       dic[\"lock\"] = true;\n            var updatedCache = mergeOptions(cache,\
    \ dic);\n            setIntegrationContext(updatedCache);\n            logInfo(\"\
    Putting a newly token in cache which was generated after an error, token is: \"\
    \ + token);\n\n            if (i==14){\n                var dic = {};\n      \
    \          dic[\"valid\"] = false;\n                dic[\"lock\"] = false;\n \
    \               var updatedCache = mergeOptions(cache, dic);\n               \
    \ setIntegrationContext(updatedCache);\n                throw \"Error in response.\
    \ Request = \" + soap + \" Response = \" + rawResponse;\n            }\n     \
    \       continue;\n        }\n    }\n\n    var response = JSON.parse(x2j(rawResponse));\n\
    \    logInfo('Successful get user id request to RSA Archer with session token:\
    \ ' + token);\n    var dic = {};\n    dic[\"token\"] = token;\n    dic[\"valid\"\
    ] = true;\n    dic[\"lock\"] = false;\n    var updatedCache = mergeOptions(cache,\
    \ dic);\n    setIntegrationContext(updatedCache);\n    if (typeof rawResponse\
    \ !== 'string' || rawResponse.length == 0) {\n        throw \"Error in response.\
    \ Request was: \" + soap + \" Response was: \" + rawResponse;\n    }\n\n    var\
    \ userId = response.Envelope.Body.LookupDomainUserIdResponse.LookupDomainUserIdResult;\n\
    \n    return {\n        Type: entryTypes.note,\n        Contents: {\n        \
    \    \"UserId\": userId\n        },\n        ContentsFormat: formats.json,\n \
    \       ReadableContentsFormat: formats.markdown,\n        HumanReadable: \"User\
    \ id for user \" + userName + \" is \" + userId,\n        EntryContext: {\n  \
    \          'Archer.getUserId(val.UserId==obj.UserId)': userId\n        }\n   \
    \ };\n}\n\nfunction isKeyInCache(key){\n    cache = getIntegrationContext();\n\
    \    if (key in cache && cache[key] !== null) {\n        return true;\n    }\n\
    \    return false;\n}\n\nfunction resetIntegrationCache(){\n    currentIntegrationContext\
    \ = getIntegrationContext();\n    newIntegrationContext = {}\n    keysNotToReset\
    \ = [\"token\", \"lock\", \"valid\"]\n    Object.keys(currentIntegrationContext).forEach(function(key)\
    \ {\n        if (keysNotToReset.indexOf(key) === -1) {\n            newIntegrationContext[key]\
    \ = null\n        }\n    });\n    setIntegrationContext(newIntegrationContext);\n\
    }\n\nfunction test() {\n    var isFetch = params.isFetch;\n    if (isFetch &&\
    \ !params.fetchApplicationId && !params.fieldsToDisplay) {\n        throw 'If\
    \ Fetch incidents is on, then Application Id and fields to display must be passed';\n\
    \    }\n    if (!getListOfApplications(commands.searchApps).Contents.length >\
    \ 0){\n        throw 'Error in test, list of Applications is empty - possible\
    \ problem with API connection';\n    }\n    return 'ok';\n}\n\nfunction mergeDicts(dictA,\
    \ dictB) {\n    newDict = {}\n    Object.keys(dictA).forEach(function(key){\n\
    \        newDict[key] = dictA[key]\n    })\n    Object.keys(dictB).forEach(function(key){\n\
    \        newDict[key] = dictB[key]\n    })\n    return newDict\n}\n\ntry {\n \
    \    /*\n     current workaround for known missing mapping. If this issue appears\
    \ again\n     it would be better to put missing application ids (such as 411)\
    \ as integration params.\n     it's ok if this fails, the client might not have\
    \ this module.\n     */\n\n    var cache = getIntegrationContext();\n    var appId\
    \ = \"411\";\n    if (Object.keys(cache).length > 0 && isKeyInCache(appId)) {\n\
    \        newMapping = cache[appId][\"mapping\"];\n        for (var attrname in\
    \ newMapping) {\n            GLOBAL_MAPPING[attrname] = newMapping[attrname];\n\
    \        }\n    } else {\n        var levels = getLevelsByApplicationId(appId);\n\
    \        var mappingIDToName = createMappingFieldIdToName(levels);\n        var\
    \ mappingNameToID = createMappingNameToFieldId(levels);\n        newMapping =\
    \ mergeDicts(mappingIDToName, mappingNameToID);\n        for (var attrname in\
    \ newMapping) {\n            GLOBAL_MAPPING[attrname] = newMapping[attrname];\n\
    \        }\n        var dic = {};\n        var innerDic = {};\n        innerDic[\"\
    levels\"] = levels;\n        innerDic[\"mapping\"] = newMapping;\n        dic[appId]\
    \ = innerDic;\n        var updatedCache = mergeOptions(cache, dic);\n        setIntegrationContext(updatedCache);\n\
    \        // todo add new levels to the cache\n    }\n} catch (e) {\n}\n\n\nswitch\
    \ (command) {\n    case 'test-module':\n        return test();\n    case commands.createRecord:\n\
    \        return createRecord(command, args);\n    case commands.getValueList:\n\
    \        return getValueListJustForField(args);\n    case commands.valueListForField:\n\
    \        return getValueObjectForFieldId(args);\n    case commands.updateRecord:\n\
    \        return updateRecord(command, args);\n    case commands.deleteRecord:\n\
    \        return deleteRecord(command, args);\n    case commands.getRecord:\n \
    \       return getRecord(command, null, null, true);\n    case commands.searchApps:\n\
    \        return getListOfApplications(command);\n    case commands.searchRecords:\n\
    \        return searchRecords(command, args);\n    case commands.getAppFields:\n\
    \        return getAppFields();\n    case commands.fetchIncidents:\n        return\
    \ fetchIncidents(args);\n    case commands.getReports:\n        return getReports(command);\n\
    \    case commands.executeStatisticSearchByReport:\n        return executeStatisticSearchByReport(command,\
    \ args);\n    case commands.getSearchOptionsByGuid:\n        return getSearchOptionsByGuid(command,\
    \ args);\n    case commands.searchRecordsByReport:\n        return searchRecordsByReport(command,\
    \ args);\n    case commands.getMappingByLevel:\n        return createMappingFieldIdToName(args.level);\n\
    \    case commands.manualFetch:\n        return manualFetch(args);\n    case commands.getFile:\n\
    \        return getFile(args);\n    case commands.uploadFile:\n        return\
    \ uploadFile(args);\n    case commands.addToDetailedAnalysis:\n        return\
    \ addToDetailedAnalysis(args);\n    case commands.getUserId:\n        return getUserId(args);\n\
    \    case 'archer-reset-cache':\n        return resetIntegrationCache();\n   \
    \ case 'fetch-incidents':\n        return fetchIncidents(args);\n    default:\n\
    \        break;\n}"
  type: javascript
tests:
- Archer-Test-Playbook
toversion: 4.1.9
