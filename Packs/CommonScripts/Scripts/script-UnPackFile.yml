args:
- default: true
  description: Name of the file to unpack
  name: fileName
- description: entry id of the attached packed file in the warroom
  name: entryID
- description: Set to package file extension to look for the last of its kind in the
    war room
  name: lastPackedFileInWarroom
comment: 'UnPack a file using fileName or entryID to specify a file. Files unpacked
  will be pushed to the war room and names will be pushed to the context.

  supported types are:

  7z (.7z), ACE (.ace), ALZIP (.alz), AR (.a), ARC (.arc), ARJ (.arj), BZIP2 (.bz2),
  CAB (.cab), compress (.Z), CPIO (.cpio), DEB (.deb), DMS (.dms), GZIP (.gz), LRZIP
  (.lrz), LZH (.lha, .lzh), LZIP (.lz), LZMA (.lzma), LZOP (.lzo), RPM (.rpm), RAR
  (.rar), RZIP (.rz), TAR (.tar), XZ (.xz), ZIP (.zip, .jar) and ZOO (.zoo)'
commonfields:
  id: UnPackFile
  version: -1
dockerimage: demisto/unrar:1.4
enabled: true
name: UnPackFile
outputs:
- contextPath: ExtractedFiles
  description: list of file names which extracted from package
runonce: false
script: "from pyunpack import Archive\nimport os\nfrom os.path import isfile\nfrom\
  \ os.path import isdir\n\nfilePath = None\nfileEntryID = ''\nif demisto.args().has_key('fileName')\
  \ or demisto.args().has_key('lastPackedFileInWarroom'):\n    entries = demisto.executeCommand('getEntries',\
  \ {})\n    for entry in entries:\n        fn = demisto.get(entry, 'File')\n\n  \
  \      is_text = type(fn) in [unicode, str]\n        is_correct_file = demisto.args().get('fileName',\
  \ '').lower() == fn.lower()\n\n        if is_text:\n            if demisto.args().has_key('fileName')\
  \ and is_correct_file:\n                fileEntryID = entry['ID']\n            \
  \    break\n            if demisto.args().has_key('lastPackedFileInWarroom') and\
  \ fn.lower().endswith(demisto.args().get('lastPackedFileInWarroom', '').lower()):\n\
  \                fileEntryID = entry['ID']\n\n    if fileEntryID == '':\n      \
  \  errorMessage = ''\n        if demisto.args().has_key('fileName'):\n         \
  \   demisto.results({\n                'Type': entryTypes['error'],\n          \
  \      'ContentsFormat': formats['text'],\n                'Contents': '\"' + demisto.args().get('fileName')\
  \ + '\" no such file in the war room'\n            })\n        if demisto.args().has_key('lastPackedFileInWarroom'):\n\
  \            demisto.results({\n                'Type': entryTypes['error'],\n \
  \               'ContentsFormat': formats['text'],\n                'Contents':\
  \ 'Could not find \"' + demisto.args().get('lastPackedFileInWarroom', '') + '\"\
  \ file in war room'\n            })\n\n        sys.exit(0)\n\nif demisto.args().has_key('entryID'):\n\
  \    fileEntryID = demisto.args().get('entryID')\n\nif not fileEntryID:\n    demisto.results({\n\
  \        'Type': entryTypes['error'],\n        'ContentsFormat': formats['text'],\n\
  \        'Contents': 'You must set entryID or fileName or lastPackedFileInWarroom=i.e.(zip)\
  \ when executing Unpack script'\n    })\n    sys.exit(0)\n\nres = demisto.executeCommand('getFilePath',\
  \ {'id': fileEntryID})\nif res[0]['Type'] == entryTypes['error']:\n    demisto.results({\n\
  \        'Type': entryTypes['error'],\n        'ContentsFormat': formats['text'],\n\
  \        'Contents': 'Failed to get the file path for entry: ' + fileEntryID\n \
  \   })\n    sys.exit(0)\n\nfilePath = res[0]['Contents']['path']\n\nfilenames =\
  \ []\n# remembering which files and dirs we currently have so we add them later\
  \ as newly extracted files.\nexcludedFiles = [f for f in os.listdir('.') if isfile(f)]\n\
  excludedDirs = [d for d in os.listdir('.') if isdir(d)]\n\n# extracting the archive\
  \ file\nArchive(filePath).extractall_patool('.', None)\n# recursing over the file\
  \ system top down\nfor root, directories, files in os.walk('.'):\n    # removing\
  \ the previously existing dirs from the search\n    directories[:] = [d for d in\
  \ directories if d not in excludedDirs]\n    for f in files:\n        # skipping\
  \ previously existing files and verifying that the current file is a file and then\
  \ adding it to the extracted files list\n        if f not in excludedFiles and isfile(os.path.join(root,\
  \ f)):\n            filenames.append(os.path.join(root,f))\nif len(filenames) ==\
  \ 0:\n    demisto.results({\n        'Type': entryTypes['error'],\n        'ContentsFormat':\
  \ formats['text'],\n        'Contents': 'Could not find files in archive'\n    })\n\
  else:\n    results = []\n    # extracted files can be in sub directories so we save\
  \ the base names of the files and also the full path of the file\n    files_base_names\
  \ = [os.path.basename(file_path) for file_path in filenames]\n    files_dic = {file_path:\
  \ os.path.basename(file_path) for file_path in filenames}\n    for file_path, file_name\
  \ in files_dic.items():\n        demisto.results(file_result_existing_file(file_path,\
  \ file_name))\n    results.append(\n        {\n            'Type': entryTypes['note'],\n\
  \            'ContentsFormat': formats['json'],\n            'Contents': { 'extractedFiles':\
  \ files_base_names },\n            'EntryContext': { 'ExtractedFiles': files_base_names,\
  \ 'File(val.EntryID==\"' + fileEntryID + '\").Unpacked': True },\n            'ReadableContentsFormat'\
  \ : formats['markdown'],\n            'HumanReadable': tableToMarkdown('Extracted\
  \ Files', [ { 'name': file_name , 'path': file_path } for file_path, file_name in\
  \ files_dic.items()])\n        })\n    demisto.results(results)"
scripttarget: 0
subtype: python2
tags:
- Utility
- file
toversion: 4.1.9
type: python
