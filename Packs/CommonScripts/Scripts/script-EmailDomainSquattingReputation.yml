args:
- default: true
  description: The email address to check
  name: email
  required: true
- description: The domain list to check against for squatting (comma separated)
  isArray: true
  name: domain
  required: true
- defaultValue: '3'
  description: The similarity threshold
  name: threshold
comment: Check if an email address's domain is trying to squat other domain using
  Levenshtein distance algorithm
commonfields:
  id: EmailDomainSquattingReputation
  version: -1
name: EmailDomainSquattingReputation
outputs:
- contextPath: Account
  description: 'A user account '
- contextPath: Account.Email
  description: The account email object
- contextPath: Account.Email.Username
  description: The account email username
  type: string
- contextPath: Account.Email.Address
  description: The account email address
  type: string
- contextPath: Account.Email.Domain
  description: The account email domain
  type: string
- contextPath: Account.Email.Distance
  description: The email address distance compare to the domains in query
  type: number
- contextPath: Account.Email.Distance.Domain
  description: The compared domain
  type: string
- contextPath: Account.Email.Distance.Value
  description: 'The distance between the email domain and the compared domain '
  type: number
- contextPath: DBotScore.Indicator
  description: The Indicator
  type: string
- contextPath: DBotScore.Type
  description: The Indicator Type
  type: string
- contextPath: DBotScore.Vendor
  description: The DBot score vendor
  type: string
- contextPath: DBotScore.Score
  description: The DBot score
  type: number
runonce: false
script: "\nvar email = args.email;\nvar domains = argToList(args.domain);\nvar threshold\
  \ = parseInt(args.threshold);\n\nvar emailParts = email.split('@',2);\n\nif (emailParts.length\
  \ < 2){\n    return {\n        ContentsFormat: formats.text,\n        Type: entryTypes.error,\n\
  \        Contents: email.toString() + \" - is not a valid email address\"\n    };\n\
  }\nvar emailObj = {\n    Username: emailParts[0],\n    Domain: emailParts[1],\n\
  \    Address : email,\n    Distance : []\n};\n\ndomains.forEach(function(domain){\n\
  \  if(domain) {\n      var resp = executeCommand(\"GetStringsDistance\", {inputString:\
  \ emailObj.Domain, compareString: domain});\n\n      if(isError(resp[0])){\n   \
  \       return resp;\n      }\n\n      data = [dq(resp[0], \"Contents.Distances\"\
  )];\n      data.forEach(function(entry)\n      {\n          emailObj.Distance.push(\n\
  \              {\n                  Domain  : dq(entry,\"StringB\"),\n         \
  \         Value   : dq(entry,\"LevenshteinDistance\")\n              });\n     \
  \ });\n  }\n});\nvar ec = {};\nvar suspicious = dq(emailObj,\"Distance(val.Value\
  \ > 0 && val.Value < {0}).Value\".format(threshold));\nvar dbotScore = 0;\nvar malicious\
  \ = null;\n\nif(suspicious && suspicious.length > 0){\n    //add dbot score, suspicious\n\
  \    ec.DBotScore = {\n        Indicator: email,\n        Type: 'email',\n     \
  \   Vendor: 'DomainSquatting', Score: 2\n    };\n    //add suspicious description\
  \ to the indicator\n    malicious = {\n        Vendor: \"DomainSquatting\",\n  \
  \      Description : \"The email address domain is suspicious at domain squatting\"\
  \n    };\n}\n\nvar account = {Email: emailObj};\nif (malicious){\n    account.Malicious\
  \ = malicious;\n}\n\nec[\"Account(val.Email && val.Email.Address && val.Email.Address\
  \ === obj.Email.Address)\"] = account;\n\nvar md = tableToMarkdown(\"Domain squatting\
  \ reputation for {0}\".format(email),emailObj.Distance);\n\nreturn {\n    Type:\
  \ entryTypes.note,\n    Contents: emailObj,\n    ContentsFormat: formats.json,\n\
  \    HumanReadable: md,\n    EntryContext: ec\n};"
scripttarget: 0
system: true
tags:
- email
- reputation
toversion: 4.1.9
type: javascript
