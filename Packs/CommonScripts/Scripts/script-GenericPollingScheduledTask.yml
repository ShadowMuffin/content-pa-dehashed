args:
- description: List of IDs to poll
  isArray: true
  name: ids
  required: true
- description: IDs with pending status
  name: pendingIds
- description: Name of the polling command to run
  name: pollingCommand
  required: true
- defaultValue: ids
  description: Name of the argument of the polling command
  name: pollingCommandArgName
  required: true
- description: Polling frequency - how often the polling command should run (minutes)
  name: interval
  required: true
- description: How much time to poll before declaring a timeout and resuming the playbook
    (minutes)
  name: timeout
  required: true
- description: The ID of the playbook that contains the manual task which will be
    completed once the polling is done.
  name: playbookId
- defaultValue: polling
  description: The tag of the blocking manual task ("Wait For Polling Task To Finish")
  name: tag
  required: true
- description: Names of additional arguments for the polling command (e.g. arg1,arg2,...)
  isArray: true
  name: additionalPollingCommandArgNames
- description: Commas separated arguments values of the polling command
  isArray: true
  name: additionalPollingCommandArgValues
comment: Runs the polling command repeatedly, completes a blocking manual task when
  polling is done.
commonfields:
  id: GenericPollingScheduledTask
  version: -1
enabled: true
name: GenericPollingScheduledTask
runonce: false
script: "/**\n * GenericPollingScheduledTask\n *   This task is ment to be scheduled\
  \ by the ScheduleGenericPolling automation\n *   Logic:\n *     This task schedules\
  \ itself to run 'interval' minutes from the current run, and decrease the 'timeout'\
  \ accordingly.\n *     This happens until the end condition is met: either the 'timeout'\
  \ reaches 0, or all IDs are finished running.\n *     Once the end condition is\
  \ met, this task will complete the manual task with the given playbookID and tag.\n\
  \ *\n *     The 'dt' parameter, when applied to the context, should retrieve a list\
  \ of ids which have not finished running.\n *     Example:\n *          dt = \"\
  Joe.Analysis(val.Status != 'finished').ID\"\n *          Breakdown:\n *        \
  \      Joe - integration name\n *              Analysis - the object that contains\
  \ the ID and the status\n *              Status - can be 'submitted', 'running'\
  \ or 'finished'\n *              ID - the key that contains the id for polling\n\
  \ */\n\nfunction listOfStrings(v) {\n    if (!Array.isArray(v)) {\n        v = [v];\n\
  \    }\n    for (var i = 0; i < v.length; i++) {\n        v[i] = v[i].toString();\n\
  \    }\n    return v;\n}\n\n// https://stackoverflow.com/questions/16227197/compute-intersection-of-two-arrays-in-javascript#16227294\n\
  function intersect(a, b) {\n    var t;\n    if (b.length > a.length) t = b, b =\
  \ a, a = t; // indexOf to loop over shorter\n    return a.filter(function (e) {\n\
  \        return b.indexOf(e) > -1;\n    }).filter(function (e, i, c) { // extra\
  \ step to remove duplicates\n        return c.indexOf(e) === i;\n    });\n}\n\n\
  function finish(playbookId, tag, err) {\n    var params = { 'id': tag };\n    if\
  \ (err === undefined) {\n        params.input = 'YES';\n    } else {\n        params.input\
  \ = 'NO'\n    }\n    if (playbookId) {\n        params.parentPlaybookID = playbookId;\n\
  \    }\n    return executeCommand(\"taskComplete\", params);\n}\n\nfunction setNextRun(ids,\
  \ playbookId, pollingCommand, pollingCommandArgName, pendingIds, interval, timeout,\
  \ tag, additionalArgNames, additionalArgValues) {\n    var idsStr = ids.replace(/\"\
  /g, '\\\\\"');\n    var playbookIdStr = '';\n    if (playbookId !== undefined) {\n\
  \        playbookIdStr = ' playbookId=\"' + playbookId + '\"';\n    }\n    var cmd\
  \ = '!GenericPollingScheduledTask pollingCommand=\"' + pollingCommand + '\" pollingCommandArgName=\"\
  ' + pollingCommandArgName + '\"' + playbookIdStr;\n    cmd += ' ids=\"' + idsStr\
  \ + '\" pendingIds=\"' + pendingIds.replace(/\"/g,'\\\\\"') + '\" interval=\"' +\
  \ interval + '\" timeout=\"' + (parseInt(timeout) - parseInt(interval)) + '\" tag=\"\
  ' + tag + '\"';\n    cmd += ' additionalPollingCommandArgNames=\"' + additionalArgNames\
  \ + '\" additionalPollingCommandArgValues=\"' + additionalArgValues + '\"';\n  \
  \  return executeCommand(\"ScheduleCommand\", {\n        'command': cmd,\n     \
  \   'cron': '*/' + interval + ' * * * *',\n        'times': 1\n    });\n}\n\ntry\
  \ {\n    if (args.timeout <= 0) {\n        return finish(args.playbookId, args.tag);\n\
  \    }\n\n    // Get ids that have not finished yet\n    var ids = argToList(args.ids);\n\
  \    for (var i = 0; i < ids.length; i++) {\n        ids[i] = ids[i].replace(/[\\\
  \\]*\"/g, '');\n    }\n\n\n    // Set the context of the scheduled task to the local\
  \ playbook context\n    var idsToPoll = ids;\n    var pendingPath = args.pendingIds;\n\
  \    if ('playbookId' in args) {\n        playbookContext = 'subplaybook-' + args.playbookId;\n\
  \        pendingPath = playbookContext + \".\" + args.pendingIds;\n    }\n    var\
  \ pendings = dq(invContext, pendingPath);\n\n    if (pendings === null) {\n    \
  \    return finish(args.playbookId, args.tag);\n    }\n\n    var idsStrArr = listOfStrings(ids);\n\
  \    var pendingsStrArr = listOfStrings(pendings);\n    idsToPoll = intersect(idsStrArr,\
  \ pendingsStrArr);\n    if (idsToPoll.length === 0) {\n        return finish(args.playbookId,\
  \ args.tag);\n    }\n\n    // Run the polling command for each id\n    var pollingCommandArgs\
  \ = {};\n    var names = argToList(args.additionalPollingCommandArgNames);\n   \
  \ var values = argToList(args.additionalPollingCommandArgValues);\n\n    for (var\
  \ index = 0; index < names.length; index++)\n        pollingCommandArgs[names[index]]\
  \ = values[index];\n\n    pollingCommandArgs[args.pollingCommandArgName] = idsToPoll.join(',');\n\
  \    var res = executeCommand(args.pollingCommand, pollingCommandArgs);\n\n    //\
  \ Change the context output of the polling results to the local playbook context\n\
  \    if ('playbookId' in args) {\n        for (var i = 0; i < res.length; i++) {\n\
  \            if ('EntryContext' in res[i]) {\n                for (var k in res[i].EntryContext)\
  \ {\n                    res[i].EntryContext[playbookContext + \".\" + k] = res[i].EntryContext[k];\n\
  \                    delete res[i].EntryContext[k];\n                }\n       \
  \     }\n        }\n    }\n\n    // Schedule the next iteration\n    var scheduleTaskRes\
  \ = setNextRun(args.ids, args.playbookId, args.pollingCommand, args.pollingCommandArgName,\
  \ args.pendingIds, args.interval, args.timeout, args.tag, args.additionalPollingCommandArgNames,\
  \ args.additionalPollingCommandArgValues);\n    if (isError(scheduleTaskRes[0]))\
  \ {\n        res.push(scheduleTaskRes);\n    }\n\n    return res;\n}\ncatch (err)\
  \ {\n    finish(args.playbookId, args.tag, err);\n    throw err;\n}"
scripttarget: 0
tags: []
tests:
- No test
toversion: 4.1.9
type: javascript
