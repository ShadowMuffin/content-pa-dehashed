args:
- default: true
  description: The domain to be measured against the domain in the sender's email
    address.Usually the domain used by the company for email, e.g. acme.com when users
    are assigned jane@acme.com (could be multiple domains with a comma separator)
  name: domain
  required: true
- description: Sender email address
  name: sender
  required: true
- defaultValue: '3'
  description: Distance that is considered close
  name: distance
  required: false
comment: Get the string distance for the sender from our domain
commonfields:
  id: CheckSenderDomainDistance
  version: -1
dependson: {}
name: CheckSenderDomainDistance
outputs:
- contextPath: LevenshteinDistance
  description: The closeness of the sender domain to our configured domains
script: "import re\n\ndef levenshtein(s1, s2):\n    l1 = len(s1)\n    l2 = len(s2)\n\
  \    matrix = [range(l1 + 1)] * (l2 + 1)\n    for zz in range(l2 + 1):\n       \
  \ matrix[zz] = range(zz,zz + l1 + 1)\n    for zz in range(0,l2):\n        for sz\
  \ in range(0,l1):\n            if s1[sz] == s2[zz]:\n                matrix[zz+1][sz+1]\
  \ = min(matrix[zz+1][sz] + 1, matrix[zz][sz+1] + 1, matrix[zz][sz])\n          \
  \  else:\n                matrix[zz+1][sz+1] = min(matrix[zz+1][sz] + 1, matrix[zz][sz+1]\
  \ + 1, matrix[zz][sz] + 1)\n    return matrix[l2][l1]\n\nres = []\nfound = False\n\
  \ndomains = argToList(demisto.get(demisto.args(), 'domain'))\nif not domains:\n\
  \    res.append({'Type': entryTypes['error'], 'ContentsFormat': formats['text'],\
  \ 'Contents': 'Unable to extract domain from arguments'})\nelse:\n    sender = demisto.get(demisto.args(),\
  \ 'sender')\n    if sender:\n        parts = sender.split('@')\n        if len(parts)\
  \ == 2:\n            if not parts[1] in domains:\n                distances = []\n\
  \                for domain in domains:\n                    distance = levenshtein(domain,\
  \ parts[1])\n                    distances.append(distance)\n                  \
  \  closeDistance = demisto.get(demisto.args(), 'distance')\n                   \
  \ closeDistanceInt = int(closeDistance) if closeDistance else 3\n              \
  \      if distance > 0 and distance < closeDistanceInt:\n                      \
  \  res.append({'Type': entryTypes['note'], 'ContentsFormat': formats['text'], 'Contents':\
  \ 'Domain ' + parts[1] + ' is suspiciously close to ' + domain})\n             \
  \           found = True\n                if len(distances) > 0:\n             \
  \       # Override the context on each run\n                    demisto.setContext('LevenshteinDistance',\
  \ distances if len(distances) > 1 else distances[0])\n        else:\n          \
  \  res.append({'Type': entryTypes['error'], 'ContentsFormat': formats['text'], 'Contents':\
  \ 'Unable to extract domain from sender - ' + sender})\n    else:\n        res.append({'Type':\
  \ entryTypes['error'], 'ContentsFormat': formats['text'], 'Contents': 'Unable to\
  \ find sender in email'})\nif found:\n    res.append('yes')\nelse:\n    res.append('no')\n\
  demisto.results(res)"
scripttarget: 0
subtype: python2
system: true
tags:
- server
- phishing
- Condition
timeout: 0s
toversion: 4.1.9
type: python
