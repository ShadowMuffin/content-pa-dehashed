args:
- default: true
  description: The data to apply the filter on
  isArray: true
  name: data
  required: true
- description: The type of filter to apply. Available filters are upper, lower, join,
    split, index, substr, trim, regex, replace
  name: filterType
  required: true
- description: The data for the filter. join - the join string between elements (optional,
    default is ','). split - the string on which to split (optional, default is ',').
    index - the index of the array to return (optional, default 0). substr - the from
    (inclusive) and length (optional, default is to end of string). regex - the regular
    expression to match. replace - a regular expression to replace and with what.
  name: filter
- description: The name of the context output parameter we should write to
  name: out
  required: true
- description: Additional arguments to add to filter. flags for regex. flags, replace
    string for replace. length for substr.
  name: additional
comment: Filter context keys by applying one of the various available manipulations
  and storing in a new context key. Please notice that the resulting context key will
  not be available automatically as an option but you can still specify it.
commonfields:
  id: ContextFilter
  version: -1
dependson: {}
enabled: true
name: ContextFilter
script: "if (!args.data) {\n    return {ContentsFormat: formats.text, Type: entryTypes.error,\
  \ Contents: 'Data is empty, filter not applied'};\n}\n\nif (['upper', 'lower', 'split',\
  \ 'substr', 'trim', 'regex', 'replace'].indexOf(args.filterType) >= 0 && typeof\
  \ args.data !== 'string') {\n    return {ContentsFormat: formats.text, Type: entryTypes.error,\
  \ Contents: 'Data is not a string, cannot convert'};\n}\n\nif (['join', 'index'].indexOf(args.filterType)\
  \ >= 0 && !Array.isArray(args.data)) {\n    return {ContentsFormat: formats.text,\
  \ Type: entryTypes.error, Contents: 'Data is not a array, cannot convert'};\n}\n\
  var ec = {};\nvar md = '';\n// Supported types are upper, lower, join, split, index,\
  \ substr, trim, regex, replace, jq\nswitch (args.filterType) {\n    case 'upper':\n\
  \        ec[args.out] = args.data.toUpperCase();\n        md = 'Converted data to\
  \ upper case and stored in ' + args.out;\n        break\n    case 'lower':\n   \
  \     ec[args.out] = args.data.toLowerCase();\n        md = 'Converted data to lower\
  \ case and stored in ' + args.out;\n        break\n    case 'join':\n        var\
  \ join = (args.filter) ? args.filter : ',';\n        ec[args.out] = args.data.join(join);\n\
  \        md = 'Joined data to ' + args.out;\n        break\n    case 'split':\n\
  \        var split = (args.filter) ? args.filter : ',';\n        ec[args.out] =\
  \ args.data.split(split);\n        md = 'Split data to ' + args.out;\n        break\n\
  \    case 'index':\n        var index = (args.filter) ? args.filter : '0';\n   \
  \     var i = parseInt(index);\n        if (isNaN(i)) {\n            return {ContentsFormat:\
  \ formats.text, Type: entryTypes.error, Contents: 'filter is not a number'};\n \
  \       }\n        if (i < 0) {\n            i = args.data.length + (i % args.data.length);\n\
  \        }\n        ec[args.out] = args.data[i];\n        md = 'Returned element\
  \ ' + index + ' from data to ' + args.out;\n        break\n    case 'substr':\n\
  \        var sub = (args.filter) ? args.filter : '0';\n        var from = parseInt(sub);\n\
  \        if (isNaN(from)) {\n            return {ContentsFormat: formats.text, Type:\
  \ entryTypes.error, Contents: 'filter from is not a number'};\n        }\n     \
  \   var len = args.data.length - from;\n        if (args.additional) {\n       \
  \     len = parseInt(args.additional);\n            if (isNaN(len)) {\n        \
  \        return {ContentsFormat: formats.text, Type: entryTypes.error, Contents:\
  \ 'filter length is not a number'};\n            }\n        }\n        ec[args.out]\
  \ = args.data.substr(from, len);\n        md = 'Returned substr from data to ' +\
  \ args.out;\n        break\n    case 'trim':\n        ec[args.out] = args.data.substr(from,\
  \ len);\n        md = 'Trimmed data to ' + args.out;\n        break\n    case 'regex':\n\
  \        if (!args.filter) {\n            return {ContentsFormat: formats.text,\
  \ Type: entryTypes.error, Contents: 'Regex not provided to filter'};\n        }\n\
  \        var flags = (args.additional) ? args.additional : 'i'; // Default is to\
  \ ignore case\n        var r = new RegExp(args.filter, flags);\n        var res\
  \ = r.exec(args.data);\n        if (!res) {\n            ec[args.out] = '';\n  \
  \          md = 'Regex was not found. Placed empty string in ' + args.out;\n   \
  \     } else {\n            ec[args.out] = res[0];\n            md = 'Returned regex\
  \ match from data to ' + args.out;\n        }\n        break\n    case 'replace':\n\
  \        if (!args.filter) {\n            return {ContentsFormat: formats.text,\
  \ Type: entryTypes.error, Contents: 'Regex not provided to filter'};\n        }\n\
  \        var replace = (args.additional) ? args.additional : ''; // Default is to\
  \ just remove the match\n        var r = new RegExp(args.filter, 'i');\n       \
  \ ec[args.out] = args.data.replace(r, replace);\n        md = 'Replaced match from\
  \ data to ' + args.out;\n        break\n}\nif (md !== '') {\n    return {Type: entryTypes.note,\
  \ Contents: ec, ContentsFormat: formats.json, HumanReadable: md, EntryContext: ec};\n\
  }\nreturn {ContentsFormat: formats.text, Type: entryTypes.error, Contents: 'Unknown\
  \ filter type - ' + args.filterType};\n"
scripttarget: 0
system: true
tags:
- Utility
timeout: 0s
toversion: 4.1.9
type: javascript
