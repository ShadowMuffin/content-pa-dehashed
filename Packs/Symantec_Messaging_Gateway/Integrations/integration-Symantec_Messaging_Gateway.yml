category: Email Gateway
commonfields:
  id: Symantec Messaging Gateway
  version: -1
configuration:
- defaultvalue: ''
  display: Server URL (e.g. https://192.168.0.1:20013)
  name: server
  required: true
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: ''
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Symantec Messaging Gateway protects against spam, malware, targeted attacks
  and provides advanced content filtering, data loss prevention, and email encryption.
display: Symantec Messaging Gateway
image: data:image/png;base64,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
name: Symantec Messaging Gateway
script:
  commands:
  - arguments:
    - default: true
      description: Email address to block
      name: email
      required: true
    description: Adds email address to the Local Bad Sender Domains.
    execution: true
    name: smg-block-email
    outputs:
    - contextPath: Email.Address
      description: Email address that was blocked
      type: string
    - contextPath: Email.Blocked
      description: True if blocked, False if unblocked
      type: boolean
  - arguments:
    - default: true
      description: Email address to unblock
      name: email
      required: true
    description: Removes email address from the Local Bad Sender Domains.
    execution: true
    name: smg-unblock-email
    outputs:
    - contextPath: Email.Address
      description: Email address that was unblocked
      type: string
    - contextPath: Email.Blocked
      description: True if blocked, False if unblocked
      type: boolean
  - arguments:
    - default: true
      description: Domain to block
      name: domain
      required: true
    description: Adds domain to the Local Bad Sender Domains group.
    execution: true
    name: smg-block-domain
    outputs:
    - contextPath: Domain.Name
      description: Domain name that was blocked
      type: string
    - contextPath: Domain.Blocked
      description: True if blocked, False if unblocked
      type: boolean
  - arguments:
    - default: true
      description: IP address to block
      name: ip
      required: true
    description: Adds IP address to the Local Bad Sender IPs  group.
    execution: true
    name: smg-block-ip
    outputs:
    - contextPath: IP.Address
      description: IP address that was blocked
      type: string
    - contextPath: IP.Blocked
      description: True if blocked, False if unblocked
      type: boolean
  - arguments:
    - default: true
      description: IP address to unblock
      name: ip
      required: true
    description: Removes IP address from the Local Bad Sender IPs  group.
    execution: true
    name: smg-unblock-ip
  - arguments:
    - default: true
      description: Domain to unblock
      name: domain
      required: true
    description: Removes domain from the Local Bad Sender Domains group.
    execution: true
    name: smg-unblock-domain
    outputs:
    - contextPath: Domain.Name
      description: Domain name that was unblocked
      type: string
    - contextPath: Domain.Blocked
      description: True if blocked, False if unblocked
      type: boolean
  - arguments: []
    description: Returns a list of all blocked email addresses.
    name: smg-get-blocked-domains
  - arguments: []
    description: Returns a list of all blocked IP addresses.
    name: smg-get-blocked-ips
  dockerimage: demisto/bs4:1.0.0.7863
  dockerimage45: demisto/bs4
  script: "import requests\nimport os\nfrom bs4 import BeautifulSoup\n# disable insecure\
    \ warnings\nrequests.packages.urllib3.disable_warnings()\n\n''' GLOBAL VARS '''\n\
    SERVER = demisto.params()['server'][:-1] if demisto.params()['server'].endswith('/')\
    \ else demisto.params()['server']\nUSERNAME=demisto.params()['credentials']['identifier']\n\
    PASSWORD=demisto.params()['credentials']['password']\nBASE_URL = SERVER + '/brightmail/'\n\
    USE_SSL = not demisto.params().get('insecure', False)\nCOOKIES = {}\n\nif not\
    \ demisto.params()['proxy']:\n    del os.environ['HTTP_PROXY']\n    del os.environ['HTTPS_PROXY']\n\
    \    del os.environ['http_proxy']\n    del os.environ['https_proxy']\n\nBAD_DOMAINS_EMAILS_GROUP\
    \ = 'Local Bad Sender Domains'\nBAD_IPS_GROUP = 'Local Bad Sender IPs'\n\n'''\
    \ HELPER FUNCTIONS '''\ndef http_request(method, url_suffix, cookies=COOKIES,\
    \ data=None, headers=None):\n    LOG('running request with url=%s\\tdata=%s\\\
    theaders=%s' % (BASE_URL + url_suffix,\n        data, headers))\n    try:\n  \
    \      res = requests.request(\n            method,\n            BASE_URL + url_suffix,\n\
    \            verify=USE_SSL,\n            data=data,\n            headers=headers,\n\
    \            cookies=cookies\n        )\n\n        if res.status_code not in (200,\
    \ 204):\n            raise Exception('Your request failed with the following error:\
    \ ' + res.reason)\n    except Exception, e:\n        LOG(e)\n        raise\n \
    \   return res\n\ndef login():\n    login_do_url = 'viewLogin.do'\n    login_do_response\
    \ = http_request('get', login_do_url, cookies=None)\n    login_jsession = login_do_response.cookies.get_dict()['JSESSIONID']\n\
    \n    soup = BeautifulSoup(login_do_response.content, \"lxml\")\n    hidden_tags\
    \ = soup.find_all(\"input\", type=\"hidden\") # Parse <input type=hidden>\n  \
    \  for tag in hidden_tags:\n        name = tag.attrs.get('name', None)\n     \
    \   if name == 'lastlogin':\n            last_login = tag.attrs['value']\n   \
    \ cookies = {\n        'JSESSIONID': login_jsession\n    }\n    data = {\n   \
    \     'lastlogin': last_login,\n        'username': USERNAME,\n        'password':\
    \ PASSWORD\n    }\n    login_url = 'login.do'\n    login_response = http_request('post',\
    \ login_url, cookies=cookies, data=data)\n\n    #if JSESSIONID doesn't exist -\
    \ creds may be invalid\n    if 'JSESSIONID' not in login_response.cookies:\n \
    \       return_error('Failed to login. Username or password may be invalid')\n\
    \n    jsession = login_response.cookies.get_dict()['JSESSIONID']\n\n    # Add\
    \ Jsession ID to the cookies\n    COOKIES['JSESSIONID'] = jsession\n\n    # Get\
    \ Token\n    login_do_url = 'admin/backup/backupNow.do'\n    login_do_response\
    \ = http_request('get', login_do_url)\n    soup = BeautifulSoup(login_do_response.content,\
    \ \"lxml\")\n    hidden_tags = soup.find_all(\"input\", type=\"hidden\") # Parse\
    \ <input type=hidden>\n    for tag in hidden_tags:\n        name = tag.attrs.get('name',\
    \ None)\n        if name == 'symantec.brightmail.key.TOKEN':\n            token\
    \ = tag.attrs['value']\n            return token\n\ndef get_selected_sender_groups(group):\n\
    \    '''\n    Gets bad group name, i.e. Local Bad Sender Domains, and returns\
    \ the bad group identifer, i.e. 1|3\n    The identifier is needed in any sent\
    \ query related to the bad group\n    '''\n    cmd_url = 'reputation/sender-group/viewSenderGroups.do?view=badSenders'\n\
    \    groups = http_request('get', cmd_url)\n    soup = BeautifulSoup(groups.content,\
    \ 'lxml')\n\n    tds_group_names_array = soup.find_all('td') # Parse <td>\n  \
    \  for td in tds_group_names_array:\n        a_href = td.find('a') # Parse <a>\n\
    \        if a_href:\n            href_string = a_href.string # Extracts the string\
    \ from the <a>string</a> tags\n            checked_group = ' '.join(href_string.split())\
    \ # Removes whitespaces from string\n            if checked_group == group:\n\
    \                previous_td = td.previous_sibling.previous_sibling\n        \
    \        input_tag = previous_td.find('input') # Parse <input> tags\n        \
    \        if input_tag:\n                    group_number = input_tag['value']\n\
    \                    return group_number\n\ndef block_request(ioc, selected_sender_groups):\n\
    \    cmd_url = 'reputation/sender-group/saveSender.do'\n    data = {\n       \
    \ 'pageReuseFor': 'add',\n        'selectedSenderGroups': selected_sender_groups,\n\
    \        'view': 'badSenders',\n        'symantec.brightmail.key.TOKEN': TOKEN,\n\
    \        'addEditSenders': ioc\n    }\n    response = http_request('post', cmd_url,\
    \ data=data)\n    # Check if given domain/email address is valid and is not already\
    \ blocked\n    soup = BeautifulSoup(response.content, 'lxml')\n    # Look for\
    \ the error message\n    error = soup.find('div','errorMessageText')\n    if error:\
    \ # Error occured\n        error_message = ' '.join(error.text.split())# Removes\
    \ whitespaces from string\n        return error_message\n\ndef unblock_request(selected_group_member,\
    \ selected_sender_groups):\n    cmd_url = 'reputation/sender-group/deleteSender.do'\n\
    \    data = {\n        'selectedSenderGroups': selected_sender_groups,\n     \
    \   'view': 'badSenders',\n        'symantec.brightmail.key.TOKEN': TOKEN,\n \
    \       'selectedGroupMembers': int(selected_group_member)\n    }\n    response\
    \ = http_request('post', cmd_url, data=data)\n\ndef get_blocked_request(sender_group):\n\
    \    selected_sender_groups = get_selected_sender_groups(sender_group)\n    cmd_url\
    \ = 'reputation/sender-group/viewSenderGroup.do'\n    data = {\n        'selectedSenderGroups':\
    \ selected_sender_groups,\n        'view': 'badSenders',\n        'symantec.brightmail.key.TOKEN':\
    \ TOKEN\n    }\n    blocked = http_request('post', cmd_url, data=data)\n    return\
    \ blocked\n\ndef get_next_page(selected_sender_groups):\n    '''\n    Gets next\
    \ page in bad list\n    '''\n    cmd_url = 'reputation/sender-group/viewNextPage.do'\n\
    \    data = {\n        'selectedSenderGroups': selected_sender_groups,\n     \
    \   'view': 'badSenders',\n        'symantec.brightmail.key.TOKEN': TOKEN\n  \
    \  }\n    next_page = http_request('post', cmd_url, data=data)\n    return next_page\n\
    \n''' FUNCTIONS '''\ndef get_blocked_domains():\n    selected_sender_groups =\
    \ get_selected_sender_groups(BAD_DOMAINS_EMAILS_GROUP)\n    blocked_domains =\
    \ get_blocked_request(BAD_DOMAINS_EMAILS_GROUP)\n    hr='### SMG Blocked domains:\\\
    n'\n    soup = BeautifulSoup(blocked_domains.content, 'lxml')\n    # Handles pagination\
    \ of Local Bad Sender Domains\n    pages = soup.find('select', 'defaultDrop',\
    \ id=\"pageNumber\").find_all('option')\n    for i in range(len(pages)): # Loop\
    \ through all pages of blocked IP address\n        tds_array = soup.find_all('td',\
    \ 'paddingL3') # Parse <td>\n        for td in tds_array:\n            a = td.find('a')\
    \ # Parse <a>\n            if a:\n                s = str(a.find_next_sibling(text=True))\
    \ # Get domain\n                hr += '- ' + ''.join(s.split()) + '\\n' # Removes\
    \ whitespaces from string\n        # Get next page\n        next_page = get_next_page(selected_sender_groups)\n\
    \        soup = BeautifulSoup(next_page.content, 'lxml')\n\n    entry = {\n  \
    \      'Type': entryTypes['note'],\n        'Contents': hr,\n        'ContentsFormat':\
    \ formats['json'],\n        'ReadableContentsFormat': formats['markdown'],\n \
    \       'HumanReadable': hr\n    }\n    return entry\n\ndef get_blocked_ips():\n\
    \    selected_sender_groups = get_selected_sender_groups(BAD_IPS_GROUP)\n    blocked_emails\
    \ = get_blocked_request(BAD_IPS_GROUP)\n    hr='### SMG Blocked IP addresses:\\\
    n'\n    soup = BeautifulSoup(blocked_emails.content, 'lxml')\n    # Handles pagination\
    \ of Local Bad Sender IPs\n    pages = soup.find('select', 'defaultDrop', id=\"\
    pageNumber\").find_all('option')\n    for i in range(len(pages)): # Loop through\
    \ all pages of blocked IP address\n        tds_array = soup.find_all('td', 'paddingL3')\
    \ # Parse <td>\n        for td in tds_array:\n            a = td.find('a') # Parse\
    \ <a>\n            if a:\n                s = str(a.find_next_sibling(text=True))\
    \ # Get IP address\n                hr += '- ' + ''.join(s.split()) + '\\n' #\
    \ Removes whitespaces from string\n        # Get next page\n        next_page\
    \ = get_next_page(selected_sender_groups)\n        soup = BeautifulSoup(next_page.content,\
    \ 'lxml')\n\n    entry = {\n        'Type': entryTypes['note'],\n        'Contents':\
    \ hr,\n        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': hr\n    }\n    return entry\n\
    \ndef block_email(email):\n    selected_sender_groups = get_selected_sender_groups(BAD_DOMAINS_EMAILS_GROUP)\n\
    \    error_message = block_request(email, selected_sender_groups)\n    if error_message:\n\
    \        return error_message\n    context = {\n        'Address': email,\n  \
    \      'Blocked': True\n    }\n    ec = {\n        'Email(val.Address && val.Address\
    \ === obj.Address)': context\n    }\n    message = 'Email address ' + email +\
    \ ' was blocked successfully.'\n    entry = {\n        'Type': entryTypes['note'],\n\
    \        'Contents': message,\n        'ContentsFormat': formats['json'],\n  \
    \      'ReadableContentsFormat': formats['markdown'],\n        'HumanReadable':\
    \ message,\n        'EntryContext': ec\n    }\n    return entry\n\ndef unblock_email(email):\n\
    \    selected_sender_groups = get_selected_sender_groups(BAD_DOMAINS_EMAILS_GROUP)\n\
    \    blocked_emails = get_blocked_request(BAD_DOMAINS_EMAILS_GROUP)\n    # Email\
    \ member number is required in order to send it in the unblock query\n    soup\
    \ = BeautifulSoup(blocked_emails.content, 'lxml')\n    # Handles pagination of\
    \ Local Bad Sender Domains\n    pages = soup.find('select', 'defaultDrop', id=\"\
    pageNumber\").find_all('option')\n    for i in range(len(pages)): # Loop through\
    \ all pages of blocked email addresses\n        tds_array = soup.find_all('td',\
    \ 'paddingL3') # Parse <td>\n        for td in tds_array:\n            a = td.find('a')\
    \ # Parse <a>\n            if a:\n                s = str(a.find_next_sibling(text=True))\
    \ # Get checked email address\n                checked_email = ''.join(s.split())\
    \ # Removes whitespaces from string\n                if checked_email == email:\n\
    \                    href = a['href'] # Get <a href=...>\n                   \
    \ comma_index = href.find(',') # Get comma sign index in string\n            \
    \        selected_group_member = a['href'][comma_index+1:-2] # Get email member\
    \ number\n                    break\n        # Get next page\n        next_page\
    \ = get_next_page(selected_sender_groups)\n        soup = BeautifulSoup(next_page.content,\
    \ 'lxml')\n\n    if not 'selected_group_member' in locals():\n        return 'Could\
    \ not find given email address in ' + BAD_DOMAINS_EMAILS_GROUP\n\n    unblock_request(selected_group_member,\
    \ selected_sender_groups)\n    context = {\n        'Address': email,\n      \
    \  'Blocked': False\n    }\n    ec = {\n        'Email(val.Address && val.Address\
    \ === obj.Address)': context\n    }\n    message = 'Email address ' + email +\
    \ ' was unblocked successfully.'\n    entry = {\n        'Type': entryTypes['note'],\n\
    \        'Contents': message,\n        'ContentsFormat': formats['json'],\n  \
    \      'ReadableContentsFormat': formats['markdown'],\n        'HumanReadable':\
    \ message,\n        'EntryContext': ec\n    }\n    return entry\n\ndef block_domain(domain):\n\
    \    selected_sender_groups = get_selected_sender_groups(BAD_DOMAINS_EMAILS_GROUP)\n\
    \    error_message = block_request(domain, selected_sender_groups)\n    if error_message:\n\
    \        return error_message\n    context = {\n        'Name': domain,\n    \
    \    'Blocked': True\n    }\n    ec = {\n        'Domain(val.Name && val.Name\
    \ === obj.Name)': context\n    }\n    message = 'Domain ' + domain + ' was blocked\
    \ successfully.'\n    entry = {\n        'Type': entryTypes['note'],\n       \
    \ 'Contents': message,\n        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': message,\n        'EntryContext':\
    \ ec\n    }\n    return entry\n\ndef unblock_domain(domain):\n    selected_sender_groups\
    \ = get_selected_sender_groups(BAD_DOMAINS_EMAILS_GROUP)\n    blocked_domains\
    \ = get_blocked_request(BAD_DOMAINS_EMAILS_GROUP)\n    # Domain member number\
    \ is required in order to send it in the unblock query\n    soup = BeautifulSoup(blocked_domains.content,\
    \ 'lxml')\n    # Handles pagination of Local Bad Sender Domains\n    pages = soup.find('select',\
    \ 'defaultDrop', id=\"pageNumber\").find_all('option')\n    for i in range(len(pages)):\
    \ # Loop through all pages of blocked domains\n        tds_array = soup.find_all('td',\
    \ 'paddingL3') # Parse <td>\n        for td in tds_array:\n            a = td.find('a')\
    \ # Parse <a>\n            if a:\n                s = str(a.find_next_sibling(text=True))\
    \ # Get checked domain\n                checked_domain = ''.join(s.split()) #\
    \ Removed whitespaces from string\n                if checked_domain == domain:\n\
    \                    href = a['href'] # Get <a href=...>\n                   \
    \ comma_index = href.find(',') # Get comma sign index in string\n            \
    \        selected_group_member = a['href'][comma_index+1:-2] # Get domain member\
    \ number\n                    break\n        # Get next page\n        next_page\
    \ = get_next_page(selected_sender_groups)\n        soup = BeautifulSoup(next_page.content,\
    \ 'lxml')\n\n    if not 'selected_group_member' in locals():\n        return 'Could\
    \ not find given domain in ' + BAD_DOMAINS_EMAILS_GROUP\n\n    unblock_request(selected_group_member,\
    \ selected_sender_groups)\n    context = {\n        'Name': domain,\n        'Blocked':\
    \ False\n    }\n    ec = {\n        'Domain(val.Name && val.Name === obj.Name)':\
    \ context\n    }\n    message = 'Domain ' + domain + ' was unblocked successfully.'\n\
    \    entry = {\n        'Type': entryTypes['note'],\n        'Contents': message,\n\
    \        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': message,\n        'EntryContext':\
    \ ec\n    }\n    return entry\n\ndef block_ip(ip):\n    selected_sender_groups\
    \ = get_selected_sender_groups(BAD_IPS_GROUP)\n    error_message = block_request(ip,\
    \ selected_sender_groups)\n    if error_message:\n        return error_message\n\
    \    context = {\n        'Address': ip,\n        'Blocked': True\n    }\n   \
    \ ec = {\n        'IP(val.Address && val.Address === obj.Address)': context\n\
    \    }\n    message = 'IP address ' + ip + ' was blocked successfully.'\n    entry\
    \ = {\n        'Type': entryTypes['note'],\n        'Contents': message,\n   \
    \     'ContentsFormat': formats['json'],\n        'ReadableContentsFormat': formats['markdown'],\n\
    \        'HumanReadable': message,\n        'EntryContext': ec\n    }\n    return\
    \ entry\n\ndef unblock_ip(ip):\n    selected_sender_groups = get_selected_sender_groups(BAD_IPS_GROUP)\n\
    \    blocked_ips =  get_blocked_request(BAD_IPS_GROUP)\n    # Domain member number\
    \ is required in order to send it in the unblock query\n    soup = BeautifulSoup(blocked_ips.content,\
    \ 'lxml')\n    # Handles pagination of Local Bad Sender IPs\n    pages = soup.find('select',\
    \ 'defaultDrop', id=\"pageNumber\").find_all('option')\n    for i in range(len(pages)):\
    \ # Loop through all pages of blocked IP address\n        tds_array = soup.find_all('td',\
    \ 'paddingL3') # Parse <td>\n        for td in tds_array:\n            a = td.find('a')\
    \ # Parse <a>\n            if a:\n                s = str(a.find_next_sibling(text=True))\
    \ # Get checked IP address\n                checked_ip = ''.join(s.split()) #\
    \ Removed whitespaces from string\n                if checked_ip == ip:\n    \
    \                href = a['href'] # Get <a href=...>\n                    comma_index\
    \ = href.find(',') # Get comma sign index in string\n                    selected_group_member\
    \ = a['href'][comma_index+1:-2] # Get IP member number\n                    break\n\
    \        next_page = get_next_page(selected_sender_groups)\n        soup = BeautifulSoup(next_page.content,\
    \ 'lxml')\n\n    if not 'selected_group_member' in locals():\n        return 'Could\
    \ not find given IP address in ' + BAD_IPS_GROUP\n\n    unblock_request(selected_group_member,\
    \ selected_sender_groups)\n    context = {\n        'Address': ip,\n        'Blocked':\
    \ False\n    }\n    ec = {\n        'IP(val.Address && val.Address === obj.Address)':\
    \ context\n    }\n    message = 'IP address ' + ip + ' was unblocked successfully.'\n\
    \    entry = {\n        'Type': entryTypes['note'],\n        'Contents': message,\n\
    \        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': message,\n        'EntryContext':\
    \ ec\n    }\n    return entry\n\n''' EXECUTION CODE '''\nTOKEN = login()\n\nLOG('command\
    \ is %s' % (demisto.command(), ))\ntry:\n    if demisto.command() == 'test-module':\n\
    \        # Checks authentication and connectivity in login() function\n      \
    \  demisto.results('ok')\n    elif demisto.command() == 'smg-block-email':\n \
    \       #demisto.results(get_selected_sender_groups())\n        demisto.results(block_email(demisto.args()['email']))\n\
    \    elif demisto.command() == 'smg-unblock-email':\n        demisto.results(unblock_email(demisto.args()['email']))\n\
    \    elif demisto.command() == 'smg-block-domain':\n        demisto.results(block_domain(demisto.args()['domain']))\n\
    \    elif demisto.command() == 'smg-block-ip':\n        demisto.results(block_ip(demisto.args()['ip']))\n\
    \    elif demisto.command() == 'smg-unblock-ip':\n        demisto.results(unblock_ip(demisto.args()['ip']))\n\
    \    elif demisto.command() == 'smg-unblock-domain':\n        demisto.results(unblock_domain(demisto.args()['domain']))\n\
    \    elif demisto.command() == 'smg-get-blocked-domains':\n        demisto.results(get_blocked_domains())\n\
    \    elif demisto.command() == 'smg-get-blocked-ips':\n        demisto.results(get_blocked_ips())\n\
    except Exception, e:\n    LOG(e.message)\n    LOG.print_log()\n    raise"
  subtype: python2
  type: python
toversion: 4.1.9
